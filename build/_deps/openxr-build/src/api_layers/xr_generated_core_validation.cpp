// *********** THIS FILE IS GENERATED - DO NOT EDIT ***********
//     See validation_layer_generator.py for modifications
// ************************************************************

// Copyright (c) 2017-2024, The Khronos Group Inc.
// Copyright (c) 2017-2019 Valve Corporation
// Copyright (c) 2017-2019 LunarG, Inc.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Mark Young <marky@lunarg.com>
//

#include "xr_generated_core_validation.hpp"

#include "api_layer_platform_defines.h"
#include "hex_and_handles.h"
#include "validation_utils.h"
#include "xr_dependencies.h"
#include "xr_generated_dispatch_table.h"

#include "api_layer_platform_defines.h"
#include "xr_dependencies.h"
#include <openxr/openxr.h>
#include <openxr/openxr_platform.h>

#include <algorithm>
#include <cstring>
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#ifdef __clang__
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif

// Structure used for indicating status of 'flags' test.
enum ValidateXrFlagsResult {
    VALIDATE_XR_FLAGS_ZERO,
    VALIDATE_XR_FLAGS_INVALID,
    VALIDATE_XR_FLAGS_SUCCESS,
};

// Unordered Map associating pointer to a vector of session label information to a session's handle
std::unordered_map<XrSession, std::vector<GenValidUsageXrInternalSessionLabel*>*> g_xr_session_labels;

InstanceHandleInfo g_instance_info;
HandleInfo<XrSession> g_session_info;
HandleInfo<XrSpace> g_space_info;
HandleInfo<XrAction> g_action_info;
HandleInfo<XrSwapchain> g_swapchain_info;
HandleInfo<XrActionSet> g_actionset_info;
HandleInfo<XrDebugUtilsMessengerEXT> g_debugutilsmessengerext_info;
HandleInfo<XrSpatialAnchorMSFT> g_spatialanchormsft_info;
HandleInfo<XrSpatialGraphNodeBindingMSFT> g_spatialgraphnodebindingmsft_info;
HandleInfo<XrHandTrackerEXT> g_handtrackerext_info;
HandleInfo<XrBodyTrackerFB> g_bodytrackerfb_info;
HandleInfo<XrSceneObserverMSFT> g_sceneobservermsft_info;
HandleInfo<XrSceneMSFT> g_scenemsft_info;
HandleInfo<XrFacialTrackerHTC> g_facialtrackerhtc_info;
HandleInfo<XrFoveationProfileFB> g_foveationprofilefb_info;
HandleInfo<XrTriangleMeshFB> g_trianglemeshfb_info;
HandleInfo<XrPassthroughFB> g_passthroughfb_info;
HandleInfo<XrPassthroughLayerFB> g_passthroughlayerfb_info;
HandleInfo<XrGeometryInstanceFB> g_geometryinstancefb_info;
HandleInfo<XrMarkerDetectorML> g_markerdetectorml_info;
HandleInfo<XrExportedLocalizationMapML> g_exportedlocalizationmapml_info;
HandleInfo<XrSpatialAnchorStoreConnectionMSFT> g_spatialanchorstoreconnectionmsft_info;
HandleInfo<XrSpaceUserFB> g_spaceuserfb_info;
HandleInfo<XrFaceTrackerFB> g_facetrackerfb_info;
HandleInfo<XrEyeTrackerFB> g_eyetrackerfb_info;
HandleInfo<XrVirtualKeyboardMETA> g_virtualkeyboardmeta_info;
HandleInfo<XrPassthroughColorLutMETA> g_passthroughcolorlutmeta_info;
HandleInfo<XrFaceTracker2FB> g_facetracker2fb_info;
HandleInfo<XrPassthroughHTC> g_passthroughhtc_info;
HandleInfo<XrPlaneDetectorEXT> g_planedetectorext_info;
ValidateXrHandleResult VerifyXrInstanceHandle(const XrInstance* handle_to_check);
ValidateXrHandleResult VerifyXrSessionHandle(const XrSession* handle_to_check);
ValidateXrHandleResult VerifyXrSpaceHandle(const XrSpace* handle_to_check);
ValidateXrHandleResult VerifyXrActionHandle(const XrAction* handle_to_check);
ValidateXrHandleResult VerifyXrSwapchainHandle(const XrSwapchain* handle_to_check);
ValidateXrHandleResult VerifyXrActionSetHandle(const XrActionSet* handle_to_check);
ValidateXrHandleResult VerifyXrDebugUtilsMessengerEXTHandle(const XrDebugUtilsMessengerEXT* handle_to_check);
ValidateXrHandleResult VerifyXrSpatialAnchorMSFTHandle(const XrSpatialAnchorMSFT* handle_to_check);
ValidateXrHandleResult VerifyXrSpatialGraphNodeBindingMSFTHandle(const XrSpatialGraphNodeBindingMSFT* handle_to_check);
ValidateXrHandleResult VerifyXrHandTrackerEXTHandle(const XrHandTrackerEXT* handle_to_check);
ValidateXrHandleResult VerifyXrBodyTrackerFBHandle(const XrBodyTrackerFB* handle_to_check);
ValidateXrHandleResult VerifyXrSceneObserverMSFTHandle(const XrSceneObserverMSFT* handle_to_check);
ValidateXrHandleResult VerifyXrSceneMSFTHandle(const XrSceneMSFT* handle_to_check);
ValidateXrHandleResult VerifyXrFacialTrackerHTCHandle(const XrFacialTrackerHTC* handle_to_check);
ValidateXrHandleResult VerifyXrFoveationProfileFBHandle(const XrFoveationProfileFB* handle_to_check);
ValidateXrHandleResult VerifyXrTriangleMeshFBHandle(const XrTriangleMeshFB* handle_to_check);
ValidateXrHandleResult VerifyXrPassthroughFBHandle(const XrPassthroughFB* handle_to_check);
ValidateXrHandleResult VerifyXrPassthroughLayerFBHandle(const XrPassthroughLayerFB* handle_to_check);
ValidateXrHandleResult VerifyXrGeometryInstanceFBHandle(const XrGeometryInstanceFB* handle_to_check);
ValidateXrHandleResult VerifyXrMarkerDetectorMLHandle(const XrMarkerDetectorML* handle_to_check);
ValidateXrHandleResult VerifyXrExportedLocalizationMapMLHandle(const XrExportedLocalizationMapML* handle_to_check);
ValidateXrHandleResult VerifyXrSpatialAnchorStoreConnectionMSFTHandle(const XrSpatialAnchorStoreConnectionMSFT* handle_to_check);
ValidateXrHandleResult VerifyXrSpaceUserFBHandle(const XrSpaceUserFB* handle_to_check);
ValidateXrHandleResult VerifyXrFaceTrackerFBHandle(const XrFaceTrackerFB* handle_to_check);
ValidateXrHandleResult VerifyXrEyeTrackerFBHandle(const XrEyeTrackerFB* handle_to_check);
ValidateXrHandleResult VerifyXrVirtualKeyboardMETAHandle(const XrVirtualKeyboardMETA* handle_to_check);
ValidateXrHandleResult VerifyXrPassthroughColorLutMETAHandle(const XrPassthroughColorLutMETA* handle_to_check);
ValidateXrHandleResult VerifyXrFaceTracker2FBHandle(const XrFaceTracker2FB* handle_to_check);
ValidateXrHandleResult VerifyXrPassthroughHTCHandle(const XrPassthroughHTC* handle_to_check);
ValidateXrHandleResult VerifyXrPlaneDetectorEXTHandle(const XrPlaneDetectorEXT* handle_to_check);

// Write out prototypes for handle parent verification functions
bool VerifyXrParent(XrObjectType handle1_type, const uint64_t handle1,
                    XrObjectType handle2_type, const uint64_t handle2,
                    bool check_this);

// Function to check if an extension has been enabled
bool ExtensionEnabled(const std::vector<std::string> &extensions, const char* const check_extension_name);

// Functions to validate structures
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrApiLayerProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtensionProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrApplicationInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataBuffer* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemGetInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemGraphicsProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemTrackingProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector3f* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceVelocity* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrQuaternionf* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPosef* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrReferenceSpaceCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent2Df* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSpaceCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceLocation* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationProperties* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationView* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageBaseHeader* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageAcquireInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageWaitInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageReleaseInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionBeginInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameWaitInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameState* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameBeginInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerBaseHeader* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameEndInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewLocateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewState* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFovf* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrView* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSetCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionCreateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSuggestedBinding* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileSuggestedBinding* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionActionSetsAttachInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileState* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateGetInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateBoolean* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateFloat* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector2f* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateVector2f* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStatePose* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSet* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionsSyncInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBoundSourcesForActionEnumerateInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInputSourceLocalizedNameGetInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticActionInfo* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticBaseHeader* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBaseInStructure* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBaseOutStructure* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset2Di* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent2Di* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect2Di* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainSubImage* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerProjectionView* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerProjection* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerQuad* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataBaseHeader* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataEventsLost* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataInstanceLossPending* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSessionStateChanged* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataReferenceSpaceChangePending* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataInteractionProfileChanged* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticVibration* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset2Df* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect2Df* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector4f* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrColor4f* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerCubeKHR* value);
#if defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceCreateInfoAndroidKHR* value);
#endif // defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthInfoKHR* value);
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanSwapchainFormatListCreateInfoKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerCylinderKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerEquirectKHR* value);
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLWin32KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLXlibKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLXcbKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLWaylandKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageOpenGLKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsOpenGLKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLESAndroidKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageOpenGLESKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsOpenGLESKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingVulkanKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageVulkanKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsVulkanKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingD3D11KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageD3D11KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsD3D11KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingD3D12KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageD3D12KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsD3D12KHR* value);
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVisibilityMaskKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVisibilityMaskChangedKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerColorScaleBiasKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLoaderInitInfoBaseHeaderKHR* value);
#if defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLoaderInitInfoAndroidKHR* value);
#endif // defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanInstanceCreateInfoKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanDeviceCreateInfoKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanGraphicsDeviceGetInfoKHR* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerEquirect2KHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBindingModificationBaseHeaderKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBindingModificationsKHR* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataPerfSettingsEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsObjectNameInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsLabelEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsMessengerCallbackDataEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsMessengerCreateInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemEyeGazeInteractionPropertiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazeSampleTimeEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionCreateInfoOverlayEXTX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataMainSessionVisibilityChangedEXTX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorSpaceCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerImageLayoutFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerAlphaBlendFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationDepthRangeEXT* value);
#if defined(XR_USE_PLATFORM_EGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingEGLMNDX* value);
#endif // defined(XR_USE_PLATFORM_EGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeSpaceCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeBindingPropertiesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHandTrackingPropertiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackerCreateInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointsLocateInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointLocationEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointVelocityEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointLocationsEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointVelocitiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHandTrackingMeshPropertiesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshSpaceCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshUpdateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshIndexBufferMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshVertexMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshVertexBufferMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandPoseTypeInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationSessionBeginInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationStateMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationFrameStateMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationLayerInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationFrameEndInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelKeyStateMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelNodePropertiesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelPropertiesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelNodeStateMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelStateMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationViewFovEPIC* value);
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHolographicWindowAttachmentMSFT* value);
#endif // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerReprojectionInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerReprojectionPlaneOverrideMSFT* value);
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrAndroidSurfaceSwapchainCreateInfoFB* value);
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateBaseHeaderFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSecureContentFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointLocationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemBodyTrackingPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyTrackerCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodySkeletonJointFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodySkeletonFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointsLocateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointLocationsFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileDpadBindingEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileAnalogThresholdVALVE* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointsMotionRangeInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUuidMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObserverCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneSphereBoundMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneOrientedBoxBoundMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneFrustumBoundMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneBoundsMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrNewSceneComputeInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVisualMeshComputeLodInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsGetInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentLocationMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentLocationsMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsLocateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectsMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentParentFilterInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectTypesFilterInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlaneMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlanesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlaneAlignmentFilterInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshBuffersGetInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshBuffersMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshVertexBufferMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshIndicesUint32MSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshIndicesUint16MSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSerializedSceneFragmentDataGetInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDeserializeSceneFragmentMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneDeserializeInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataDisplayRefreshRateChangedFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViveTrackerPathsHTCX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataViveTrackerConnectedHTCX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFacialTrackingPropertiesHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFacialExpressionsHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFacialTrackerCreateInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemColorSpacePropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector4sFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingMeshFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingScaleFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingAimStateFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandCapsuleFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingCapsulesStateFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemSpatialEntityPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentStatusSetInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentStatusFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUuidEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpatialAnchorCreateCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceSetStatusCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationProfileCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainCreateInfoFoveationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateFoveationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationLevelProfileCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemKeyboardTrackingPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardTrackingDescriptionFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardSpaceCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardTrackingQueryFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrTriangleMeshCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughProperties2FB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughLayerCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerPassthroughFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGeometryInstanceCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGeometryInstanceTransformFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughStyleFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapMonoToRgbaFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapMonoToMonoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughBrightnessContrastSaturationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataPassthroughStateChangedFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelPathInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelBufferFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelLoadInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemRenderModelPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelCapabilitiesRequestFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewLocateFoveatedRenderingVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveatedViewConfigurationViewVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFoveatedRenderingPropertiesVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthTestVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemMarkerTrackingPropertiesVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataMarkerTrackingUpdateVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerSpaceCreateInfoVARJO* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameEndInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGlobalDimmerFrameEndInfoML* value);
#if defined(XR_USE_PLATFORM_ML)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCoordinateSpaceCreateInfoML* value);
#endif // defined(XR_USE_PLATFORM_ML)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemMarkerUnderstandingPropertiesML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorCreateInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorArucoInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorSizeInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorAprilTagInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorCustomProfileInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorSnapshotInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorStateML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerSpaceCreateInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataLocalizationChangedML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapQueryInfoBaseHeaderML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMapLocalizationRequestInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapImportInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationEnableEventsInfoML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorPersistenceNameMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorPersistenceInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkersMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerTypeFilterMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerQRCodeMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerQRCodesMSFT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryInfoBaseHeaderFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceFilterInfoBaseHeaderFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceStorageLocationFilterInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceUuidFilterInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentFilterInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryResultFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryResultsFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceQueryResultsAvailableFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceQueryCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceSaveInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceEraseInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceSaveCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceEraseCompleteFB* value);
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageFoveationVulkanFB* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateAndroidSurfaceDimensionsFB* value);
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateSamplerOpenGLESFB* value);
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateSamplerVulkanFB* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceShareInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceShareCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSpaceWarpInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemSpaceWarpPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticAmplitudeEnvelopeVibrationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent3DfFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset3DfFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect3DfFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSemanticLabelsFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRoomLayoutFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBoundary2DFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSemanticLabelsSupportInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDigitalLensControlALMALENCE* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSceneCaptureCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneCaptureRequestInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceContainerFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationEyeTrackedProfileCreateInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationEyeTrackedStateMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFoveationEyeTrackedPropertiesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFaceTrackingPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceTrackerCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionStatusFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionWeightsFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazeFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeTrackerCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazesInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemEyeTrackingPropertiesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazesFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughKeyboardHandsIntensityFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSettingsFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticPcmVibrationFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDevicePcmSampleRateStateFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthTestFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalDimmingFrameEndInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughPreferencesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemVirtualKeyboardPropertiesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardCreateInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardSpaceCreateInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardLocationInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardModelVisibilitySetInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardAnimationStateMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardModelAnimationStatesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardTextureDataMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardInputInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardTextContextChangeInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardCommitTextMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardBackspaceMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardEnterMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardShownMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardHiddenMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraIntrinsicsOCULUS* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraExtrinsicsOCULUS* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraOCULUS* value);
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanSwapchainCreateInfoMETA* value);
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPerformanceMetricsStateMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPerformanceMetricsCounterMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceListSaveInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceListSaveCompleteFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceUserCreateInfoFB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHeadsetIdPropertiesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRecommendedLayerResolutionMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRecommendedLayerResolutionGetInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutDataMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutCreateInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutUpdateInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapLutMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapInterpolatedLutMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughColorLutPropertiesMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceTriangleMeshGetInfoMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceTriangleMeshMETA* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFaceTrackingProperties2FB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceTrackerCreateInfo2FB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionInfo2FB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionWeights2FB* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughCreateInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughMeshTransformInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerPassthroughHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationApplyInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationConfigurationHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationDynamicModeInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationCustomModeInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemAnchorPropertiesHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorNameHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoHTC* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSetPriorityEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSetPrioritiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemForceFeedbackCurlPropertiesMNDX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrForceFeedbackCurlApplyLocationMNDX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrForceFeedbackCurlApplyLocationsMNDX* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingDataSourceInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingDataSourceStateEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPlaneDetectionPropertiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorCreateInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent3DfEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorBeginInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorGetInfoEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorLocationEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorLocationsEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorPolygonBufferEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataUserPresenceChangedEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemUserPresencePropertiesEXT* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataHeadsetFitChangedML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataEyeCalibrationChangedML* value);
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUserCalibrationEnableEventsInfoML* value);
// Function used to clean up any residual map values that point to an instance prior to that
// instance being deleted.
void GenValidUsageCleanUpMaps(GenValidUsageXrInstanceInfo *instance_info) {
    EraseAllInstanceTableMapElements(instance_info);
    g_session_info.removeHandlesForInstance(instance_info);
    g_space_info.removeHandlesForInstance(instance_info);
    g_action_info.removeHandlesForInstance(instance_info);
    g_swapchain_info.removeHandlesForInstance(instance_info);
    g_actionset_info.removeHandlesForInstance(instance_info);
    g_debugutilsmessengerext_info.removeHandlesForInstance(instance_info);
    g_spatialanchormsft_info.removeHandlesForInstance(instance_info);
    g_spatialgraphnodebindingmsft_info.removeHandlesForInstance(instance_info);
    g_handtrackerext_info.removeHandlesForInstance(instance_info);
    g_bodytrackerfb_info.removeHandlesForInstance(instance_info);
    g_sceneobservermsft_info.removeHandlesForInstance(instance_info);
    g_scenemsft_info.removeHandlesForInstance(instance_info);
    g_facialtrackerhtc_info.removeHandlesForInstance(instance_info);
    g_foveationprofilefb_info.removeHandlesForInstance(instance_info);
    g_trianglemeshfb_info.removeHandlesForInstance(instance_info);
    g_passthroughfb_info.removeHandlesForInstance(instance_info);
    g_passthroughlayerfb_info.removeHandlesForInstance(instance_info);
    g_geometryinstancefb_info.removeHandlesForInstance(instance_info);
    g_markerdetectorml_info.removeHandlesForInstance(instance_info);
    g_exportedlocalizationmapml_info.removeHandlesForInstance(instance_info);
    g_spatialanchorstoreconnectionmsft_info.removeHandlesForInstance(instance_info);
    g_spaceuserfb_info.removeHandlesForInstance(instance_info);
    g_facetrackerfb_info.removeHandlesForInstance(instance_info);
    g_eyetrackerfb_info.removeHandlesForInstance(instance_info);
    g_virtualkeyboardmeta_info.removeHandlesForInstance(instance_info);
    g_passthroughcolorlutmeta_info.removeHandlesForInstance(instance_info);
    g_facetracker2fb_info.removeHandlesForInstance(instance_info);
    g_passthroughhtc_info.removeHandlesForInstance(instance_info);
    g_planedetectorext_info.removeHandlesForInstance(instance_info);
}

// Function to convert XrObjectType to string
std::string GenValidUsageXrObjectTypeToString(const XrObjectType& type) {
    std::string object_string;
    if (type == XR_OBJECT_TYPE_UNKNOWN) {
        object_string = "Unknown XR Object";
    } else if (type == XR_OBJECT_TYPE_INSTANCE) {
        object_string = "XrInstance";
    } else if (type == XR_OBJECT_TYPE_SESSION) {
        object_string = "XrSession";
    } else if (type == XR_OBJECT_TYPE_SWAPCHAIN) {
        object_string = "XrSwapchain";
    } else if (type == XR_OBJECT_TYPE_SPACE) {
        object_string = "XrSpace";
    } else if (type == XR_OBJECT_TYPE_ACTION_SET) {
        object_string = "XrActionSet";
    } else if (type == XR_OBJECT_TYPE_ACTION) {
        object_string = "XrAction";
    } else if (type == XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT) {
        object_string = "XrDebugUtilsMessengerEXT";
    } else if (type == XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT) {
        object_string = "XrSpatialAnchorMSFT";
    } else if (type == XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT) {
        object_string = "XrSpatialGraphNodeBindingMSFT";
    } else if (type == XR_OBJECT_TYPE_HAND_TRACKER_EXT) {
        object_string = "XrHandTrackerEXT";
    } else if (type == XR_OBJECT_TYPE_BODY_TRACKER_FB) {
        object_string = "XrBodyTrackerFB";
    } else if (type == XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT) {
        object_string = "XrSceneObserverMSFT";
    } else if (type == XR_OBJECT_TYPE_SCENE_MSFT) {
        object_string = "XrSceneMSFT";
    } else if (type == XR_OBJECT_TYPE_FACIAL_TRACKER_HTC) {
        object_string = "XrFacialTrackerHTC";
    } else if (type == XR_OBJECT_TYPE_FOVEATION_PROFILE_FB) {
        object_string = "XrFoveationProfileFB";
    } else if (type == XR_OBJECT_TYPE_TRIANGLE_MESH_FB) {
        object_string = "XrTriangleMeshFB";
    } else if (type == XR_OBJECT_TYPE_PASSTHROUGH_FB) {
        object_string = "XrPassthroughFB";
    } else if (type == XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB) {
        object_string = "XrPassthroughLayerFB";
    } else if (type == XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB) {
        object_string = "XrGeometryInstanceFB";
    } else if (type == XR_OBJECT_TYPE_MARKER_DETECTOR_ML) {
        object_string = "XrMarkerDetectorML";
    } else if (type == XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML) {
        object_string = "XrExportedLocalizationMapML";
    } else if (type == XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT) {
        object_string = "XrSpatialAnchorStoreConnectionMSFT";
    } else if (type == XR_OBJECT_TYPE_FACE_TRACKER_FB) {
        object_string = "XrFaceTrackerFB";
    } else if (type == XR_OBJECT_TYPE_EYE_TRACKER_FB) {
        object_string = "XrEyeTrackerFB";
    } else if (type == XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META) {
        object_string = "XrVirtualKeyboardMETA";
    } else if (type == XR_OBJECT_TYPE_SPACE_USER_FB) {
        object_string = "XrSpaceUserFB";
    } else if (type == XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META) {
        object_string = "XrPassthroughColorLutMETA";
    } else if (type == XR_OBJECT_TYPE_FACE_TRACKER2_FB) {
        object_string = "XrFaceTracker2FB";
    } else if (type == XR_OBJECT_TYPE_PASSTHROUGH_HTC) {
        object_string = "XrPassthroughHTC";
    } else if (type == XR_OBJECT_TYPE_PLANE_DETECTOR_EXT) {
        object_string = "XrPlaneDetectorEXT";
    }
    return object_string;
}

// Structure used for state validation.

// Result return value for next chain validation
enum NextChainResult {
    NEXT_CHAIN_RESULT_VALID = 0,
    NEXT_CHAIN_RESULT_ERROR = -1,
    NEXT_CHAIN_RESULT_DUPLICATE_STRUCT = -2,
};

// Prototype for validateNextChain command (it uses the validate structure commands so add it after
NextChainResult ValidateNextChain(GenValidUsageXrInstanceInfo *instance_info,
                                  const std::string &command_name,
                                  std::vector<GenValidUsageXrObjectInfo>& objects_info,
                                  const void* next,
                                  std::vector<XrStructureType>& valid_ext_structs,
                                  std::vector<XrStructureType>& encountered_structs,
                                  std::vector<XrStructureType>& duplicate_structs);

// Function to validate XrInstanceCreateFlags flags
ValidateXrFlagsResult ValidateXrInstanceCreateFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSessionCreateFlags flags
ValidateXrFlagsResult ValidateXrSessionCreateFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSpaceVelocityFlags flags
ValidateXrFlagsResult ValidateXrSpaceVelocityFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SPACE_VELOCITY_LINEAR_VALID_BIT) != 0) {
        // Clear the value XR_SPACE_VELOCITY_LINEAR_VALID_BIT since it is valid
        int_value &= ~XR_SPACE_VELOCITY_LINEAR_VALID_BIT;
    }
    if ((int_value & XR_SPACE_VELOCITY_ANGULAR_VALID_BIT) != 0) {
        // Clear the value XR_SPACE_VELOCITY_ANGULAR_VALID_BIT since it is valid
        int_value &= ~XR_SPACE_VELOCITY_ANGULAR_VALID_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSpaceLocationFlags flags
ValidateXrFlagsResult ValidateXrSpaceLocationFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SPACE_LOCATION_ORIENTATION_VALID_BIT) != 0) {
        // Clear the value XR_SPACE_LOCATION_ORIENTATION_VALID_BIT since it is valid
        int_value &= ~XR_SPACE_LOCATION_ORIENTATION_VALID_BIT;
    }
    if ((int_value & XR_SPACE_LOCATION_POSITION_VALID_BIT) != 0) {
        // Clear the value XR_SPACE_LOCATION_POSITION_VALID_BIT since it is valid
        int_value &= ~XR_SPACE_LOCATION_POSITION_VALID_BIT;
    }
    if ((int_value & XR_SPACE_LOCATION_ORIENTATION_TRACKED_BIT) != 0) {
        // Clear the value XR_SPACE_LOCATION_ORIENTATION_TRACKED_BIT since it is valid
        int_value &= ~XR_SPACE_LOCATION_ORIENTATION_TRACKED_BIT;
    }
    if ((int_value & XR_SPACE_LOCATION_POSITION_TRACKED_BIT) != 0) {
        // Clear the value XR_SPACE_LOCATION_POSITION_TRACKED_BIT since it is valid
        int_value &= ~XR_SPACE_LOCATION_POSITION_TRACKED_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSwapchainCreateFlags flags
ValidateXrFlagsResult ValidateXrSwapchainCreateFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SWAPCHAIN_CREATE_PROTECTED_CONTENT_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_CREATE_PROTECTED_CONTENT_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_CREATE_PROTECTED_CONTENT_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_CREATE_STATIC_IMAGE_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_CREATE_STATIC_IMAGE_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_CREATE_STATIC_IMAGE_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSwapchainUsageFlags flags
ValidateXrFlagsResult ValidateXrSwapchainUsageFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_SAMPLED_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_SAMPLED_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_SAMPLED_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND;
    }
    if ((int_value & XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR) != 0) {
        // Clear the value XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR since it is valid
        int_value &= ~XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrCompositionLayerFlags flags
ValidateXrFlagsResult ValidateXrCompositionLayerFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT;
    }
    if ((int_value & XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT;
    }
    if ((int_value & XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrViewStateFlags flags
ValidateXrFlagsResult ValidateXrViewStateFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_VIEW_STATE_ORIENTATION_VALID_BIT) != 0) {
        // Clear the value XR_VIEW_STATE_ORIENTATION_VALID_BIT since it is valid
        int_value &= ~XR_VIEW_STATE_ORIENTATION_VALID_BIT;
    }
    if ((int_value & XR_VIEW_STATE_POSITION_VALID_BIT) != 0) {
        // Clear the value XR_VIEW_STATE_POSITION_VALID_BIT since it is valid
        int_value &= ~XR_VIEW_STATE_POSITION_VALID_BIT;
    }
    if ((int_value & XR_VIEW_STATE_ORIENTATION_TRACKED_BIT) != 0) {
        // Clear the value XR_VIEW_STATE_ORIENTATION_TRACKED_BIT since it is valid
        int_value &= ~XR_VIEW_STATE_ORIENTATION_TRACKED_BIT;
    }
    if ((int_value & XR_VIEW_STATE_POSITION_TRACKED_BIT) != 0) {
        // Clear the value XR_VIEW_STATE_POSITION_TRACKED_BIT since it is valid
        int_value &= ~XR_VIEW_STATE_POSITION_TRACKED_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrInputSourceLocalizedNameFlags flags
ValidateXrFlagsResult ValidateXrInputSourceLocalizedNameFlags(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_INPUT_SOURCE_LOCALIZED_NAME_USER_PATH_BIT) != 0) {
        // Clear the value XR_INPUT_SOURCE_LOCALIZED_NAME_USER_PATH_BIT since it is valid
        int_value &= ~XR_INPUT_SOURCE_LOCALIZED_NAME_USER_PATH_BIT;
    }
    if ((int_value & XR_INPUT_SOURCE_LOCALIZED_NAME_INTERACTION_PROFILE_BIT) != 0) {
        // Clear the value XR_INPUT_SOURCE_LOCALIZED_NAME_INTERACTION_PROFILE_BIT since it is valid
        int_value &= ~XR_INPUT_SOURCE_LOCALIZED_NAME_INTERACTION_PROFILE_BIT;
    }
    if ((int_value & XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT) != 0) {
        // Clear the value XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT since it is valid
        int_value &= ~XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
// Function to validate XrVulkanInstanceCreateFlagsKHR flags
ValidateXrFlagsResult ValidateXrVulkanInstanceCreateFlagsKHR(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
// Function to validate XrVulkanDeviceCreateFlagsKHR flags
ValidateXrFlagsResult ValidateXrVulkanDeviceCreateFlagsKHR(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
// Function to validate XrDebugUtilsMessageSeverityFlagsEXT flags
ValidateXrFlagsResult ValidateXrDebugUtilsMessageSeverityFlagsEXT(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrDebugUtilsMessageTypeFlagsEXT flags
ValidateXrFlagsResult ValidateXrDebugUtilsMessageTypeFlagsEXT(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    }
    if ((int_value & XR_DEBUG_UTILS_MESSAGE_TYPE_CONFORMANCE_BIT_EXT) != 0) {
        // Clear the value XR_DEBUG_UTILS_MESSAGE_TYPE_CONFORMANCE_BIT_EXT since it is valid
        int_value &= ~XR_DEBUG_UTILS_MESSAGE_TYPE_CONFORMANCE_BIT_EXT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrOverlaySessionCreateFlagsEXTX flags
ValidateXrFlagsResult ValidateXrOverlaySessionCreateFlagsEXTX(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrOverlayMainSessionFlagsEXTX flags
ValidateXrFlagsResult ValidateXrOverlayMainSessionFlagsEXTX(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_OVERLAY_MAIN_SESSION_ENABLED_COMPOSITION_LAYER_INFO_DEPTH_BIT_EXTX) != 0) {
        // Clear the value XR_OVERLAY_MAIN_SESSION_ENABLED_COMPOSITION_LAYER_INFO_DEPTH_BIT_EXTX since it is valid
        int_value &= ~XR_OVERLAY_MAIN_SESSION_ENABLED_COMPOSITION_LAYER_INFO_DEPTH_BIT_EXTX;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrCompositionLayerImageLayoutFlagsFB flags
ValidateXrFlagsResult ValidateXrCompositionLayerImageLayoutFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_COMPOSITION_LAYER_IMAGE_LAYOUT_VERTICAL_FLIP_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_IMAGE_LAYOUT_VERTICAL_FLIP_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_IMAGE_LAYOUT_VERTICAL_FLIP_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

#if defined(XR_USE_PLATFORM_ANDROID)
// Function to validate XrAndroidSurfaceSwapchainFlagsFB flags
ValidateXrFlagsResult ValidateXrAndroidSurfaceSwapchainFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_ANDROID_SURFACE_SWAPCHAIN_SYNCHRONOUS_BIT_FB) != 0) {
        // Clear the value XR_ANDROID_SURFACE_SWAPCHAIN_SYNCHRONOUS_BIT_FB since it is valid
        int_value &= ~XR_ANDROID_SURFACE_SWAPCHAIN_SYNCHRONOUS_BIT_FB;
    }
    if ((int_value & XR_ANDROID_SURFACE_SWAPCHAIN_USE_TIMESTAMPS_BIT_FB) != 0) {
        // Clear the value XR_ANDROID_SURFACE_SWAPCHAIN_USE_TIMESTAMPS_BIT_FB since it is valid
        int_value &= ~XR_ANDROID_SURFACE_SWAPCHAIN_USE_TIMESTAMPS_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

#endif // defined(XR_USE_PLATFORM_ANDROID)
// Function to validate XrCompositionLayerSecureContentFlagsFB flags
ValidateXrFlagsResult ValidateXrCompositionLayerSecureContentFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_COMPOSITION_LAYER_SECURE_CONTENT_EXCLUDE_LAYER_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SECURE_CONTENT_EXCLUDE_LAYER_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SECURE_CONTENT_EXCLUDE_LAYER_BIT_FB;
    }
    if ((int_value & XR_COMPOSITION_LAYER_SECURE_CONTENT_REPLACE_LAYER_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SECURE_CONTENT_REPLACE_LAYER_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SECURE_CONTENT_REPLACE_LAYER_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrHandTrackingAimFlagsFB flags
ValidateXrFlagsResult ValidateXrHandTrackingAimFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_HAND_TRACKING_AIM_COMPUTED_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_COMPUTED_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_COMPUTED_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_VALID_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_VALID_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_VALID_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_INDEX_PINCHING_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_INDEX_PINCHING_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_INDEX_PINCHING_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_MIDDLE_PINCHING_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_MIDDLE_PINCHING_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_MIDDLE_PINCHING_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_RING_PINCHING_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_RING_PINCHING_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_RING_PINCHING_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_LITTLE_PINCHING_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_LITTLE_PINCHING_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_LITTLE_PINCHING_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_SYSTEM_GESTURE_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_SYSTEM_GESTURE_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_SYSTEM_GESTURE_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_DOMINANT_HAND_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_DOMINANT_HAND_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_DOMINANT_HAND_BIT_FB;
    }
    if ((int_value & XR_HAND_TRACKING_AIM_MENU_PRESSED_BIT_FB) != 0) {
        // Clear the value XR_HAND_TRACKING_AIM_MENU_PRESSED_BIT_FB since it is valid
        int_value &= ~XR_HAND_TRACKING_AIM_MENU_PRESSED_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSwapchainCreateFoveationFlagsFB flags
ValidateXrFlagsResult ValidateXrSwapchainCreateFoveationFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SWAPCHAIN_CREATE_FOVEATION_SCALED_BIN_BIT_FB) != 0) {
        // Clear the value XR_SWAPCHAIN_CREATE_FOVEATION_SCALED_BIN_BIT_FB since it is valid
        int_value &= ~XR_SWAPCHAIN_CREATE_FOVEATION_SCALED_BIN_BIT_FB;
    }
    if ((int_value & XR_SWAPCHAIN_CREATE_FOVEATION_FRAGMENT_DENSITY_MAP_BIT_FB) != 0) {
        // Clear the value XR_SWAPCHAIN_CREATE_FOVEATION_FRAGMENT_DENSITY_MAP_BIT_FB since it is valid
        int_value &= ~XR_SWAPCHAIN_CREATE_FOVEATION_FRAGMENT_DENSITY_MAP_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSwapchainStateFoveationFlagsFB flags
ValidateXrFlagsResult ValidateXrSwapchainStateFoveationFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrKeyboardTrackingFlagsFB flags
ValidateXrFlagsResult ValidateXrKeyboardTrackingFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_KEYBOARD_TRACKING_EXISTS_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_EXISTS_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_EXISTS_BIT_FB;
    }
    if ((int_value & XR_KEYBOARD_TRACKING_LOCAL_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_LOCAL_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_LOCAL_BIT_FB;
    }
    if ((int_value & XR_KEYBOARD_TRACKING_REMOTE_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_REMOTE_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_REMOTE_BIT_FB;
    }
    if ((int_value & XR_KEYBOARD_TRACKING_CONNECTED_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_CONNECTED_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_CONNECTED_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrKeyboardTrackingQueryFlagsFB flags
ValidateXrFlagsResult ValidateXrKeyboardTrackingQueryFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB;
    }
    if ((int_value & XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB) != 0) {
        // Clear the value XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB since it is valid
        int_value &= ~XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrTriangleMeshFlagsFB flags
ValidateXrFlagsResult ValidateXrTriangleMeshFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_TRIANGLE_MESH_MUTABLE_BIT_FB) != 0) {
        // Clear the value XR_TRIANGLE_MESH_MUTABLE_BIT_FB since it is valid
        int_value &= ~XR_TRIANGLE_MESH_MUTABLE_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPassthroughCapabilityFlagsFB flags
ValidateXrFlagsResult ValidateXrPassthroughCapabilityFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PASSTHROUGH_CAPABILITY_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_CAPABILITY_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_CAPABILITY_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_CAPABILITY_COLOR_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_CAPABILITY_COLOR_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_CAPABILITY_COLOR_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_CAPABILITY_LAYER_DEPTH_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_CAPABILITY_LAYER_DEPTH_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_CAPABILITY_LAYER_DEPTH_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPassthroughFlagsFB flags
ValidateXrFlagsResult ValidateXrPassthroughFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PASSTHROUGH_IS_RUNNING_AT_CREATION_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_IS_RUNNING_AT_CREATION_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_IS_RUNNING_AT_CREATION_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_LAYER_DEPTH_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_LAYER_DEPTH_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_LAYER_DEPTH_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPassthroughStateChangedFlagsFB flags
ValidateXrFlagsResult ValidateXrPassthroughStateChangedFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PASSTHROUGH_STATE_CHANGED_REINIT_REQUIRED_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_STATE_CHANGED_REINIT_REQUIRED_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_STATE_CHANGED_REINIT_REQUIRED_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_STATE_CHANGED_NON_RECOVERABLE_ERROR_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_STATE_CHANGED_NON_RECOVERABLE_ERROR_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_STATE_CHANGED_NON_RECOVERABLE_ERROR_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_STATE_CHANGED_RECOVERABLE_ERROR_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_STATE_CHANGED_RECOVERABLE_ERROR_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_STATE_CHANGED_RECOVERABLE_ERROR_BIT_FB;
    }
    if ((int_value & XR_PASSTHROUGH_STATE_CHANGED_RESTORED_ERROR_BIT_FB) != 0) {
        // Clear the value XR_PASSTHROUGH_STATE_CHANGED_RESTORED_ERROR_BIT_FB since it is valid
        int_value &= ~XR_PASSTHROUGH_STATE_CHANGED_RESTORED_ERROR_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrRenderModelFlagsFB flags
ValidateXrFlagsResult ValidateXrRenderModelFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB) != 0) {
        // Clear the value XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB since it is valid
        int_value &= ~XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB;
    }
    if ((int_value & XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_2_BIT_FB) != 0) {
        // Clear the value XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_2_BIT_FB since it is valid
        int_value &= ~XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_2_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrFrameEndInfoFlagsML flags
ValidateXrFlagsResult ValidateXrFrameEndInfoFlagsML(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_FRAME_END_INFO_PROTECTED_BIT_ML) != 0) {
        // Clear the value XR_FRAME_END_INFO_PROTECTED_BIT_ML since it is valid
        int_value &= ~XR_FRAME_END_INFO_PROTECTED_BIT_ML;
    }
    if ((int_value & XR_FRAME_END_INFO_VIGNETTE_BIT_ML) != 0) {
        // Clear the value XR_FRAME_END_INFO_VIGNETTE_BIT_ML since it is valid
        int_value &= ~XR_FRAME_END_INFO_VIGNETTE_BIT_ML;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrGlobalDimmerFrameEndInfoFlagsML flags
ValidateXrFlagsResult ValidateXrGlobalDimmerFrameEndInfoFlagsML(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_GLOBAL_DIMMER_FRAME_END_INFO_ENABLED_BIT_ML) != 0) {
        // Clear the value XR_GLOBAL_DIMMER_FRAME_END_INFO_ENABLED_BIT_ML since it is valid
        int_value &= ~XR_GLOBAL_DIMMER_FRAME_END_INFO_ENABLED_BIT_ML;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrLocalizationMapErrorFlagsML flags
ValidateXrFlagsResult ValidateXrLocalizationMapErrorFlagsML(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_UNKNOWN_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_UNKNOWN_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_UNKNOWN_BIT_ML;
    }
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_OUT_OF_MAPPED_AREA_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_OUT_OF_MAPPED_AREA_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_OUT_OF_MAPPED_AREA_BIT_ML;
    }
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_LOW_FEATURE_COUNT_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_LOW_FEATURE_COUNT_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_LOW_FEATURE_COUNT_BIT_ML;
    }
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_EXCESSIVE_MOTION_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_EXCESSIVE_MOTION_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_EXCESSIVE_MOTION_BIT_ML;
    }
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_LOW_LIGHT_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_LOW_LIGHT_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_LOW_LIGHT_BIT_ML;
    }
    if ((int_value & XR_LOCALIZATION_MAP_ERROR_HEADPOSE_BIT_ML) != 0) {
        // Clear the value XR_LOCALIZATION_MAP_ERROR_HEADPOSE_BIT_ML since it is valid
        int_value &= ~XR_LOCALIZATION_MAP_ERROR_HEADPOSE_BIT_ML;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrCompositionLayerSpaceWarpInfoFlagsFB flags
ValidateXrFlagsResult ValidateXrCompositionLayerSpaceWarpInfoFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_COMPOSITION_LAYER_SPACE_WARP_INFO_FRAME_SKIP_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SPACE_WARP_INFO_FRAME_SKIP_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SPACE_WARP_INFO_FRAME_SKIP_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrSemanticLabelsSupportFlagsFB flags
ValidateXrFlagsResult ValidateXrSemanticLabelsSupportFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_SEMANTIC_LABELS_SUPPORT_MULTIPLE_SEMANTIC_LABELS_BIT_FB) != 0) {
        // Clear the value XR_SEMANTIC_LABELS_SUPPORT_MULTIPLE_SEMANTIC_LABELS_BIT_FB since it is valid
        int_value &= ~XR_SEMANTIC_LABELS_SUPPORT_MULTIPLE_SEMANTIC_LABELS_BIT_FB;
    }
    if ((int_value & XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_DESK_TO_TABLE_MIGRATION_BIT_FB) != 0) {
        // Clear the value XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_DESK_TO_TABLE_MIGRATION_BIT_FB since it is valid
        int_value &= ~XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_DESK_TO_TABLE_MIGRATION_BIT_FB;
    }
    if ((int_value & XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_INVISIBLE_WALL_FACE_BIT_FB) != 0) {
        // Clear the value XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_INVISIBLE_WALL_FACE_BIT_FB since it is valid
        int_value &= ~XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_INVISIBLE_WALL_FACE_BIT_FB;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrDigitalLensControlFlagsALMALENCE flags
ValidateXrFlagsResult ValidateXrDigitalLensControlFlagsALMALENCE(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_DIGITAL_LENS_CONTROL_PROCESSING_DISABLE_BIT_ALMALENCE) != 0) {
        // Clear the value XR_DIGITAL_LENS_CONTROL_PROCESSING_DISABLE_BIT_ALMALENCE since it is valid
        int_value &= ~XR_DIGITAL_LENS_CONTROL_PROCESSING_DISABLE_BIT_ALMALENCE;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrFoveationEyeTrackedProfileCreateFlagsMETA flags
ValidateXrFlagsResult ValidateXrFoveationEyeTrackedProfileCreateFlagsMETA(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrFoveationEyeTrackedStateFlagsMETA flags
ValidateXrFlagsResult ValidateXrFoveationEyeTrackedStateFlagsMETA(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_FOVEATION_EYE_TRACKED_STATE_VALID_BIT_META) != 0) {
        // Clear the value XR_FOVEATION_EYE_TRACKED_STATE_VALID_BIT_META since it is valid
        int_value &= ~XR_FOVEATION_EYE_TRACKED_STATE_VALID_BIT_META;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrCompositionLayerSettingsFlagsFB flags
ValidateXrFlagsResult ValidateXrCompositionLayerSettingsFlagsFB(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SUPER_SAMPLING_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SUPER_SAMPLING_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SUPER_SAMPLING_BIT_FB;
    }
    if ((int_value & XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SUPER_SAMPLING_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SUPER_SAMPLING_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SUPER_SAMPLING_BIT_FB;
    }
    if ((int_value & XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SHARPENING_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SHARPENING_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SETTINGS_NORMAL_SHARPENING_BIT_FB;
    }
    if ((int_value & XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SHARPENING_BIT_FB) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SHARPENING_BIT_FB since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SETTINGS_QUALITY_SHARPENING_BIT_FB;
    }
    if ((int_value & XR_COMPOSITION_LAYER_SETTINGS_AUTO_LAYER_FILTER_BIT_META) != 0) {
        // Clear the value XR_COMPOSITION_LAYER_SETTINGS_AUTO_LAYER_FILTER_BIT_META since it is valid
        int_value &= ~XR_COMPOSITION_LAYER_SETTINGS_AUTO_LAYER_FILTER_BIT_META;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPassthroughPreferenceFlagsMETA flags
ValidateXrFlagsResult ValidateXrPassthroughPreferenceFlagsMETA(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PASSTHROUGH_PREFERENCE_DEFAULT_TO_ACTIVE_BIT_META) != 0) {
        // Clear the value XR_PASSTHROUGH_PREFERENCE_DEFAULT_TO_ACTIVE_BIT_META since it is valid
        int_value &= ~XR_PASSTHROUGH_PREFERENCE_DEFAULT_TO_ACTIVE_BIT_META;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrVirtualKeyboardInputStateFlagsMETA flags
ValidateXrFlagsResult ValidateXrVirtualKeyboardInputStateFlagsMETA(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_VIRTUAL_KEYBOARD_INPUT_STATE_PRESSED_BIT_META) != 0) {
        // Clear the value XR_VIRTUAL_KEYBOARD_INPUT_STATE_PRESSED_BIT_META since it is valid
        int_value &= ~XR_VIRTUAL_KEYBOARD_INPUT_STATE_PRESSED_BIT_META;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrExternalCameraStatusFlagsOCULUS flags
ValidateXrFlagsResult ValidateXrExternalCameraStatusFlagsOCULUS(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_EXTERNAL_CAMERA_STATUS_CONNECTED_BIT_OCULUS) != 0) {
        // Clear the value XR_EXTERNAL_CAMERA_STATUS_CONNECTED_BIT_OCULUS since it is valid
        int_value &= ~XR_EXTERNAL_CAMERA_STATUS_CONNECTED_BIT_OCULUS;
    }
    if ((int_value & XR_EXTERNAL_CAMERA_STATUS_CALIBRATING_BIT_OCULUS) != 0) {
        // Clear the value XR_EXTERNAL_CAMERA_STATUS_CALIBRATING_BIT_OCULUS since it is valid
        int_value &= ~XR_EXTERNAL_CAMERA_STATUS_CALIBRATING_BIT_OCULUS;
    }
    if ((int_value & XR_EXTERNAL_CAMERA_STATUS_CALIBRATION_FAILED_BIT_OCULUS) != 0) {
        // Clear the value XR_EXTERNAL_CAMERA_STATUS_CALIBRATION_FAILED_BIT_OCULUS since it is valid
        int_value &= ~XR_EXTERNAL_CAMERA_STATUS_CALIBRATION_FAILED_BIT_OCULUS;
    }
    if ((int_value & XR_EXTERNAL_CAMERA_STATUS_CALIBRATED_BIT_OCULUS) != 0) {
        // Clear the value XR_EXTERNAL_CAMERA_STATUS_CALIBRATED_BIT_OCULUS since it is valid
        int_value &= ~XR_EXTERNAL_CAMERA_STATUS_CALIBRATED_BIT_OCULUS;
    }
    if ((int_value & XR_EXTERNAL_CAMERA_STATUS_CAPTURING_BIT_OCULUS) != 0) {
        // Clear the value XR_EXTERNAL_CAMERA_STATUS_CAPTURING_BIT_OCULUS since it is valid
        int_value &= ~XR_EXTERNAL_CAMERA_STATUS_CAPTURING_BIT_OCULUS;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPerformanceMetricsCounterFlagsMETA flags
ValidateXrFlagsResult ValidateXrPerformanceMetricsCounterFlagsMETA(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PERFORMANCE_METRICS_COUNTER_ANY_VALUE_VALID_BIT_META) != 0) {
        // Clear the value XR_PERFORMANCE_METRICS_COUNTER_ANY_VALUE_VALID_BIT_META since it is valid
        int_value &= ~XR_PERFORMANCE_METRICS_COUNTER_ANY_VALUE_VALID_BIT_META;
    }
    if ((int_value & XR_PERFORMANCE_METRICS_COUNTER_UINT_VALUE_VALID_BIT_META) != 0) {
        // Clear the value XR_PERFORMANCE_METRICS_COUNTER_UINT_VALUE_VALID_BIT_META since it is valid
        int_value &= ~XR_PERFORMANCE_METRICS_COUNTER_UINT_VALUE_VALID_BIT_META;
    }
    if ((int_value & XR_PERFORMANCE_METRICS_COUNTER_FLOAT_VALUE_VALID_BIT_META) != 0) {
        // Clear the value XR_PERFORMANCE_METRICS_COUNTER_FLOAT_VALUE_VALID_BIT_META since it is valid
        int_value &= ~XR_PERFORMANCE_METRICS_COUNTER_FLOAT_VALUE_VALID_BIT_META;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrFoveationDynamicFlagsHTC flags
ValidateXrFlagsResult ValidateXrFoveationDynamicFlagsHTC(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_BIT_HTC) != 0) {
        // Clear the value XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_BIT_HTC since it is valid
        int_value &= ~XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_BIT_HTC;
    }
    if ((int_value & XR_FOVEATION_DYNAMIC_CLEAR_FOV_ENABLED_BIT_HTC) != 0) {
        // Clear the value XR_FOVEATION_DYNAMIC_CLEAR_FOV_ENABLED_BIT_HTC since it is valid
        int_value &= ~XR_FOVEATION_DYNAMIC_CLEAR_FOV_ENABLED_BIT_HTC;
    }
    if ((int_value & XR_FOVEATION_DYNAMIC_FOCAL_CENTER_OFFSET_ENABLED_BIT_HTC) != 0) {
        // Clear the value XR_FOVEATION_DYNAMIC_FOCAL_CENTER_OFFSET_ENABLED_BIT_HTC since it is valid
        int_value &= ~XR_FOVEATION_DYNAMIC_FOCAL_CENTER_OFFSET_ENABLED_BIT_HTC;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPlaneDetectionCapabilityFlagsEXT flags
ValidateXrFlagsResult ValidateXrPlaneDetectionCapabilityFlagsEXT(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_PLANE_DETECTION_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_PLANE_DETECTION_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_PLANE_DETECTION_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_PLANE_HOLES_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_PLANE_HOLES_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_PLANE_HOLES_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_CEILING_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_CEILING_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_CEILING_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_FLOOR_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_FLOOR_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_FLOOR_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_WALL_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_WALL_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_WALL_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_PLATFORM_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_PLATFORM_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_SEMANTIC_PLATFORM_BIT_EXT;
    }
    if ((int_value & XR_PLANE_DETECTION_CAPABILITY_ORIENTATION_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTION_CAPABILITY_ORIENTATION_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTION_CAPABILITY_ORIENTATION_BIT_EXT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrPlaneDetectorFlagsEXT flags
ValidateXrFlagsResult ValidateXrPlaneDetectorFlagsEXT(const XrFlags64 value) {
    if (0 == value) {
        return VALIDATE_XR_FLAGS_ZERO;
    }
    XrFlags64 int_value = value;
    if ((int_value & XR_PLANE_DETECTOR_ENABLE_CONTOUR_BIT_EXT) != 0) {
        // Clear the value XR_PLANE_DETECTOR_ENABLE_CONTOUR_BIT_EXT since it is valid
        int_value &= ~XR_PLANE_DETECTOR_ENABLE_CONTOUR_BIT_EXT;
    }
    if (int_value != 0) {
        // Something is left, it must be invalid
        return VALIDATE_XR_FLAGS_INVALID;
    }
    return VALIDATE_XR_FLAGS_SUCCESS;
}

// Function to validate XrResult enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrResult value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_SUCCESS:
            return true;
        case XR_TIMEOUT_EXPIRED:
            return true;
        case XR_SESSION_LOSS_PENDING:
            return true;
        case XR_EVENT_UNAVAILABLE:
            return true;
        case XR_SPACE_BOUNDS_UNAVAILABLE:
            return true;
        case XR_SESSION_NOT_FOCUSED:
            return true;
        case XR_FRAME_DISCARDED:
            return true;
        case XR_ERROR_VALIDATION_FAILURE:
            return true;
        case XR_ERROR_RUNTIME_FAILURE:
            return true;
        case XR_ERROR_OUT_OF_MEMORY:
            return true;
        case XR_ERROR_API_VERSION_UNSUPPORTED:
            return true;
        case XR_ERROR_INITIALIZATION_FAILED:
            return true;
        case XR_ERROR_FUNCTION_UNSUPPORTED:
            return true;
        case XR_ERROR_FEATURE_UNSUPPORTED:
            return true;
        case XR_ERROR_EXTENSION_NOT_PRESENT:
            return true;
        case XR_ERROR_LIMIT_REACHED:
            return true;
        case XR_ERROR_SIZE_INSUFFICIENT:
            return true;
        case XR_ERROR_HANDLE_INVALID:
            return true;
        case XR_ERROR_INSTANCE_LOST:
            return true;
        case XR_ERROR_SESSION_RUNNING:
            return true;
        case XR_ERROR_SESSION_NOT_RUNNING:
            return true;
        case XR_ERROR_SESSION_LOST:
            return true;
        case XR_ERROR_SYSTEM_INVALID:
            return true;
        case XR_ERROR_PATH_INVALID:
            return true;
        case XR_ERROR_PATH_COUNT_EXCEEDED:
            return true;
        case XR_ERROR_PATH_FORMAT_INVALID:
            return true;
        case XR_ERROR_PATH_UNSUPPORTED:
            return true;
        case XR_ERROR_LAYER_INVALID:
            return true;
        case XR_ERROR_LAYER_LIMIT_EXCEEDED:
            return true;
        case XR_ERROR_SWAPCHAIN_RECT_INVALID:
            return true;
        case XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED:
            return true;
        case XR_ERROR_ACTION_TYPE_MISMATCH:
            return true;
        case XR_ERROR_SESSION_NOT_READY:
            return true;
        case XR_ERROR_SESSION_NOT_STOPPING:
            return true;
        case XR_ERROR_TIME_INVALID:
            return true;
        case XR_ERROR_REFERENCE_SPACE_UNSUPPORTED:
            return true;
        case XR_ERROR_FILE_ACCESS_ERROR:
            return true;
        case XR_ERROR_FILE_CONTENTS_INVALID:
            return true;
        case XR_ERROR_FORM_FACTOR_UNSUPPORTED:
            return true;
        case XR_ERROR_FORM_FACTOR_UNAVAILABLE:
            return true;
        case XR_ERROR_API_LAYER_NOT_PRESENT:
            return true;
        case XR_ERROR_CALL_ORDER_INVALID:
            return true;
        case XR_ERROR_GRAPHICS_DEVICE_INVALID:
            return true;
        case XR_ERROR_POSE_INVALID:
            return true;
        case XR_ERROR_INDEX_OUT_OF_RANGE:
            return true;
        case XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED:
            return true;
        case XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED:
            return true;
        case XR_ERROR_NAME_DUPLICATED:
            return true;
        case XR_ERROR_NAME_INVALID:
            return true;
        case XR_ERROR_ACTIONSET_NOT_ATTACHED:
            return true;
        case XR_ERROR_ACTIONSETS_ALREADY_ATTACHED:
            return true;
        case XR_ERROR_LOCALIZED_NAME_DUPLICATED:
            return true;
        case XR_ERROR_LOCALIZED_NAME_INVALID:
            return true;
        case XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING:
            return true;
        case XR_ERROR_RUNTIME_UNAVAILABLE:
            return true;
        case XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR:
            // Enum value XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR requires extension XR_KHR_android_thread_settings, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_android_thread_settings")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_ANDROID_THREAD_SETTINGS_ID_INVALID_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_android_thread_settings\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR:
            // Enum value XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR requires extension XR_KHR_android_thread_settings, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_android_thread_settings")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_ANDROID_THREAD_SETTINGS_FAILURE_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_android_thread_settings\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT:
            // Enum value XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT requires extension XR_MSFT_spatial_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT:
            // Enum value XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT:
            // Enum value XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT:
            // Enum value XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT requires extension XR_MSFT_composition_layer_reprojection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_composition_layer_reprojection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_composition_layer_reprojection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT:
            // Enum value XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT:
            // Enum value XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT:
            // Enum value XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT:
            // Enum value XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT:
            // Enum value XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT:
            // Enum value XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB:
            // Enum value XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB requires extension XR_FB_display_refresh_rate, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_display_refresh_rate")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_display_refresh_rate\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB:
            // Enum value XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB requires extension XR_FB_color_space, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_color_space")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_color_space\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB:
            // Enum value XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB:
            // Enum value XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB:
            // Enum value XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB:
            // Enum value XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB:
            // Enum value XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB:
            // Enum value XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB:
            // Enum value XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB:
            // Enum value XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB:
            // Enum value XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_UNKNOWN_PASSTHROUGH_FB:
            // Enum value XR_ERROR_UNKNOWN_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_UNKNOWN_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_RENDER_MODEL_KEY_INVALID_FB:
            // Enum value XR_ERROR_RENDER_MODEL_KEY_INVALID_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_RENDER_MODEL_KEY_INVALID_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_RENDER_MODEL_UNAVAILABLE_FB:
            // Enum value XR_RENDER_MODEL_UNAVAILABLE_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_RENDER_MODEL_UNAVAILABLE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_NOT_TRACKED_VARJO:
            // Enum value XR_ERROR_MARKER_NOT_TRACKED_VARJO requires extension XR_VARJO_marker_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_NOT_TRACKED_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_ID_INVALID_VARJO:
            // Enum value XR_ERROR_MARKER_ID_INVALID_VARJO requires extension XR_VARJO_marker_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_ID_INVALID_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_DETECTOR_PERMISSION_DENIED_ML:
            // Enum value XR_ERROR_MARKER_DETECTOR_PERMISSION_DENIED_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_DETECTOR_PERMISSION_DENIED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_DETECTOR_LOCATE_FAILED_ML:
            // Enum value XR_ERROR_MARKER_DETECTOR_LOCATE_FAILED_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_DETECTOR_LOCATE_FAILED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_DETECTOR_INVALID_DATA_QUERY_ML:
            // Enum value XR_ERROR_MARKER_DETECTOR_INVALID_DATA_QUERY_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_DETECTOR_INVALID_DATA_QUERY_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_DETECTOR_INVALID_CREATE_INFO_ML:
            // Enum value XR_ERROR_MARKER_DETECTOR_INVALID_CREATE_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_DETECTOR_INVALID_CREATE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_MARKER_INVALID_ML:
            // Enum value XR_ERROR_MARKER_INVALID_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_MARKER_INVALID_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_INCOMPATIBLE_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_INCOMPATIBLE_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_INCOMPATIBLE_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_UNAVAILABLE_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_UNAVAILABLE_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_UNAVAILABLE_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_FAIL_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_FAIL_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_FAIL_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_IMPORT_EXPORT_PERMISSION_DENIED_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_IMPORT_EXPORT_PERMISSION_DENIED_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_IMPORT_EXPORT_PERMISSION_DENIED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_PERMISSION_DENIED_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_PERMISSION_DENIED_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_PERMISSION_DENIED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_ALREADY_EXISTS_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_ALREADY_EXISTS_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_ALREADY_EXISTS_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_LOCALIZATION_MAP_CANNOT_EXPORT_CLOUD_MAP_ML:
            // Enum value XR_ERROR_LOCALIZATION_MAP_CANNOT_EXPORT_CLOUD_MAP_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_LOCALIZATION_MAP_CANNOT_EXPORT_CLOUD_MAP_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT:
            // Enum value XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT requires extension XR_MSFT_spatial_anchor_persistence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor_persistence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor_persistence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT:
            // Enum value XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT requires extension XR_MSFT_spatial_anchor_persistence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor_persistence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor_persistence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_SCENE_MARKER_DATA_NOT_STRING_MSFT:
            // Enum value XR_SCENE_MARKER_DATA_NOT_STRING_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_SCENE_MARKER_DATA_NOT_STRING_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB:
            // Enum value XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_LOCALIZATION_FAILED_FB:
            // Enum value XR_ERROR_SPACE_LOCALIZATION_FAILED_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_LOCALIZATION_FAILED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_NETWORK_TIMEOUT_FB:
            // Enum value XR_ERROR_SPACE_NETWORK_TIMEOUT_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_NETWORK_TIMEOUT_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB:
            // Enum value XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB:
            // Enum value XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META:
            // Enum value XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_HINT_ALREADY_SET_QCOM:
            // Enum value XR_ERROR_HINT_ALREADY_SET_QCOM requires extension XR_QCOM_tracking_optimization_settings, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_QCOM_tracking_optimization_settings")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_HINT_ALREADY_SET_QCOM\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_QCOM_tracking_optimization_settings\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_NOT_AN_ANCHOR_HTC:
            // Enum value XR_ERROR_NOT_AN_ANCHOR_HTC requires extension XR_HTC_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_NOT_AN_ANCHOR_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_SPACE_NOT_LOCATABLE_EXT:
            // Enum value XR_ERROR_SPACE_NOT_LOCATABLE_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_SPACE_NOT_LOCATABLE_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT:
            // Enum value XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrResult value \"XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrStructureType enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrStructureType value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_TYPE_UNKNOWN:
            return false; // Invalid XrStructureType 
        case XR_TYPE_API_LAYER_PROPERTIES:
            return true;
        case XR_TYPE_EXTENSION_PROPERTIES:
            return true;
        case XR_TYPE_INSTANCE_CREATE_INFO:
            return true;
        case XR_TYPE_SYSTEM_GET_INFO:
            return true;
        case XR_TYPE_SYSTEM_PROPERTIES:
            return true;
        case XR_TYPE_VIEW_LOCATE_INFO:
            return true;
        case XR_TYPE_VIEW:
            return true;
        case XR_TYPE_SESSION_CREATE_INFO:
            return true;
        case XR_TYPE_SWAPCHAIN_CREATE_INFO:
            return true;
        case XR_TYPE_SESSION_BEGIN_INFO:
            return true;
        case XR_TYPE_VIEW_STATE:
            return true;
        case XR_TYPE_FRAME_END_INFO:
            return true;
        case XR_TYPE_HAPTIC_VIBRATION:
            return true;
        case XR_TYPE_EVENT_DATA_BUFFER:
            return true;
        case XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING:
            return true;
        case XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED:
            return true;
        case XR_TYPE_ACTION_STATE_BOOLEAN:
            return true;
        case XR_TYPE_ACTION_STATE_FLOAT:
            return true;
        case XR_TYPE_ACTION_STATE_VECTOR2F:
            return true;
        case XR_TYPE_ACTION_STATE_POSE:
            return true;
        case XR_TYPE_ACTION_SET_CREATE_INFO:
            return true;
        case XR_TYPE_ACTION_CREATE_INFO:
            return true;
        case XR_TYPE_INSTANCE_PROPERTIES:
            return true;
        case XR_TYPE_FRAME_WAIT_INFO:
            return true;
        case XR_TYPE_COMPOSITION_LAYER_PROJECTION:
            return true;
        case XR_TYPE_COMPOSITION_LAYER_QUAD:
            return true;
        case XR_TYPE_REFERENCE_SPACE_CREATE_INFO:
            return true;
        case XR_TYPE_ACTION_SPACE_CREATE_INFO:
            return true;
        case XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING:
            return true;
        case XR_TYPE_VIEW_CONFIGURATION_VIEW:
            return true;
        case XR_TYPE_SPACE_LOCATION:
            return true;
        case XR_TYPE_SPACE_VELOCITY:
            return true;
        case XR_TYPE_FRAME_STATE:
            return true;
        case XR_TYPE_VIEW_CONFIGURATION_PROPERTIES:
            return true;
        case XR_TYPE_FRAME_BEGIN_INFO:
            return true;
        case XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW:
            return true;
        case XR_TYPE_EVENT_DATA_EVENTS_LOST:
            return true;
        case XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING:
            return true;
        case XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED:
            return true;
        case XR_TYPE_INTERACTION_PROFILE_STATE:
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO:
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO:
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO:
            return true;
        case XR_TYPE_ACTION_STATE_GET_INFO:
            return true;
        case XR_TYPE_HAPTIC_ACTION_INFO:
            return true;
        case XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO:
            return true;
        case XR_TYPE_ACTIONS_SYNC_INFO:
            return true;
        case XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO:
            return true;
        case XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO:
            return true;
        case XR_TYPE_COMPOSITION_LAYER_CUBE_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_CUBE_KHR requires extension XR_KHR_composition_layer_cube, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_cube")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_CUBE_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_cube\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR:
            // Enum value XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR requires extension XR_KHR_android_create_instance, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_android_create_instance")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_android_create_instance\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR requires extension XR_KHR_composition_layer_depth, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_depth")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_depth\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR:
            // Enum value XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR requires extension XR_KHR_vulkan_swapchain_format_list, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_swapchain_format_list")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_swapchain_format_list\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT:
            // Enum value XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT requires extension XR_EXT_performance_settings, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR requires extension XR_KHR_composition_layer_cylinder, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_cylinder")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_cylinder\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR requires extension XR_KHR_composition_layer_equirect, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_equirect")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_equirect\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            // Enum value XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT requires extension XR_EXT_debug_utils, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_debug_utils")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_debug_utils\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
            // Enum value XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT requires extension XR_EXT_debug_utils, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_debug_utils")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_debug_utils\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            // Enum value XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT requires extension XR_EXT_debug_utils, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_debug_utils")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_debug_utils\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DEBUG_UTILS_LABEL_EXT:
            // Enum value XR_TYPE_DEBUG_UTILS_LABEL_EXT requires extension XR_EXT_debug_utils, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_debug_utils")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DEBUG_UTILS_LABEL_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_debug_utils\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR:
            // Enum value XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR requires extension XR_KHR_opengl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR requires extension XR_KHR_opengl_es_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_es_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_es_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR requires extension XR_KHR_opengl_es_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_es_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_es_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR:
            // Enum value XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR requires extension XR_KHR_opengl_es_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_es_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_opengl_es_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR requires extension XR_KHR_vulkan_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR requires extension XR_KHR_vulkan_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR:
            // Enum value XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR requires extension XR_KHR_vulkan_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_D3D11_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_D3D11_KHR requires extension XR_KHR_D3D11_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D11_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_D3D11_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D11_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR requires extension XR_KHR_D3D11_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D11_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D11_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR:
            // Enum value XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR requires extension XR_KHR_D3D11_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D11_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D11_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_D3D12_KHR:
            // Enum value XR_TYPE_GRAPHICS_BINDING_D3D12_KHR requires extension XR_KHR_D3D12_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D12_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_D3D12_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D12_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR requires extension XR_KHR_D3D12_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D12_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D12_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR:
            // Enum value XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR requires extension XR_KHR_D3D12_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D12_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_D3D12_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT:
            // Enum value XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT requires extension XR_EXT_eye_gaze_interaction, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_eye_gaze_interaction")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_eye_gaze_interaction\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT:
            // Enum value XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT requires extension XR_EXT_eye_gaze_interaction, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_eye_gaze_interaction")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_eye_gaze_interaction\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VISIBILITY_MASK_KHR:
            // Enum value XR_TYPE_VISIBILITY_MASK_KHR requires extension XR_KHR_visibility_mask, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_visibility_mask")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VISIBILITY_MASK_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_visibility_mask\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR:
            // Enum value XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR requires extension XR_KHR_visibility_mask, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_visibility_mask")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_visibility_mask\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX:
            // Enum value XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX requires extension XR_EXTX_overlay, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXTX_overlay")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXTX_overlay\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX:
            // Enum value XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX requires extension XR_EXTX_overlay, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXTX_overlay")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXTX_overlay\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR requires extension XR_KHR_composition_layer_color_scale_bias, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_color_scale_bias")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_color_scale_bias\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT requires extension XR_MSFT_spatial_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT requires extension XR_MSFT_spatial_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB requires extension XR_FB_composition_layer_image_layout, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_image_layout")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_composition_layer_image_layout\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB requires extension XR_FB_composition_layer_alpha_blend, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_alpha_blend")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_composition_layer_alpha_blend\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT:
            // Enum value XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT requires extension XR_EXT_view_configuration_depth_range, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_view_configuration_depth_range")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_view_configuration_depth_range\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GRAPHICS_BINDING_EGL_MNDX:
            // Enum value XR_TYPE_GRAPHICS_BINDING_EGL_MNDX requires extension XR_MNDX_egl_enable, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MNDX_egl_enable")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GRAPHICS_BINDING_EGL_MNDX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MNDX_egl_enable\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT:
            // Enum value XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT:
            // Enum value XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT:
            // Enum value XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT:
            // Enum value XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_JOINT_LOCATIONS_EXT:
            // Enum value XR_TYPE_HAND_JOINT_LOCATIONS_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_JOINT_LOCATIONS_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_JOINT_VELOCITIES_EXT:
            // Enum value XR_TYPE_HAND_JOINT_VELOCITIES_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_JOINT_VELOCITIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT:
            // Enum value XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT:
            // Enum value XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_MESH_MSFT:
            // Enum value XR_TYPE_HAND_MESH_MSFT requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_MESH_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_POSE_TYPE_INFO_MSFT:
            // Enum value XR_TYPE_HAND_POSE_TYPE_INFO_MSFT requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_POSE_TYPE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT requires extension XR_MSFT_secondary_view_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_secondary_view_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_secondary_view_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT:
            // Enum value XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT:
            // Enum value XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT:
            // Enum value XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT:
            // Enum value XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_CONTROLLER_MODEL_STATE_MSFT:
            // Enum value XR_TYPE_CONTROLLER_MODEL_STATE_MSFT requires extension XR_MSFT_controller_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_controller_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_CONTROLLER_MODEL_STATE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_controller_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC:
            // Enum value XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC requires extension XR_EPIC_view_configuration_fov, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EPIC_view_configuration_fov")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EPIC_view_configuration_fov\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT:
            // Enum value XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT requires extension XR_MSFT_holographic_window_attachment, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_holographic_window_attachment")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_holographic_window_attachment\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT:
            // Enum value XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT requires extension XR_MSFT_composition_layer_reprojection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_composition_layer_reprojection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_composition_layer_reprojection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT:
            // Enum value XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT requires extension XR_MSFT_composition_layer_reprojection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_composition_layer_reprojection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_composition_layer_reprojection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB:
            // Enum value XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB requires extension XR_FB_android_surface_swapchain_create, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_android_surface_swapchain_create")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_android_surface_swapchain_create\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB requires extension XR_FB_composition_layer_secure_content, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_secure_content")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_composition_layer_secure_content\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BODY_TRACKER_CREATE_INFO_FB:
            // Enum value XR_TYPE_BODY_TRACKER_CREATE_INFO_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BODY_TRACKER_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB:
            // Enum value XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BODY_JOINT_LOCATIONS_FB:
            // Enum value XR_TYPE_BODY_JOINT_LOCATIONS_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BODY_JOINT_LOCATIONS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BODY_SKELETON_FB:
            // Enum value XR_TYPE_BODY_SKELETON_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BODY_SKELETON_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT:
            // Enum value XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT requires extension XR_EXT_dpad_binding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_dpad_binding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_dpad_binding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE:
            // Enum value XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE requires extension XR_VALVE_analog_threshold, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VALVE_analog_threshold")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VALVE_analog_threshold\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT:
            // Enum value XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT requires extension XR_EXT_hand_joints_motion_range, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_joints_motion_range")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_joints_motion_range\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR:
            // Enum value XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR requires extension XR_KHR_loader_init_android, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_loader_init_android")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_loader_init_android\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR:
            // Enum value XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR requires extension XR_KHR_vulkan_enable2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR:
            // Enum value XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR requires extension XR_KHR_vulkan_enable2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR:
            // Enum value XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR requires extension XR_KHR_vulkan_enable2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_vulkan_enable2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR:
            // Enum value XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR requires extension XR_KHR_composition_layer_equirect2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_equirect2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_composition_layer_equirect2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_CREATE_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT:
            // Enum value XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT:
            // Enum value XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_COMPONENTS_MSFT:
            // Enum value XR_TYPE_SCENE_COMPONENTS_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_COMPONENTS_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT:
            // Enum value XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_OBJECTS_MSFT:
            // Enum value XR_TYPE_SCENE_OBJECTS_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_OBJECTS_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_PLANES_MSFT:
            // Enum value XR_TYPE_SCENE_PLANES_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_PLANES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESHES_MSFT:
            // Enum value XR_TYPE_SCENE_MESHES_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESHES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESH_BUFFERS_MSFT:
            // Enum value XR_TYPE_SCENE_MESH_BUFFERS_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESH_BUFFERS_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT:
            // Enum value XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT:
            // Enum value XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT:
            // Enum value XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT:
            // Enum value XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT requires extension XR_MSFT_scene_understanding_serialization, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding_serialization")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding_serialization\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT:
            // Enum value XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT requires extension XR_MSFT_scene_understanding_serialization, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding_serialization")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding_serialization\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB:
            // Enum value XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB requires extension XR_FB_display_refresh_rate, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_display_refresh_rate")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_display_refresh_rate\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIVE_TRACKER_PATHS_HTCX:
            // Enum value XR_TYPE_VIVE_TRACKER_PATHS_HTCX requires extension XR_HTCX_vive_tracker_interaction, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTCX_vive_tracker_interaction")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIVE_TRACKER_PATHS_HTCX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTCX_vive_tracker_interaction\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX:
            // Enum value XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX requires extension XR_HTCX_vive_tracker_interaction, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTCX_vive_tracker_interaction")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTCX_vive_tracker_interaction\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC:
            // Enum value XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC requires extension XR_HTC_facial_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC:
            // Enum value XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC requires extension XR_HTC_facial_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACIAL_EXPRESSIONS_HTC:
            // Enum value XR_TYPE_FACIAL_EXPRESSIONS_HTC requires extension XR_HTC_facial_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACIAL_EXPRESSIONS_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB requires extension XR_FB_color_space, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_color_space")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_color_space\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_MESH_FB:
            // Enum value XR_TYPE_HAND_TRACKING_MESH_FB requires extension XR_FB_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_MESH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_SCALE_FB:
            // Enum value XR_TYPE_HAND_TRACKING_SCALE_FB requires extension XR_FB_hand_tracking_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_hand_tracking_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_SCALE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_hand_tracking_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_AIM_STATE_FB:
            // Enum value XR_TYPE_HAND_TRACKING_AIM_STATE_FB requires extension XR_FB_hand_tracking_aim, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_hand_tracking_aim")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_AIM_STATE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_hand_tracking_aim\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB:
            // Enum value XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB requires extension XR_FB_hand_tracking_capsules, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_hand_tracking_capsules")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_hand_tracking_capsules\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB:
            // Enum value XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_COMPONENT_STATUS_FB:
            // Enum value XR_TYPE_SPACE_COMPONENT_STATUS_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_COMPONENT_STATUS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB requires extension XR_FB_spatial_entity, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB:
            // Enum value XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB requires extension XR_FB_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB:
            // Enum value XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB requires extension XR_FB_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB:
            // Enum value XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB requires extension XR_FB_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB:
            // Enum value XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB requires extension XR_FB_foveation_configuration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation_configuration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation_configuration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB:
            // Enum value XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB requires extension XR_FB_keyboard_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_keyboard_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_keyboard_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_KEYBOARD_TRACKING_QUERY_FB:
            // Enum value XR_TYPE_KEYBOARD_TRACKING_QUERY_FB requires extension XR_FB_keyboard_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_keyboard_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_KEYBOARD_TRACKING_QUERY_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_keyboard_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB requires extension XR_FB_keyboard_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_keyboard_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_keyboard_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB:
            // Enum value XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB requires extension XR_FB_triangle_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_triangle_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_triangle_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_CREATE_INFO_FB:
            // Enum value XR_TYPE_PASSTHROUGH_CREATE_INFO_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB:
            // Enum value XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB:
            // Enum value XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB:
            // Enum value XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB:
            // Enum value XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_STYLE_FB:
            // Enum value XR_TYPE_PASSTHROUGH_STYLE_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_STYLE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB:
            // Enum value XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB:
            // Enum value XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RENDER_MODEL_PATH_INFO_FB:
            // Enum value XR_TYPE_RENDER_MODEL_PATH_INFO_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RENDER_MODEL_PATH_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RENDER_MODEL_PROPERTIES_FB:
            // Enum value XR_TYPE_RENDER_MODEL_PROPERTIES_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RENDER_MODEL_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RENDER_MODEL_BUFFER_FB:
            // Enum value XR_TYPE_RENDER_MODEL_BUFFER_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RENDER_MODEL_BUFFER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RENDER_MODEL_LOAD_INFO_FB:
            // Enum value XR_TYPE_RENDER_MODEL_LOAD_INFO_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RENDER_MODEL_LOAD_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB:
            // Enum value XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB requires extension XR_FB_render_model, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_render_model")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_render_model\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BINDING_MODIFICATIONS_KHR:
            // Enum value XR_TYPE_BINDING_MODIFICATIONS_KHR requires extension XR_KHR_binding_modification, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_binding_modification")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BINDING_MODIFICATIONS_KHR\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_KHR_binding_modification\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO:
            // Enum value XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO requires extension XR_VARJO_foveated_rendering, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_foveated_rendering")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_foveated_rendering\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO:
            // Enum value XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO requires extension XR_VARJO_foveated_rendering, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_foveated_rendering")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_foveated_rendering\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO:
            // Enum value XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO requires extension XR_VARJO_foveated_rendering, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_foveated_rendering")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_foveated_rendering\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO:
            // Enum value XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO requires extension XR_VARJO_composition_layer_depth_test, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_composition_layer_depth_test")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_composition_layer_depth_test\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO:
            // Enum value XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO requires extension XR_VARJO_marker_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO:
            // Enum value XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO requires extension XR_VARJO_marker_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO:
            // Enum value XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO requires extension XR_VARJO_marker_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FRAME_END_INFO_ML:
            // Enum value XR_TYPE_FRAME_END_INFO_ML requires extension XR_ML_frame_end_info, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_frame_end_info")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FRAME_END_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_frame_end_info\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML:
            // Enum value XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML requires extension XR_ML_global_dimmer, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_global_dimmer")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_global_dimmer\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML:
            // Enum value XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML requires extension XR_ML_compat, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_compat")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_compat\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML:
            // Enum value XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_DETECTOR_STATE_ML:
            // Enum value XR_TYPE_MARKER_DETECTOR_STATE_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_DETECTOR_STATE_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MARKER_SPACE_CREATE_INFO_ML:
            // Enum value XR_TYPE_MARKER_SPACE_CREATE_INFO_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MARKER_SPACE_CREATE_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_LOCALIZATION_MAP_ML:
            // Enum value XR_TYPE_LOCALIZATION_MAP_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_LOCALIZATION_MAP_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML:
            // Enum value XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML:
            // Enum value XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML:
            // Enum value XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML:
            // Enum value XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML:
            // Enum value XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML requires extension XR_ML_user_calibration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML:
            // Enum value XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML requires extension XR_ML_user_calibration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML:
            // Enum value XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML requires extension XR_ML_user_calibration, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT requires extension XR_MSFT_spatial_anchor_persistence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor_persistence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor_persistence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT requires extension XR_MSFT_spatial_anchor_persistence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor_persistence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor_persistence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MARKERS_MSFT:
            // Enum value XR_TYPE_SCENE_MARKERS_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MARKERS_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT:
            // Enum value XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_MARKER_QR_CODES_MSFT:
            // Enum value XR_TYPE_SCENE_MARKER_QR_CODES_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_MARKER_QR_CODES_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_QUERY_INFO_FB:
            // Enum value XR_TYPE_SPACE_QUERY_INFO_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_QUERY_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_QUERY_RESULTS_FB:
            // Enum value XR_TYPE_SPACE_QUERY_RESULTS_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_QUERY_RESULTS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB:
            // Enum value XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_UUID_FILTER_INFO_FB:
            // Enum value XR_TYPE_SPACE_UUID_FILTER_INFO_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_UUID_FILTER_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB:
            // Enum value XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB requires extension XR_FB_spatial_entity_query, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_SAVE_INFO_FB:
            // Enum value XR_TYPE_SPACE_SAVE_INFO_FB requires extension XR_FB_spatial_entity_storage, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_SAVE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_ERASE_INFO_FB:
            // Enum value XR_TYPE_SPACE_ERASE_INFO_FB requires extension XR_FB_spatial_entity_storage, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_ERASE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB requires extension XR_FB_spatial_entity_storage, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB requires extension XR_FB_spatial_entity_storage, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB:
            // Enum value XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB requires extension XR_FB_foveation_vulkan, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation_vulkan")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation_vulkan\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB:
            // Enum value XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB requires extension XR_FB_swapchain_update_state_android_surface, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_android_surface")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_swapchain_update_state_android_surface\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB:
            // Enum value XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB requires extension XR_FB_swapchain_update_state_opengl_es, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_opengl_es")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_swapchain_update_state_opengl_es\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB:
            // Enum value XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB requires extension XR_FB_swapchain_update_state_vulkan, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_vulkan")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_swapchain_update_state_vulkan\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_SHARE_INFO_FB:
            // Enum value XR_TYPE_SPACE_SHARE_INFO_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_SHARE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB requires extension XR_FB_spatial_entity_sharing, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB requires extension XR_FB_space_warp, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_space_warp")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_space_warp\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB requires extension XR_FB_space_warp, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_space_warp")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_space_warp\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB:
            // Enum value XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB requires extension XR_FB_haptic_amplitude_envelope, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_haptic_amplitude_envelope")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_haptic_amplitude_envelope\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SEMANTIC_LABELS_FB:
            // Enum value XR_TYPE_SEMANTIC_LABELS_FB requires extension XR_FB_scene, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SEMANTIC_LABELS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_ROOM_LAYOUT_FB:
            // Enum value XR_TYPE_ROOM_LAYOUT_FB requires extension XR_FB_scene, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_ROOM_LAYOUT_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_BOUNDARY_2D_FB:
            // Enum value XR_TYPE_BOUNDARY_2D_FB requires extension XR_FB_scene, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_BOUNDARY_2D_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB:
            // Enum value XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB requires extension XR_FB_scene, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE:
            // Enum value XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE requires extension XR_ALMALENCE_digital_lens_control, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ALMALENCE_digital_lens_control")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ALMALENCE_digital_lens_control\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB requires extension XR_FB_scene_capture, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene_capture")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene_capture\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB:
            // Enum value XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB requires extension XR_FB_scene_capture, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_scene_capture")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_scene_capture\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_CONTAINER_FB:
            // Enum value XR_TYPE_SPACE_CONTAINER_FB requires extension XR_FB_spatial_entity_container, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_container")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_CONTAINER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_container\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META:
            // Enum value XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META requires extension XR_META_foveation_eye_tracked, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_foveation_eye_tracked")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_foveation_eye_tracked\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META:
            // Enum value XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META requires extension XR_META_foveation_eye_tracked, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_foveation_eye_tracked")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_foveation_eye_tracked\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META:
            // Enum value XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META requires extension XR_META_foveation_eye_tracked, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_foveation_eye_tracked")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_foveation_eye_tracked\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB requires extension XR_FB_face_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_TRACKER_CREATE_INFO_FB:
            // Enum value XR_TYPE_FACE_TRACKER_CREATE_INFO_FB requires extension XR_FB_face_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_TRACKER_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_EXPRESSION_INFO_FB:
            // Enum value XR_TYPE_FACE_EXPRESSION_INFO_FB requires extension XR_FB_face_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_EXPRESSION_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB:
            // Enum value XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB requires extension XR_FB_face_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EYE_TRACKER_CREATE_INFO_FB:
            // Enum value XR_TYPE_EYE_TRACKER_CREATE_INFO_FB requires extension XR_FB_eye_tracking_social, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EYE_TRACKER_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EYE_GAZES_INFO_FB:
            // Enum value XR_TYPE_EYE_GAZES_INFO_FB requires extension XR_FB_eye_tracking_social, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EYE_GAZES_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EYE_GAZES_FB:
            // Enum value XR_TYPE_EYE_GAZES_FB requires extension XR_FB_eye_tracking_social, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EYE_GAZES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB:
            // Enum value XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB requires extension XR_FB_eye_tracking_social, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB:
            // Enum value XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB requires extension XR_FB_passthrough_keyboard_hands, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough_keyboard_hands")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough_keyboard_hands\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB requires extension XR_FB_composition_layer_settings, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_settings")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_composition_layer_settings\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAPTIC_PCM_VIBRATION_FB:
            // Enum value XR_TYPE_HAPTIC_PCM_VIBRATION_FB requires extension XR_FB_haptic_pcm, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_haptic_pcm")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAPTIC_PCM_VIBRATION_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_haptic_pcm\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB:
            // Enum value XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB requires extension XR_FB_haptic_pcm, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_haptic_pcm")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_haptic_pcm\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB:
            // Enum value XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB requires extension XR_FB_composition_layer_depth_test, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_depth_test")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_composition_layer_depth_test\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META:
            // Enum value XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META requires extension XR_META_local_dimming, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_local_dimming")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_local_dimming\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_PREFERENCES_META:
            // Enum value XR_TYPE_PASSTHROUGH_PREFERENCES_META requires extension XR_META_passthrough_preferences, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_preferences")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_PREFERENCES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_preferences\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META:
            // Enum value XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META:
            // Enum value XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META:
            // Enum value XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META:
            // Enum value XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META:
            // Enum value XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META:
            // Enum value XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META:
            // Enum value XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EXTERNAL_CAMERA_OCULUS:
            // Enum value XR_TYPE_EXTERNAL_CAMERA_OCULUS requires extension XR_OCULUS_external_camera, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_OCULUS_external_camera")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EXTERNAL_CAMERA_OCULUS\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_OCULUS_external_camera\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META:
            // Enum value XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META requires extension XR_META_vulkan_swapchain_create_info, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_vulkan_swapchain_create_info")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_vulkan_swapchain_create_info\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PERFORMANCE_METRICS_STATE_META:
            // Enum value XR_TYPE_PERFORMANCE_METRICS_STATE_META requires extension XR_META_performance_metrics, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_performance_metrics")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PERFORMANCE_METRICS_STATE_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_performance_metrics\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PERFORMANCE_METRICS_COUNTER_META:
            // Enum value XR_TYPE_PERFORMANCE_METRICS_COUNTER_META requires extension XR_META_performance_metrics, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_performance_metrics")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PERFORMANCE_METRICS_COUNTER_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_performance_metrics\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_LIST_SAVE_INFO_FB:
            // Enum value XR_TYPE_SPACE_LIST_SAVE_INFO_FB requires extension XR_FB_spatial_entity_storage_batch, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage_batch")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_LIST_SAVE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage_batch\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB:
            // Enum value XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB requires extension XR_FB_spatial_entity_storage_batch, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage_batch")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_storage_batch\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_USER_CREATE_INFO_FB:
            // Enum value XR_TYPE_SPACE_USER_CREATE_INFO_FB requires extension XR_FB_spatial_entity_user, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_user")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_USER_CREATE_INFO_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_user\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META:
            // Enum value XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META requires extension XR_META_headset_id, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_headset_id")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_headset_id\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META:
            // Enum value XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META requires extension XR_META_recommended_layer_resolution, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_recommended_layer_resolution")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_recommended_layer_resolution\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META:
            // Enum value XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META requires extension XR_META_recommended_layer_resolution, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_recommended_layer_resolution")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_recommended_layer_resolution\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META:
            // Enum value XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META:
            // Enum value XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META requires extension XR_META_spatial_entity_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_spatial_entity_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_spatial_entity_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPACE_TRIANGLE_MESH_META:
            // Enum value XR_TYPE_SPACE_TRIANGLE_MESH_META requires extension XR_META_spatial_entity_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_spatial_entity_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPACE_TRIANGLE_MESH_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_spatial_entity_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB:
            // Enum value XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB requires extension XR_FB_face_tracking2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB:
            // Enum value XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB requires extension XR_FB_face_tracking2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_EXPRESSION_INFO2_FB:
            // Enum value XR_TYPE_FACE_EXPRESSION_INFO2_FB requires extension XR_FB_face_tracking2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_EXPRESSION_INFO2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB:
            // Enum value XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB requires extension XR_FB_face_tracking2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC:
            // Enum value XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC requires extension XR_HTC_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_COLOR_HTC:
            // Enum value XR_TYPE_PASSTHROUGH_COLOR_HTC requires extension XR_HTC_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_COLOR_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC:
            // Enum value XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC requires extension XR_HTC_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC:
            // Enum value XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC requires extension XR_HTC_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_APPLY_INFO_HTC:
            // Enum value XR_TYPE_FOVEATION_APPLY_INFO_HTC requires extension XR_HTC_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_APPLY_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC:
            // Enum value XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC requires extension XR_HTC_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC:
            // Enum value XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC requires extension XR_HTC_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC:
            // Enum value XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC requires extension XR_HTC_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC:
            // Enum value XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC requires extension XR_HTC_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT:
            // Enum value XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT requires extension XR_EXT_active_action_set_priority, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_active_action_set_priority")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_active_action_set_priority\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX:
            // Enum value XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX requires extension XR_MNDX_force_feedback_curl, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MNDX_force_feedback_curl")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MNDX_force_feedback_curl\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX:
            // Enum value XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX requires extension XR_MNDX_force_feedback_curl, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MNDX_force_feedback_curl")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MNDX_force_feedback_curl\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT:
            // Enum value XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT requires extension XR_EXT_hand_tracking_data_source, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking_data_source")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking_data_source\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT:
            // Enum value XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT requires extension XR_EXT_hand_tracking_data_source, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking_data_source")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking_data_source\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_LOCATION_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_LOCATION_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_LOCATION_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT:
            // Enum value XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT:
            // Enum value XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT:
            // Enum value XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT requires extension XR_EXT_user_presence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_user_presence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_user_presence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT:
            // Enum value XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT requires extension XR_EXT_user_presence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_user_presence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrStructureType value \"XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_user_presence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrFormFactor enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFormFactor value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY:
            return true;
        case XR_FORM_FACTOR_HANDHELD_DISPLAY:
            return true;
    default:
        return false;
}
}

// Function to validate XrViewConfigurationType enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrViewConfigurationType value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO:
            return true;
        case XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO:
            return true;
        case XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO:
            // Enum value XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO requires extension XR_VARJO_quad_views, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_quad_views")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrViewConfigurationType value \"XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_quad_views\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT:
            // Enum value XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT requires extension XR_MSFT_first_person_observer, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_first_person_observer")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrViewConfigurationType value \"XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_first_person_observer\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrEnvironmentBlendMode enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrEnvironmentBlendMode value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_ENVIRONMENT_BLEND_MODE_OPAQUE:
            return true;
        case XR_ENVIRONMENT_BLEND_MODE_ADDITIVE:
            return true;
        case XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND:
            return true;
    default:
        return false;
}
}

// Function to validate XrReferenceSpaceType enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrReferenceSpaceType value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_REFERENCE_SPACE_TYPE_VIEW:
            return true;
        case XR_REFERENCE_SPACE_TYPE_LOCAL:
            return true;
        case XR_REFERENCE_SPACE_TYPE_STAGE:
            return true;
        case XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT:
            // Enum value XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT requires extension XR_MSFT_unbounded_reference_space, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_unbounded_reference_space")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrReferenceSpaceType value \"XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_unbounded_reference_space\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO:
            // Enum value XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO requires extension XR_VARJO_foveated_rendering, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_foveated_rendering")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrReferenceSpaceType value \"XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_VARJO_foveated_rendering\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_REFERENCE_SPACE_TYPE_LOCALIZATION_MAP_ML:
            // Enum value XR_REFERENCE_SPACE_TYPE_LOCALIZATION_MAP_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrReferenceSpaceType value \"XR_REFERENCE_SPACE_TYPE_LOCALIZATION_MAP_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT:
            // Enum value XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT requires extension XR_EXT_local_floor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_local_floor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrReferenceSpaceType value \"XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_local_floor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrActionType enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrActionType value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_ACTION_TYPE_BOOLEAN_INPUT:
            return true;
        case XR_ACTION_TYPE_FLOAT_INPUT:
            return true;
        case XR_ACTION_TYPE_VECTOR2F_INPUT:
            return true;
        case XR_ACTION_TYPE_POSE_INPUT:
            return true;
        case XR_ACTION_TYPE_VIBRATION_OUTPUT:
            return true;
    default:
        return false;
}
}

// Function to validate XrEyeVisibility enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrEyeVisibility value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_EYE_VISIBILITY_BOTH:
            return true;
        case XR_EYE_VISIBILITY_LEFT:
            return true;
        case XR_EYE_VISIBILITY_RIGHT:
            return true;
    default:
        return false;
}
}

// Function to validate XrSessionState enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSessionState value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_SESSION_STATE_UNKNOWN:
            return true;
        case XR_SESSION_STATE_IDLE:
            return true;
        case XR_SESSION_STATE_READY:
            return true;
        case XR_SESSION_STATE_SYNCHRONIZED:
            return true;
        case XR_SESSION_STATE_VISIBLE:
            return true;
        case XR_SESSION_STATE_FOCUSED:
            return true;
        case XR_SESSION_STATE_STOPPING:
            return true;
        case XR_SESSION_STATE_LOSS_PENDING:
            return true;
        case XR_SESSION_STATE_EXITING:
            return true;
    default:
        return false;
}
}

// Function to validate XrObjectType enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrObjectType value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    switch (value) {
        case XR_OBJECT_TYPE_UNKNOWN:
            return true;
        case XR_OBJECT_TYPE_INSTANCE:
            return true;
        case XR_OBJECT_TYPE_SESSION:
            return true;
        case XR_OBJECT_TYPE_SWAPCHAIN:
            return true;
        case XR_OBJECT_TYPE_SPACE:
            return true;
        case XR_OBJECT_TYPE_ACTION_SET:
            return true;
        case XR_OBJECT_TYPE_ACTION:
            return true;
        case XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT:
            // Enum value XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT requires extension XR_EXT_debug_utils, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_debug_utils")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_debug_utils\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT:
            // Enum value XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT requires extension XR_MSFT_spatial_anchor, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT:
            // Enum value XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_HAND_TRACKER_EXT:
            // Enum value XR_OBJECT_TYPE_HAND_TRACKER_EXT requires extension XR_EXT_hand_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_HAND_TRACKER_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_BODY_TRACKER_FB:
            // Enum value XR_OBJECT_TYPE_BODY_TRACKER_FB requires extension XR_FB_body_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_BODY_TRACKER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT:
            // Enum value XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SCENE_MSFT:
            // Enum value XR_OBJECT_TYPE_SCENE_MSFT requires extension XR_MSFT_scene_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SCENE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_FACIAL_TRACKER_HTC:
            // Enum value XR_OBJECT_TYPE_FACIAL_TRACKER_HTC requires extension XR_HTC_facial_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_FACIAL_TRACKER_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_FOVEATION_PROFILE_FB:
            // Enum value XR_OBJECT_TYPE_FOVEATION_PROFILE_FB requires extension XR_FB_foveation, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_FOVEATION_PROFILE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_foveation\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_TRIANGLE_MESH_FB:
            // Enum value XR_OBJECT_TYPE_TRIANGLE_MESH_FB requires extension XR_FB_triangle_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_triangle_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_TRIANGLE_MESH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_triangle_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_PASSTHROUGH_FB:
            // Enum value XR_OBJECT_TYPE_PASSTHROUGH_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_PASSTHROUGH_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB:
            // Enum value XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB:
            // Enum value XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB requires extension XR_FB_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_MARKER_DETECTOR_ML:
            // Enum value XR_OBJECT_TYPE_MARKER_DETECTOR_ML requires extension XR_ML_marker_understanding, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_MARKER_DETECTOR_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML:
            // Enum value XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML requires extension XR_ML_localization_map, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT:
            // Enum value XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT requires extension XR_MSFT_spatial_anchor_persistence, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_anchor_persistence")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_spatial_anchor_persistence\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_FACE_TRACKER_FB:
            // Enum value XR_OBJECT_TYPE_FACE_TRACKER_FB requires extension XR_FB_face_tracking, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_FACE_TRACKER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_EYE_TRACKER_FB:
            // Enum value XR_OBJECT_TYPE_EYE_TRACKER_FB requires extension XR_FB_eye_tracking_social, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_EYE_TRACKER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META:
            // Enum value XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META requires extension XR_META_virtual_keyboard, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_SPACE_USER_FB:
            // Enum value XR_OBJECT_TYPE_SPACE_USER_FB requires extension XR_FB_spatial_entity_user, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_user")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_SPACE_USER_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_spatial_entity_user\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META:
            // Enum value XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META requires extension XR_META_passthrough_color_lut, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_FACE_TRACKER2_FB:
            // Enum value XR_OBJECT_TYPE_FACE_TRACKER2_FB requires extension XR_FB_face_tracking2, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_FACE_TRACKER2_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_PASSTHROUGH_HTC:
            // Enum value XR_OBJECT_TYPE_PASSTHROUGH_HTC requires extension XR_HTC_passthrough, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_PASSTHROUGH_HTC\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_OBJECT_TYPE_PLANE_DETECTOR_EXT:
            // Enum value XR_OBJECT_TYPE_PLANE_DETECTOR_EXT requires extension XR_EXT_plane_detection, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrObjectType value \"XR_OBJECT_TYPE_PLANE_DETECTOR_EXT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

#if defined(XR_USE_PLATFORM_ANDROID)
// Function to validate XrAndroidThreadTypeKHR enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrAndroidThreadTypeKHR value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_KHR_android_thread_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_android_thread_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrAndroidThreadTypeKHR requires extension ";
        error_str += " \"XR_KHR_android_thread_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_ANDROID_THREAD_TYPE_APPLICATION_MAIN_KHR:
            return true;
        case XR_ANDROID_THREAD_TYPE_APPLICATION_WORKER_KHR:
            return true;
        case XR_ANDROID_THREAD_TYPE_RENDERER_MAIN_KHR:
            return true;
        case XR_ANDROID_THREAD_TYPE_RENDERER_WORKER_KHR:
            return true;
    default:
        return false;
}
}

#endif // defined(XR_USE_PLATFORM_ANDROID)
// Function to validate XrVisibilityMaskTypeKHR enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrVisibilityMaskTypeKHR value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_KHR_visibility_mask, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_visibility_mask")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrVisibilityMaskTypeKHR requires extension ";
        error_str += " \"XR_KHR_visibility_mask\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR:
            return true;
        case XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR:
            return true;
        case XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR:
            return true;
    default:
        return false;
}
}

// Function to validate XrPerfSettingsDomainEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPerfSettingsDomainEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_performance_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPerfSettingsDomainEXT requires extension ";
        error_str += " \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PERF_SETTINGS_DOMAIN_CPU_EXT:
            return true;
        case XR_PERF_SETTINGS_DOMAIN_GPU_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPerfSettingsSubDomainEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPerfSettingsSubDomainEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_performance_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPerfSettingsSubDomainEXT requires extension ";
        error_str += " \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT:
            return true;
        case XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT:
            return true;
        case XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPerfSettingsLevelEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPerfSettingsLevelEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_performance_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPerfSettingsLevelEXT requires extension ";
        error_str += " \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT:
            return true;
        case XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT:
            return true;
        case XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT:
            return true;
        case XR_PERF_SETTINGS_LEVEL_BOOST_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPerfSettingsNotificationLevelEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPerfSettingsNotificationLevelEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_performance_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPerfSettingsNotificationLevelEXT requires extension ";
        error_str += " \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT:
            return true;
        case XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT:
            return true;
        case XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrBlendFactorFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrBlendFactorFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_composition_layer_alpha_blend, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_alpha_blend")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrBlendFactorFB requires extension ";
        error_str += " \"XR_FB_composition_layer_alpha_blend\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_BLEND_FACTOR_ZERO_FB:
            return true;
        case XR_BLEND_FACTOR_ONE_FB:
            return true;
        case XR_BLEND_FACTOR_SRC_ALPHA_FB:
            return true;
        case XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB:
            return true;
        case XR_BLEND_FACTOR_DST_ALPHA_FB:
            return true;
        case XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrSpatialGraphNodeTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSpatialGraphNodeTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_spatial_graph_bridge, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_spatial_graph_bridge")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSpatialGraphNodeTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_spatial_graph_bridge\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SPATIAL_GRAPH_NODE_TYPE_STATIC_MSFT:
            return true;
        case XR_SPATIAL_GRAPH_NODE_TYPE_DYNAMIC_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_hand_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandEXT requires extension ";
        error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_LEFT_EXT:
            return true;
        case XR_HAND_RIGHT_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandJointEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandJointEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_hand_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandJointEXT requires extension ";
        error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_JOINT_PALM_EXT:
            return true;
        case XR_HAND_JOINT_WRIST_EXT:
            return true;
        case XR_HAND_JOINT_THUMB_METACARPAL_EXT:
            return true;
        case XR_HAND_JOINT_THUMB_PROXIMAL_EXT:
            return true;
        case XR_HAND_JOINT_THUMB_DISTAL_EXT:
            return true;
        case XR_HAND_JOINT_THUMB_TIP_EXT:
            return true;
        case XR_HAND_JOINT_INDEX_METACARPAL_EXT:
            return true;
        case XR_HAND_JOINT_INDEX_PROXIMAL_EXT:
            return true;
        case XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT:
            return true;
        case XR_HAND_JOINT_INDEX_DISTAL_EXT:
            return true;
        case XR_HAND_JOINT_INDEX_TIP_EXT:
            return true;
        case XR_HAND_JOINT_MIDDLE_METACARPAL_EXT:
            return true;
        case XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT:
            return true;
        case XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT:
            return true;
        case XR_HAND_JOINT_MIDDLE_DISTAL_EXT:
            return true;
        case XR_HAND_JOINT_MIDDLE_TIP_EXT:
            return true;
        case XR_HAND_JOINT_RING_METACARPAL_EXT:
            return true;
        case XR_HAND_JOINT_RING_PROXIMAL_EXT:
            return true;
        case XR_HAND_JOINT_RING_INTERMEDIATE_EXT:
            return true;
        case XR_HAND_JOINT_RING_DISTAL_EXT:
            return true;
        case XR_HAND_JOINT_RING_TIP_EXT:
            return true;
        case XR_HAND_JOINT_LITTLE_METACARPAL_EXT:
            return true;
        case XR_HAND_JOINT_LITTLE_PROXIMAL_EXT:
            return true;
        case XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT:
            return true;
        case XR_HAND_JOINT_LITTLE_DISTAL_EXT:
            return true;
        case XR_HAND_JOINT_LITTLE_TIP_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandJointSetEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandJointSetEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_hand_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandJointSetEXT requires extension ";
        error_str += " \"XR_EXT_hand_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_JOINT_SET_DEFAULT_EXT:
            return true;
        case XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP:
            // Enum value XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP requires extension XR_ULTRALEAP_hand_tracking_forearm, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ULTRALEAP_hand_tracking_forearm")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrHandJointSetEXT value \"XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_ULTRALEAP_hand_tracking_forearm\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrHandPoseTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandPoseTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_hand_tracking_mesh, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_hand_tracking_mesh")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandPoseTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_hand_tracking_mesh\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_POSE_TYPE_TRACKED_MSFT:
            return true;
        case XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrReprojectionModeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrReprojectionModeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_composition_layer_reprojection, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_composition_layer_reprojection")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrReprojectionModeMSFT requires extension ";
        error_str += " \"XR_MSFT_composition_layer_reprojection\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_REPROJECTION_MODE_DEPTH_MSFT:
            return true;
        case XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT:
            return true;
        case XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT:
            return true;
        case XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrBodyJointFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrBodyJointFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_body_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrBodyJointFB requires extension ";
        error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_BODY_JOINT_ROOT_FB:
            return true;
        case XR_BODY_JOINT_HIPS_FB:
            return true;
        case XR_BODY_JOINT_SPINE_LOWER_FB:
            return true;
        case XR_BODY_JOINT_SPINE_MIDDLE_FB:
            return true;
        case XR_BODY_JOINT_SPINE_UPPER_FB:
            return true;
        case XR_BODY_JOINT_CHEST_FB:
            return true;
        case XR_BODY_JOINT_NECK_FB:
            return true;
        case XR_BODY_JOINT_HEAD_FB:
            return true;
        case XR_BODY_JOINT_LEFT_SHOULDER_FB:
            return true;
        case XR_BODY_JOINT_LEFT_SCAPULA_FB:
            return true;
        case XR_BODY_JOINT_LEFT_ARM_UPPER_FB:
            return true;
        case XR_BODY_JOINT_LEFT_ARM_LOWER_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_WRIST_TWIST_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_SHOULDER_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_SCAPULA_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_ARM_UPPER_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_ARM_LOWER_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_PALM_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_WRIST_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_THUMB_TIP_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_INDEX_TIP_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_RING_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_RING_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_RING_TIP_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_LEFT_HAND_LITTLE_TIP_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_PALM_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_WRIST_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_THUMB_TIP_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_INDEX_TIP_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_RING_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_RING_TIP_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_FB:
            return true;
        case XR_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_FB:
            return true;
        case XR_BODY_JOINT_COUNT_FB:
            return true;
        case XR_BODY_JOINT_NONE_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrBodyJointSetFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrBodyJointSetFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_body_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_body_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrBodyJointSetFB requires extension ";
        error_str += " \"XR_FB_body_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_BODY_JOINT_SET_DEFAULT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandJointsMotionRangeEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandJointsMotionRangeEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_hand_joints_motion_range, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_joints_motion_range")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandJointsMotionRangeEXT requires extension ";
        error_str += " \"XR_EXT_hand_joints_motion_range\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT:
            return true;
        case XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneComputeFeatureMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneComputeFeatureMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneComputeFeatureMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_COMPUTE_FEATURE_PLANE_MSFT:
            return true;
        case XR_SCENE_COMPUTE_FEATURE_PLANE_MESH_MSFT:
            return true;
        case XR_SCENE_COMPUTE_FEATURE_VISUAL_MESH_MSFT:
            return true;
        case XR_SCENE_COMPUTE_FEATURE_COLLIDER_MESH_MSFT:
            return true;
        case XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT:
            // Enum value XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT requires extension XR_MSFT_scene_understanding_serialization, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding_serialization")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrSceneComputeFeatureMSFT value \"XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding_serialization\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_SCENE_COMPUTE_FEATURE_MARKER_MSFT:
            // Enum value XR_SCENE_COMPUTE_FEATURE_MARKER_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrSceneComputeFeatureMSFT value \"XR_SCENE_COMPUTE_FEATURE_MARKER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneComputeConsistencyMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneComputeConsistencyMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneComputeConsistencyMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_COMPLETE_MSFT:
            return true;
        case XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_INCOMPLETE_FAST_MSFT:
            return true;
        case XR_SCENE_COMPUTE_CONSISTENCY_OCCLUSION_OPTIMIZED_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrMeshComputeLodMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMeshComputeLodMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMeshComputeLodMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MESH_COMPUTE_LOD_COARSE_MSFT:
            return true;
        case XR_MESH_COMPUTE_LOD_MEDIUM_MSFT:
            return true;
        case XR_MESH_COMPUTE_LOD_FINE_MSFT:
            return true;
        case XR_MESH_COMPUTE_LOD_UNLIMITED_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneComponentTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneComponentTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneComponentTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_COMPONENT_TYPE_INVALID_MSFT:
            return true;
        case XR_SCENE_COMPONENT_TYPE_OBJECT_MSFT:
            return true;
        case XR_SCENE_COMPONENT_TYPE_PLANE_MSFT:
            return true;
        case XR_SCENE_COMPONENT_TYPE_VISUAL_MESH_MSFT:
            return true;
        case XR_SCENE_COMPONENT_TYPE_COLLIDER_MESH_MSFT:
            return true;
        case XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT:
            // Enum value XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT requires extension XR_MSFT_scene_understanding_serialization, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding_serialization")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrSceneComponentTypeMSFT value \"XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_understanding_serialization\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_SCENE_COMPONENT_TYPE_MARKER_MSFT:
            // Enum value XR_SCENE_COMPONENT_TYPE_MARKER_MSFT requires extension XR_MSFT_scene_marker, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrSceneComponentTypeMSFT value \"XR_SCENE_COMPONENT_TYPE_MARKER_MSFT\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneObjectTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneObjectTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneObjectTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_OBJECT_TYPE_UNCATEGORIZED_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_BACKGROUND_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_WALL_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_FLOOR_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_CEILING_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_PLATFORM_MSFT:
            return true;
        case XR_SCENE_OBJECT_TYPE_INFERRED_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrScenePlaneAlignmentTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrScenePlaneAlignmentTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrScenePlaneAlignmentTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_PLANE_ALIGNMENT_TYPE_NON_ORTHOGONAL_MSFT:
            return true;
        case XR_SCENE_PLANE_ALIGNMENT_TYPE_HORIZONTAL_MSFT:
            return true;
        case XR_SCENE_PLANE_ALIGNMENT_TYPE_VERTICAL_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneComputeStateMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneComputeStateMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneComputeStateMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_COMPUTE_STATE_NONE_MSFT:
            return true;
        case XR_SCENE_COMPUTE_STATE_UPDATING_MSFT:
            return true;
        case XR_SCENE_COMPUTE_STATE_COMPLETED_MSFT:
            return true;
        case XR_SCENE_COMPUTE_STATE_COMPLETED_WITH_ERROR_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrEyeExpressionHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrEyeExpressionHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_facial_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrEyeExpressionHTC requires extension ";
        error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_EYE_EXPRESSION_LEFT_BLINK_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_WIDE_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_BLINK_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_WIDE_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_DOWN_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_DOWN_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_OUT_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_IN_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_IN_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_OUT_HTC:
            return true;
        case XR_EYE_EXPRESSION_LEFT_UP_HTC:
            return true;
        case XR_EYE_EXPRESSION_RIGHT_UP_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrLipExpressionHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrLipExpressionHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_facial_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrLipExpressionHTC requires extension ";
        error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_LIP_EXPRESSION_JAW_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_JAW_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_JAW_FORWARD_HTC:
            return true;
        case XR_LIP_EXPRESSION_JAW_OPEN_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_POUT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_CHEEK_SUCK_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC:
            return true;
        case XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_LEFT_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_UP_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_DOWN_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_ROLL_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC:
            return true;
        case XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrFacialTrackingTypeHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFacialTrackingTypeHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_facial_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_facial_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFacialTrackingTypeHTC requires extension ";
        error_str += " \"XR_HTC_facial_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC:
            return true;
        case XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrColorSpaceFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrColorSpaceFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_color_space, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_color_space")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrColorSpaceFB requires extension ";
        error_str += " \"XR_FB_color_space\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_COLOR_SPACE_UNMANAGED_FB:
            return true;
        case XR_COLOR_SPACE_REC2020_FB:
            return true;
        case XR_COLOR_SPACE_REC709_FB:
            return true;
        case XR_COLOR_SPACE_RIFT_CV1_FB:
            return true;
        case XR_COLOR_SPACE_RIFT_S_FB:
            return true;
        case XR_COLOR_SPACE_QUEST_FB:
            return true;
        case XR_COLOR_SPACE_P3_FB:
            return true;
        case XR_COLOR_SPACE_ADOBE_RGB_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrSpaceComponentTypeFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSpaceComponentTypeFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_spatial_entity, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSpaceComponentTypeFB requires extension ";
        error_str += " \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SPACE_COMPONENT_TYPE_LOCATABLE_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_STORABLE_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_SHARABLE_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_BOUNDED_2D_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_BOUNDED_3D_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_SEMANTIC_LABELS_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_ROOM_LAYOUT_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_SPACE_CONTAINER_FB:
            return true;
        case XR_SPACE_COMPONENT_TYPE_TRIANGLE_MESH_META:
            // Enum value XR_SPACE_COMPONENT_TYPE_TRIANGLE_MESH_META requires extension XR_META_spatial_entity_mesh, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_spatial_entity_mesh")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrSpaceComponentTypeFB value \"XR_SPACE_COMPONENT_TYPE_TRIANGLE_MESH_META\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_META_spatial_entity_mesh\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrFoveationLevelFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFoveationLevelFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_foveation_configuration, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation_configuration")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFoveationLevelFB requires extension ";
        error_str += " \"XR_FB_foveation_configuration\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FOVEATION_LEVEL_NONE_FB:
            return true;
        case XR_FOVEATION_LEVEL_LOW_FB:
            return true;
        case XR_FOVEATION_LEVEL_MEDIUM_FB:
            return true;
        case XR_FOVEATION_LEVEL_HIGH_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFoveationDynamicFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFoveationDynamicFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_foveation_configuration, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation_configuration")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFoveationDynamicFB requires extension ";
        error_str += " \"XR_FB_foveation_configuration\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FOVEATION_DYNAMIC_DISABLED_FB:
            return true;
        case XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrWindingOrderFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrWindingOrderFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_triangle_mesh, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_triangle_mesh")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrWindingOrderFB requires extension ";
        error_str += " \"XR_FB_triangle_mesh\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_WINDING_ORDER_UNKNOWN_FB:
            return true;
        case XR_WINDING_ORDER_CW_FB:
            return true;
        case XR_WINDING_ORDER_CCW_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrPassthroughLayerPurposeFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPassthroughLayerPurposeFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_passthrough, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPassthroughLayerPurposeFB requires extension ";
        error_str += " \"XR_FB_passthrough\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB:
            return true;
        case XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB:
            return true;
        case XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB:
            // Enum value XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB requires extension XR_FB_passthrough_keyboard_hands, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough_keyboard_hands")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrPassthroughLayerPurposeFB value \"XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough_keyboard_hands\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
        case XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB:
            // Enum value XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB requires extension XR_FB_passthrough_keyboard_hands, so check that it is enabled
            if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_passthrough_keyboard_hands")) {
                std::string vuid = "VUID-";
                vuid += validation_name;
                vuid += "-";
                vuid += item_name;
                vuid += "-parameter";
                std::string error_str = "XrPassthroughLayerPurposeFB value \"XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB\"";
                error_str += " being used, which requires extension ";
                error_str += " \"XR_FB_passthrough_keyboard_hands\" to be enabled, but it is not enabled";
                CoreValidLogMessage(instance_info, vuid,
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, error_str);
                return false;
            }
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorProfileML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorProfileML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorProfileML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_PROFILE_DEFAULT_ML:
            return true;
        case XR_MARKER_DETECTOR_PROFILE_SPEED_ML:
            return true;
        case XR_MARKER_DETECTOR_PROFILE_ACCURACY_ML:
            return true;
        case XR_MARKER_DETECTOR_PROFILE_SMALL_TARGETS_ML:
            return true;
        case XR_MARKER_DETECTOR_PROFILE_LARGE_FOV_ML:
            return true;
        case XR_MARKER_DETECTOR_PROFILE_CUSTOM_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerTypeML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerTypeML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerTypeML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_TYPE_ARUCO_ML:
            return true;
        case XR_MARKER_TYPE_APRIL_TAG_ML:
            return true;
        case XR_MARKER_TYPE_QR_ML:
            return true;
        case XR_MARKER_TYPE_EAN_13_ML:
            return true;
        case XR_MARKER_TYPE_UPC_A_ML:
            return true;
        case XR_MARKER_TYPE_CODE_128_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerArucoDictML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerArucoDictML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerArucoDictML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_ARUCO_DICT_4X4_50_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_4X4_100_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_4X4_250_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_4X4_1000_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_5X5_50_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_5X5_100_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_5X5_250_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_5X5_1000_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_6X6_50_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_6X6_100_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_6X6_250_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_6X6_1000_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_7X7_50_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_7X7_100_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_7X7_250_ML:
            return true;
        case XR_MARKER_ARUCO_DICT_7X7_1000_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerAprilTagDictML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerAprilTagDictML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerAprilTagDictML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_APRIL_TAG_DICT_16H5_ML:
            return true;
        case XR_MARKER_APRIL_TAG_DICT_25H9_ML:
            return true;
        case XR_MARKER_APRIL_TAG_DICT_36H10_ML:
            return true;
        case XR_MARKER_APRIL_TAG_DICT_36H11_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorFpsML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorFpsML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorFpsML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_FPS_LOW_ML:
            return true;
        case XR_MARKER_DETECTOR_FPS_MEDIUM_ML:
            return true;
        case XR_MARKER_DETECTOR_FPS_HIGH_ML:
            return true;
        case XR_MARKER_DETECTOR_FPS_MAX_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorResolutionML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorResolutionML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorResolutionML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_RESOLUTION_LOW_ML:
            return true;
        case XR_MARKER_DETECTOR_RESOLUTION_MEDIUM_ML:
            return true;
        case XR_MARKER_DETECTOR_RESOLUTION_HIGH_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorCameraML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorCameraML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorCameraML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_CAMERA_RGB_CAMERA_ML:
            return true;
        case XR_MARKER_DETECTOR_CAMERA_WORLD_CAMERAS_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorCornerRefineMethodML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorCornerRefineMethodML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorCornerRefineMethodML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_NONE_ML:
            return true;
        case XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_SUBPIX_ML:
            return true;
        case XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_CONTOUR_ML:
            return true;
        case XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_APRIL_TAG_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorFullAnalysisIntervalML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorFullAnalysisIntervalML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorFullAnalysisIntervalML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MAX_ML:
            return true;
        case XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_FAST_ML:
            return true;
        case XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MEDIUM_ML:
            return true;
        case XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_SLOW_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrMarkerDetectorStatusML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrMarkerDetectorStatusML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_marker_understanding, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_marker_understanding")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrMarkerDetectorStatusML requires extension ";
        error_str += " \"XR_ML_marker_understanding\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_MARKER_DETECTOR_STATUS_PENDING_ML:
            return true;
        case XR_MARKER_DETECTOR_STATUS_READY_ML:
            return true;
        case XR_MARKER_DETECTOR_STATUS_ERROR_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrLocalizationMapStateML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrLocalizationMapStateML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_localization_map, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrLocalizationMapStateML requires extension ";
        error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_LOCALIZATION_MAP_STATE_NOT_LOCALIZED_ML:
            return true;
        case XR_LOCALIZATION_MAP_STATE_LOCALIZED_ML:
            return true;
        case XR_LOCALIZATION_MAP_STATE_LOCALIZATION_PENDING_ML:
            return true;
        case XR_LOCALIZATION_MAP_STATE_LOCALIZATION_SLEEPING_BEFORE_RETRY_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrLocalizationMapTypeML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrLocalizationMapTypeML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_localization_map, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrLocalizationMapTypeML requires extension ";
        error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_LOCALIZATION_MAP_TYPE_ON_DEVICE_ML:
            return true;
        case XR_LOCALIZATION_MAP_TYPE_CLOUD_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrLocalizationMapConfidenceML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrLocalizationMapConfidenceML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_localization_map, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrLocalizationMapConfidenceML requires extension ";
        error_str += " \"XR_ML_localization_map\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_LOCALIZATION_MAP_CONFIDENCE_POOR_ML:
            return true;
        case XR_LOCALIZATION_MAP_CONFIDENCE_FAIR_ML:
            return true;
        case XR_LOCALIZATION_MAP_CONFIDENCE_GOOD_ML:
            return true;
        case XR_LOCALIZATION_MAP_CONFIDENCE_EXCELLENT_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneMarkerTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneMarkerTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_marker, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneMarkerTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_MARKER_TYPE_QR_CODE_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrSceneMarkerQRCodeSymbolTypeMSFT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSceneMarkerQRCodeSymbolTypeMSFT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MSFT_scene_marker, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MSFT_scene_marker")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSceneMarkerQRCodeSymbolTypeMSFT requires extension ";
        error_str += " \"XR_MSFT_scene_marker\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_QR_CODE_MSFT:
            return true;
        case XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_MICRO_QR_CODE_MSFT:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandForearmJointULTRALEAP enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandForearmJointULTRALEAP value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ULTRALEAP_hand_tracking_forearm, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ULTRALEAP_hand_tracking_forearm")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandForearmJointULTRALEAP requires extension ";
        error_str += " \"XR_ULTRALEAP_hand_tracking_forearm\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_FOREARM_JOINT_PALM_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_WRIST_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_THUMB_METACARPAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_THUMB_PROXIMAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_THUMB_DISTAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_THUMB_TIP_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_INDEX_METACARPAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_INDEX_PROXIMAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_INDEX_INTERMEDIATE_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_INDEX_DISTAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_INDEX_TIP_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_MIDDLE_METACARPAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_MIDDLE_PROXIMAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_MIDDLE_INTERMEDIATE_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_MIDDLE_DISTAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_MIDDLE_TIP_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_RING_METACARPAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_RING_PROXIMAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_RING_INTERMEDIATE_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_RING_DISTAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_RING_TIP_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_LITTLE_METACARPAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_LITTLE_PROXIMAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_LITTLE_INTERMEDIATE_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_LITTLE_DISTAL_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_LITTLE_TIP_ULTRALEAP:
            return true;
        case XR_HAND_FOREARM_JOINT_ELBOW_ULTRALEAP:
            return true;
    default:
        return false;
}
}

// Function to validate XrSpaceQueryActionFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSpaceQueryActionFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_spatial_entity_query, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSpaceQueryActionFB requires extension ";
        error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SPACE_QUERY_ACTION_LOAD_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrSpaceStorageLocationFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSpaceStorageLocationFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_spatial_entity_query, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSpaceStorageLocationFB requires extension ";
        error_str += " \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SPACE_STORAGE_LOCATION_INVALID_FB:
            return true;
        case XR_SPACE_STORAGE_LOCATION_LOCAL_FB:
            return true;
        case XR_SPACE_STORAGE_LOCATION_CLOUD_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrSpacePersistenceModeFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrSpacePersistenceModeFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_spatial_entity_storage, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrSpacePersistenceModeFB requires extension ";
        error_str += " \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_SPACE_PERSISTENCE_MODE_INVALID_FB:
            return true;
        case XR_SPACE_PERSISTENCE_MODE_INDEFINITE_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceExpressionFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceExpressionFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceExpressionFB requires extension ";
        error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_EXPRESSION_BROW_LOWERER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_BROW_LOWERER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_PUFF_L_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_PUFF_R_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_SUCK_L_FB:
            return true;
        case XR_FACE_EXPRESSION_CHEEK_SUCK_R_FB:
            return true;
        case XR_FACE_EXPRESSION_CHIN_RAISER_B_FB:
            return true;
        case XR_FACE_EXPRESSION_CHIN_RAISER_T_FB:
            return true;
        case XR_FACE_EXPRESSION_DIMPLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_DIMPLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_CLOSED_L_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_CLOSED_R_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_DOWN_L_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_DOWN_R_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_LEFT_L_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_LEFT_R_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_L_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_R_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_UP_L_FB:
            return true;
        case XR_FACE_EXPRESSION_EYES_LOOK_UP_R_FB:
            return true;
        case XR_FACE_EXPRESSION_INNER_BROW_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_INNER_BROW_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_JAW_DROP_FB:
            return true;
        case XR_FACE_EXPRESSION_JAW_SIDEWAYS_LEFT_FB:
            return true;
        case XR_FACE_EXPRESSION_JAW_SIDEWAYS_RIGHT_FB:
            return true;
        case XR_FACE_EXPRESSION_JAW_THRUST_FB:
            return true;
        case XR_FACE_EXPRESSION_LID_TIGHTENER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LID_TIGHTENER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_CORNER_PULLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_CORNER_PULLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_FUNNELER_LB_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_FUNNELER_LT_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_FUNNELER_RB_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_FUNNELER_RT_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_PRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_PRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_PUCKER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_PUCKER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_STRETCHER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_STRETCHER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_SUCK_LB_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_SUCK_LT_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_SUCK_RB_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_SUCK_RT_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_TIGHTENER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LIP_TIGHTENER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_LIPS_TOWARD_FB:
            return true;
        case XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION_MOUTH_LEFT_FB:
            return true;
        case XR_FACE_EXPRESSION_MOUTH_RIGHT_FB:
            return true;
        case XR_FACE_EXPRESSION_NOSE_WRINKLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_NOSE_WRINKLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_OUTER_BROW_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_OUTER_BROW_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_UPPER_LID_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_UPPER_LID_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_UPPER_LIP_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION_UPPER_LIP_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION_COUNT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceExpressionSetFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceExpressionSetFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceExpressionSetFB requires extension ";
        error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_EXPRESSION_SET_DEFAULT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceConfidenceFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceConfidenceFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceConfidenceFB requires extension ";
        error_str += " \"XR_FB_face_tracking\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_CONFIDENCE_LOWER_FACE_FB:
            return true;
        case XR_FACE_CONFIDENCE_UPPER_FACE_FB:
            return true;
        case XR_FACE_CONFIDENCE_COUNT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrEyePositionFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrEyePositionFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_eye_tracking_social, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_eye_tracking_social")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrEyePositionFB requires extension ";
        error_str += " \"XR_FB_eye_tracking_social\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_EYE_POSITION_LEFT_FB:
            return true;
        case XR_EYE_POSITION_RIGHT_FB:
            return true;
        case XR_EYE_POSITION_COUNT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrCompareOpFB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrCompareOpFB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_composition_layer_depth_test, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_composition_layer_depth_test")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrCompareOpFB requires extension ";
        error_str += " \"XR_FB_composition_layer_depth_test\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_COMPARE_OP_NEVER_FB:
            return true;
        case XR_COMPARE_OP_LESS_FB:
            return true;
        case XR_COMPARE_OP_EQUAL_FB:
            return true;
        case XR_COMPARE_OP_LESS_OR_EQUAL_FB:
            return true;
        case XR_COMPARE_OP_GREATER_FB:
            return true;
        case XR_COMPARE_OP_NOT_EQUAL_FB:
            return true;
        case XR_COMPARE_OP_GREATER_OR_EQUAL_FB:
            return true;
        case XR_COMPARE_OP_ALWAYS_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrLocalDimmingModeMETA enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrLocalDimmingModeMETA value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_META_local_dimming, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_local_dimming")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrLocalDimmingModeMETA requires extension ";
        error_str += " \"XR_META_local_dimming\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_LOCAL_DIMMING_MODE_OFF_META:
            return true;
        case XR_LOCAL_DIMMING_MODE_ON_META:
            return true;
    default:
        return false;
}
}

// Function to validate XrVirtualKeyboardLocationTypeMETA enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrVirtualKeyboardLocationTypeMETA value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_META_virtual_keyboard, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrVirtualKeyboardLocationTypeMETA requires extension ";
        error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_CUSTOM_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_FAR_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_DIRECT_META:
            return true;
    default:
        return false;
}
}

// Function to validate XrVirtualKeyboardInputSourceMETA enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrVirtualKeyboardInputSourceMETA value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_META_virtual_keyboard, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_virtual_keyboard")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrVirtualKeyboardInputSourceMETA requires extension ";
        error_str += " \"XR_META_virtual_keyboard\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_LEFT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_RIGHT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_LEFT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_RIGHT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_LEFT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_RIGHT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_LEFT_META:
            return true;
        case XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_RIGHT_META:
            return true;
    default:
        return false;
}
}

// Function to validate XrExternalCameraAttachedToDeviceOCULUS enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrExternalCameraAttachedToDeviceOCULUS value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_OCULUS_external_camera, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_OCULUS_external_camera")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrExternalCameraAttachedToDeviceOCULUS requires extension ";
        error_str += " \"XR_OCULUS_external_camera\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_NONE_OCULUS:
            return true;
        case XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_HMD_OCULUS:
            return true;
        case XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_LTOUCH_OCULUS:
            return true;
        case XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_RTOUCH_OCULUS:
            return true;
    default:
        return false;
}
}

// Function to validate XrPerformanceMetricsCounterUnitMETA enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPerformanceMetricsCounterUnitMETA value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_META_performance_metrics, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_performance_metrics")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPerformanceMetricsCounterUnitMETA requires extension ";
        error_str += " \"XR_META_performance_metrics\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PERFORMANCE_METRICS_COUNTER_UNIT_GENERIC_META:
            return true;
        case XR_PERFORMANCE_METRICS_COUNTER_UNIT_PERCENTAGE_META:
            return true;
        case XR_PERFORMANCE_METRICS_COUNTER_UNIT_MILLISECONDS_META:
            return true;
        case XR_PERFORMANCE_METRICS_COUNTER_UNIT_BYTES_META:
            return true;
        case XR_PERFORMANCE_METRICS_COUNTER_UNIT_HERTZ_META:
            return true;
    default:
        return false;
}
}

// Function to validate XrPassthroughColorLutChannelsMETA enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPassthroughColorLutChannelsMETA value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_META_passthrough_color_lut, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_META_passthrough_color_lut")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPassthroughColorLutChannelsMETA requires extension ";
        error_str += " \"XR_META_passthrough_color_lut\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGB_META:
            return true;
        case XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGBA_META:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceExpression2FB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceExpression2FB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking2, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceExpression2FB requires extension ";
        error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_EXPRESSION2_BROW_LOWERER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_BROW_LOWERER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_PUFF_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_PUFF_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_SUCK_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHEEK_SUCK_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHIN_RAISER_B_FB:
            return true;
        case XR_FACE_EXPRESSION2_CHIN_RAISER_T_FB:
            return true;
        case XR_FACE_EXPRESSION2_DIMPLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_DIMPLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_CLOSED_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_CLOSED_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_UP_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_EYES_LOOK_UP_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_INNER_BROW_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_INNER_BROW_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_JAW_DROP_FB:
            return true;
        case XR_FACE_EXPRESSION2_JAW_SIDEWAYS_LEFT_FB:
            return true;
        case XR_FACE_EXPRESSION2_JAW_SIDEWAYS_RIGHT_FB:
            return true;
        case XR_FACE_EXPRESSION2_JAW_THRUST_FB:
            return true;
        case XR_FACE_EXPRESSION2_LID_TIGHTENER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LID_TIGHTENER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_FUNNELER_LB_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_FUNNELER_LT_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_FUNNELER_RB_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_FUNNELER_RT_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_PRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_PRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_PUCKER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_PUCKER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_STRETCHER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_STRETCHER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_SUCK_LB_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_SUCK_LT_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_SUCK_RB_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_SUCK_RT_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_TIGHTENER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIP_TIGHTENER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_LIPS_TOWARD_FB:
            return true;
        case XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_MOUTH_LEFT_FB:
            return true;
        case XR_FACE_EXPRESSION2_MOUTH_RIGHT_FB:
            return true;
        case XR_FACE_EXPRESSION2_NOSE_WRINKLER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_NOSE_WRINKLER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_UPPER_LID_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_UPPER_LID_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_L_FB:
            return true;
        case XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_R_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_TIP_INTERDENTAL_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_TIP_ALVEOLAR_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_FRONT_DORSAL_PALATE_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_MID_DORSAL_PALATE_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_BACK_DORSAL_VELAR_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_OUT_FB:
            return true;
        case XR_FACE_EXPRESSION2_TONGUE_RETREAT_FB:
            return true;
        case XR_FACE_EXPRESSION2_COUNT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceExpressionSet2FB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceExpressionSet2FB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking2, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceExpressionSet2FB requires extension ";
        error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_EXPRESSION_SET2_DEFAULT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceTrackingDataSource2FB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceTrackingDataSource2FB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking2, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceTrackingDataSource2FB requires extension ";
        error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_TRACKING_DATA_SOURCE2_VISUAL_FB:
            return true;
        case XR_FACE_TRACKING_DATA_SOURCE2_AUDIO_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrFaceConfidence2FB enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFaceConfidence2FB value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_FB_face_tracking2, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_face_tracking2")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFaceConfidence2FB requires extension ";
        error_str += " \"XR_FB_face_tracking2\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FACE_CONFIDENCE2_LOWER_FACE_FB:
            return true;
        case XR_FACE_CONFIDENCE2_UPPER_FACE_FB:
            return true;
        case XR_FACE_CONFIDENCE2_COUNT_FB:
            return true;
    default:
        return false;
}
}

// Function to validate XrTrackingOptimizationSettingsDomainQCOM enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrTrackingOptimizationSettingsDomainQCOM value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_QCOM_tracking_optimization_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_QCOM_tracking_optimization_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrTrackingOptimizationSettingsDomainQCOM requires extension ";
        error_str += " \"XR_QCOM_tracking_optimization_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_TRACKING_OPTIMIZATION_SETTINGS_DOMAIN_ALL_QCOM:
            return true;
    default:
        return false;
}
}

// Function to validate XrTrackingOptimizationSettingsHintQCOM enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrTrackingOptimizationSettingsHintQCOM value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_QCOM_tracking_optimization_settings, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_QCOM_tracking_optimization_settings")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrTrackingOptimizationSettingsHintQCOM requires extension ";
        error_str += " \"XR_QCOM_tracking_optimization_settings\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_NONE_QCOM:
            return true;
        case XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LONG_RANGE_PRIORIZATION_QCOM:
            return true;
        case XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_CLOSE_RANGE_PRIORIZATION_QCOM:
            return true;
        case XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LOW_POWER_PRIORIZATION_QCOM:
            return true;
        case XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_HIGH_POWER_PRIORIZATION_QCOM:
            return true;
    default:
        return false;
}
}

// Function to validate XrPassthroughFormHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPassthroughFormHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_passthrough, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPassthroughFormHTC requires extension ";
        error_str += " \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PASSTHROUGH_FORM_PLANAR_HTC:
            return true;
        case XR_PASSTHROUGH_FORM_PROJECTED_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrFoveationModeHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFoveationModeHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_foveation, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_foveation")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFoveationModeHTC requires extension ";
        error_str += " \"XR_HTC_foveation\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FOVEATION_MODE_DISABLE_HTC:
            return true;
        case XR_FOVEATION_MODE_FIXED_HTC:
            return true;
        case XR_FOVEATION_MODE_DYNAMIC_HTC:
            return true;
        case XR_FOVEATION_MODE_CUSTOM_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrFoveationLevelHTC enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrFoveationLevelHTC value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_HTC_foveation, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_foveation")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrFoveationLevelHTC requires extension ";
        error_str += " \"XR_HTC_foveation\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FOVEATION_LEVEL_NONE_HTC:
            return true;
        case XR_FOVEATION_LEVEL_LOW_HTC:
            return true;
        case XR_FOVEATION_LEVEL_MEDIUM_HTC:
            return true;
        case XR_FOVEATION_LEVEL_HIGH_HTC:
            return true;
    default:
        return false;
}
}

// Function to validate XrForceFeedbackCurlLocationMNDX enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrForceFeedbackCurlLocationMNDX value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_MNDX_force_feedback_curl, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_MNDX_force_feedback_curl")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrForceFeedbackCurlLocationMNDX requires extension ";
        error_str += " \"XR_MNDX_force_feedback_curl\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_FORCE_FEEDBACK_CURL_LOCATION_THUMB_CURL_MNDX:
            return true;
        case XR_FORCE_FEEDBACK_CURL_LOCATION_INDEX_CURL_MNDX:
            return true;
        case XR_FORCE_FEEDBACK_CURL_LOCATION_MIDDLE_CURL_MNDX:
            return true;
        case XR_FORCE_FEEDBACK_CURL_LOCATION_RING_CURL_MNDX:
            return true;
        case XR_FORCE_FEEDBACK_CURL_LOCATION_LITTLE_CURL_MNDX:
            return true;
    default:
        return false;
}
}

// Function to validate XrHandTrackingDataSourceEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHandTrackingDataSourceEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_hand_tracking_data_source, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_hand_tracking_data_source")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHandTrackingDataSourceEXT requires extension ";
        error_str += " \"XR_EXT_hand_tracking_data_source\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HAND_TRACKING_DATA_SOURCE_UNOBSTRUCTED_EXT:
            return true;
        case XR_HAND_TRACKING_DATA_SOURCE_CONTROLLER_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPlaneDetectorOrientationEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPlaneDetectorOrientationEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_plane_detection, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPlaneDetectorOrientationEXT requires extension ";
        error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_UPWARD_EXT:
            return true;
        case XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_DOWNWARD_EXT:
            return true;
        case XR_PLANE_DETECTOR_ORIENTATION_VERTICAL_EXT:
            return true;
        case XR_PLANE_DETECTOR_ORIENTATION_ARBITRARY_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPlaneDetectorSemanticTypeEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPlaneDetectorSemanticTypeEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_plane_detection, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPlaneDetectorSemanticTypeEXT requires extension ";
        error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PLANE_DETECTOR_SEMANTIC_TYPE_UNDEFINED_EXT:
            return true;
        case XR_PLANE_DETECTOR_SEMANTIC_TYPE_CEILING_EXT:
            return true;
        case XR_PLANE_DETECTOR_SEMANTIC_TYPE_FLOOR_EXT:
            return true;
        case XR_PLANE_DETECTOR_SEMANTIC_TYPE_WALL_EXT:
            return true;
        case XR_PLANE_DETECTOR_SEMANTIC_TYPE_PLATFORM_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrPlaneDetectionStateEXT enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrPlaneDetectionStateEXT value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_EXT_plane_detection, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_plane_detection")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrPlaneDetectionStateEXT requires extension ";
        error_str += " \"XR_EXT_plane_detection\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_PLANE_DETECTION_STATE_NONE_EXT:
            return true;
        case XR_PLANE_DETECTION_STATE_PENDING_EXT:
            return true;
        case XR_PLANE_DETECTION_STATE_DONE_EXT:
            return true;
        case XR_PLANE_DETECTION_STATE_ERROR_EXT:
            return true;
        case XR_PLANE_DETECTION_STATE_FATAL_EXT:
            return true;
    default:
        return false;
}
}

// Function to validate XrHeadsetFitStatusML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrHeadsetFitStatusML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_user_calibration, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrHeadsetFitStatusML requires extension ";
        error_str += " \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_HEADSET_FIT_STATUS_UNKNOWN_ML:
            return true;
        case XR_HEADSET_FIT_STATUS_NOT_WORN_ML:
            return true;
        case XR_HEADSET_FIT_STATUS_GOOD_FIT_ML:
            return true;
        case XR_HEADSET_FIT_STATUS_BAD_FIT_ML:
            return true;
    default:
        return false;
}
}

// Function to validate XrEyeCalibrationStatusML enum
bool ValidateXrEnum(GenValidUsageXrInstanceInfo *instance_info,
                    const std::string &command_name,
                    const std::string &validation_name,
                    const std::string &item_name,
                    std::vector<GenValidUsageXrObjectInfo>& objects_info,
                    const XrEyeCalibrationStatusML value) {
    (void)instance_info;  // quiet warnings
    (void)command_name;  // quiet warnings
    (void)validation_name;  // quiet warnings
    (void)item_name;  // quiet warnings
    (void)objects_info;  // quiet warnings
    // Enum requires extension XR_ML_user_calibration, so check that it is enabled
    if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
        std::string vuid = "VUID-";
        vuid += validation_name;
        vuid += "-";
        vuid += item_name;
        vuid += "-parameter";
        std::string error_str = "XrEyeCalibrationStatusML requires extension ";
        error_str += " \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
        CoreValidLogMessage(instance_info, vuid,
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, error_str);
        return false;
    }
    switch (value) {
        case XR_EYE_CALIBRATION_STATUS_UNKNOWN_ML:
            return true;
        case XR_EYE_CALIBRATION_STATUS_NONE_ML:
            return true;
        case XR_EYE_CALIBRATION_STATUS_COARSE_ML:
            return true;
        case XR_EYE_CALIBRATION_STATUS_FINE_ML:
            return true;
    default:
        return false;
}
}

bool ExtensionEnabled(const std::vector<std::string> &extensions, const char* const check_extension_name) {
    for (const auto& enabled_extension: extensions) {
        if (enabled_extension == check_extension_name) {
            return true;
        }
    }
    return false;
}

bool ValidateInstanceExtensionDependencies(GenValidUsageXrInstanceInfo *gen_instance_info,
                                           const std::string &command,
                                           const std::string &struct_name,
                                           std::vector<GenValidUsageXrObjectInfo>& objects_info,
                                           std::vector<std::string> &extensions) {
    for (uint32_t cur_index = 0; cur_index < extensions.size(); ++cur_index) {
        if (extensions[cur_index] == "XR_KHR_vulkan_swapchain_format_list") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_KHR_vulkan_enable")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_KHR_vulkan_enable\" (required by extension" \
                                            "\"XR_KHR_vulkan_swapchain_format_list\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_hand_tracking_mesh") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_MSFT_hand_tracking_mesh\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_first_person_observer") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_MSFT_secondary_view_configuration")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_MSFT_secondary_view_configuration\" (required by extension" \
                                            "\"XR_MSFT_first_person_observer\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_perception_anchor_interop") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_MSFT_spatial_anchor")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_MSFT_spatial_anchor\" (required by extension" \
                                            "\"XR_MSFT_perception_anchor_interop\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_EXT_dpad_binding") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_KHR_binding_modification")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_KHR_binding_modification\" (required by extension" \
                                            "\"XR_EXT_dpad_binding\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_EXT_hand_joints_motion_range") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_EXT_hand_joints_motion_range\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_scene_understanding_serialization") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_MSFT_scene_understanding")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_MSFT_scene_understanding\" (required by extension" \
                                            "\"XR_MSFT_scene_understanding_serialization\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_hand_tracking_mesh") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_FB_hand_tracking_mesh\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_hand_tracking_aim") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_FB_hand_tracking_aim\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_hand_tracking_capsules") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_FB_hand_tracking_capsules\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_foveation") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_swapchain_update_state")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_swapchain_update_state\" (required by extension" \
                                            "\"XR_FB_foveation\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_foveation_configuration") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_foveation")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_foveation\" (required by extension" \
                                            "\"XR_FB_foveation_configuration\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_VARJO_foveated_rendering") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_VARJO_quad_views")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_VARJO_quad_views\" (required by extension" \
                                            "\"XR_VARJO_foveated_rendering\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_VARJO_composition_layer_depth_test") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_KHR_composition_layer_depth")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_KHR_composition_layer_depth\" (required by extension" \
                                            "\"XR_VARJO_composition_layer_depth_test\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_ML_localization_map") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_uuid")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_uuid\" (required by extension" \
                                            "\"XR_ML_localization_map\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_spatial_anchor_persistence") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_MSFT_spatial_anchor")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_MSFT_spatial_anchor\" (required by extension" \
                                            "\"XR_MSFT_spatial_anchor_persistence\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MSFT_scene_marker") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_MSFT_scene_understanding")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_MSFT_scene_understanding\" (required by extension" \
                                            "\"XR_MSFT_scene_marker\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_ULTRALEAP_hand_tracking_forearm") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_ULTRALEAP_hand_tracking_forearm\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_spatial_entity_query") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity_storage")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity_storage\" (required by extension" \
                                            "\"XR_FB_spatial_entity_query\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_spatial_entity_storage") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity\" (required by extension" \
                                            "\"XR_FB_spatial_entity_storage\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_foveation_vulkan") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_foveation")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_foveation\" (required by extension" \
                                            "\"XR_FB_foveation_vulkan\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_swapchain_update_state_opengl_es") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_KHR_opengl_es_enable")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_KHR_opengl_es_enable\" (required by extension" \
                                            "\"XR_FB_swapchain_update_state_opengl_es\") from enabled extension list");
                    }
                    return false;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_swapchain_update_state")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_swapchain_update_state\" (required by extension" \
                                            "\"XR_FB_swapchain_update_state_opengl_es\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_swapchain_update_state_vulkan") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_KHR_vulkan_enable")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_KHR_vulkan_enable\" (required by extension" \
                                            "\"XR_FB_swapchain_update_state_vulkan\") from enabled extension list");
                    }
                    return false;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_swapchain_update_state")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_swapchain_update_state\" (required by extension" \
                                            "\"XR_FB_swapchain_update_state_vulkan\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_spatial_entity_sharing") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity\" (required by extension" \
                                            "\"XR_FB_spatial_entity_sharing\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_scene") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity\" (required by extension" \
                                            "\"XR_FB_scene\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_spatial_entity_container") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity\" (required by extension" \
                                            "\"XR_FB_spatial_entity_container\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_META_foveation_eye_tracked") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_foveation")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_foveation\" (required by extension" \
                                            "\"XR_META_foveation_eye_tracked\") from enabled extension list");
                    }
                    return false;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_foveation_configuration")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_foveation_configuration\" (required by extension" \
                                            "\"XR_META_foveation_eye_tracked\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_passthrough_keyboard_hands") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_passthrough")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_passthrough\" (required by extension" \
                                            "\"XR_FB_passthrough_keyboard_hands\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_FB_spatial_entity_storage_batch") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity_storage")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity_storage\" (required by extension" \
                                            "\"XR_FB_spatial_entity_storage_batch\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_META_passthrough_color_lut") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_passthrough")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_passthrough\" (required by extension" \
                                            "\"XR_META_passthrough_color_lut\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_META_spatial_entity_mesh") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_spatial_entity")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_spatial_entity\" (required by extension" \
                                            "\"XR_META_spatial_entity_mesh\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_META_automatic_layer_filter") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_FB_composition_layer_settings")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_FB_composition_layer_settings\" (required by extension" \
                                            "\"XR_META_automatic_layer_filter\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_MNDX_force_feedback_curl") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_MNDX_force_feedback_curl\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
        if (extensions[cur_index] == "XR_EXT_hand_tracking_data_source") {
            for (uint32_t check_index = 0; check_index < extensions.size(); ++check_index) {
                if (cur_index == check_index) {
                    continue;
                }
                if (!ExtensionEnabled(extensions, "XR_EXT_hand_tracking")) {
                    if (nullptr != gen_instance_info) {
                        std::string vuid = "VUID-";
                        vuid += command;
                        vuid += "-";
                        vuid += struct_name;
                        vuid += "-parameter";
                        CoreValidLogMessage(gen_instance_info, vuid, VALID_USAGE_DEBUG_SEVERITY_ERROR,
                                            command, objects_info,
                                            "Missing extension dependency \"XR_EXT_hand_tracking\" (required by extension" \
                                            "\"XR_EXT_hand_tracking_data_source\") from enabled extension list");
                    }
                    return false;
                }
            }
        }
    }
    return true;
}

bool ValidateSystemExtensionDependencies(GenValidUsageXrInstanceInfo *gen_instance_info,
                                         const std::string &command,
                                         const std::string &struct_name,
                                         std::vector<GenValidUsageXrObjectInfo>& objects_info,
                                         std::vector<std::string> &extensions) {
    // No system extensions to check dependencies for
    (void)gen_instance_info;
    (void)command;
    (void)struct_name;
    (void)objects_info;
    (void)extensions;
    return true;
}

ValidateXrHandleResult VerifyXrInstanceHandle(const XrInstance* handle_to_check) {
    return g_instance_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSessionHandle(const XrSession* handle_to_check) {
    return g_session_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSpaceHandle(const XrSpace* handle_to_check) {
    return g_space_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrActionHandle(const XrAction* handle_to_check) {
    return g_action_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSwapchainHandle(const XrSwapchain* handle_to_check) {
    return g_swapchain_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrActionSetHandle(const XrActionSet* handle_to_check) {
    return g_actionset_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrDebugUtilsMessengerEXTHandle(const XrDebugUtilsMessengerEXT* handle_to_check) {
    return g_debugutilsmessengerext_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSpatialAnchorMSFTHandle(const XrSpatialAnchorMSFT* handle_to_check) {
    return g_spatialanchormsft_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSpatialGraphNodeBindingMSFTHandle(const XrSpatialGraphNodeBindingMSFT* handle_to_check) {
    return g_spatialgraphnodebindingmsft_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrHandTrackerEXTHandle(const XrHandTrackerEXT* handle_to_check) {
    return g_handtrackerext_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrBodyTrackerFBHandle(const XrBodyTrackerFB* handle_to_check) {
    return g_bodytrackerfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSceneObserverMSFTHandle(const XrSceneObserverMSFT* handle_to_check) {
    return g_sceneobservermsft_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSceneMSFTHandle(const XrSceneMSFT* handle_to_check) {
    return g_scenemsft_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrFacialTrackerHTCHandle(const XrFacialTrackerHTC* handle_to_check) {
    return g_facialtrackerhtc_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrFoveationProfileFBHandle(const XrFoveationProfileFB* handle_to_check) {
    return g_foveationprofilefb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrTriangleMeshFBHandle(const XrTriangleMeshFB* handle_to_check) {
    return g_trianglemeshfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrPassthroughFBHandle(const XrPassthroughFB* handle_to_check) {
    return g_passthroughfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrPassthroughLayerFBHandle(const XrPassthroughLayerFB* handle_to_check) {
    return g_passthroughlayerfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrGeometryInstanceFBHandle(const XrGeometryInstanceFB* handle_to_check) {
    return g_geometryinstancefb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrMarkerDetectorMLHandle(const XrMarkerDetectorML* handle_to_check) {
    return g_markerdetectorml_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrExportedLocalizationMapMLHandle(const XrExportedLocalizationMapML* handle_to_check) {
    return g_exportedlocalizationmapml_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSpatialAnchorStoreConnectionMSFTHandle(const XrSpatialAnchorStoreConnectionMSFT* handle_to_check) {
    return g_spatialanchorstoreconnectionmsft_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrSpaceUserFBHandle(const XrSpaceUserFB* handle_to_check) {
    return g_spaceuserfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrFaceTrackerFBHandle(const XrFaceTrackerFB* handle_to_check) {
    return g_facetrackerfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrEyeTrackerFBHandle(const XrEyeTrackerFB* handle_to_check) {
    return g_eyetrackerfb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrVirtualKeyboardMETAHandle(const XrVirtualKeyboardMETA* handle_to_check) {
    return g_virtualkeyboardmeta_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrPassthroughColorLutMETAHandle(const XrPassthroughColorLutMETA* handle_to_check) {
    return g_passthroughcolorlutmeta_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrFaceTracker2FBHandle(const XrFaceTracker2FB* handle_to_check) {
    return g_facetracker2fb_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrPassthroughHTCHandle(const XrPassthroughHTC* handle_to_check) {
    return g_passthroughhtc_info.verifyHandle(handle_to_check);
}

ValidateXrHandleResult VerifyXrPlaneDetectorEXTHandle(const XrPlaneDetectorEXT* handle_to_check) {
    return g_planedetectorext_info.verifyHandle(handle_to_check);
}

// Implementation function to get parent handle information
bool GetXrParent(const XrObjectType inhandle_type, const uint64_t inhandle,
                 XrObjectType& outhandle_type, uint64_t& outhandle) {
    if (inhandle_type == XR_OBJECT_TYPE_INSTANCE) {
        return false;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SESSION) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_session_info.get(TreatIntegerAsHandle<XrSession>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SPACE) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_space_info.get(TreatIntegerAsHandle<XrSpace>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_ACTION) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_action_info.get(TreatIntegerAsHandle<XrAction>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SWAPCHAIN) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_swapchain_info.get(TreatIntegerAsHandle<XrSwapchain>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_ACTION_SET) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_actionset_info.get(TreatIntegerAsHandle<XrActionSet>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_debugutilsmessengerext_info.get(TreatIntegerAsHandle<XrDebugUtilsMessengerEXT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_spatialanchormsft_info.get(TreatIntegerAsHandle<XrSpatialAnchorMSFT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_spatialgraphnodebindingmsft_info.get(TreatIntegerAsHandle<XrSpatialGraphNodeBindingMSFT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_HAND_TRACKER_EXT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_handtrackerext_info.get(TreatIntegerAsHandle<XrHandTrackerEXT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_BODY_TRACKER_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_bodytrackerfb_info.get(TreatIntegerAsHandle<XrBodyTrackerFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_sceneobservermsft_info.get(TreatIntegerAsHandle<XrSceneObserverMSFT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SCENE_MSFT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_scenemsft_info.get(TreatIntegerAsHandle<XrSceneMSFT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_FACIAL_TRACKER_HTC) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_facialtrackerhtc_info.get(TreatIntegerAsHandle<XrFacialTrackerHTC>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_FOVEATION_PROFILE_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_foveationprofilefb_info.get(TreatIntegerAsHandle<XrFoveationProfileFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_TRIANGLE_MESH_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_trianglemeshfb_info.get(TreatIntegerAsHandle<XrTriangleMeshFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_PASSTHROUGH_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_passthroughfb_info.get(TreatIntegerAsHandle<XrPassthroughFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_passthroughlayerfb_info.get(TreatIntegerAsHandle<XrPassthroughLayerFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_geometryinstancefb_info.get(TreatIntegerAsHandle<XrGeometryInstanceFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_MARKER_DETECTOR_ML) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_markerdetectorml_info.get(TreatIntegerAsHandle<XrMarkerDetectorML>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_exportedlocalizationmapml_info.get(TreatIntegerAsHandle<XrExportedLocalizationMapML>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_spatialanchorstoreconnectionmsft_info.get(TreatIntegerAsHandle<XrSpatialAnchorStoreConnectionMSFT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_SPACE_USER_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_spaceuserfb_info.get(TreatIntegerAsHandle<XrSpaceUserFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_FACE_TRACKER_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_facetrackerfb_info.get(TreatIntegerAsHandle<XrFaceTrackerFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_EYE_TRACKER_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_eyetrackerfb_info.get(TreatIntegerAsHandle<XrEyeTrackerFB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_virtualkeyboardmeta_info.get(TreatIntegerAsHandle<XrVirtualKeyboardMETA>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_passthroughcolorlutmeta_info.get(TreatIntegerAsHandle<XrPassthroughColorLutMETA>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_FACE_TRACKER2_FB) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_facetracker2fb_info.get(TreatIntegerAsHandle<XrFaceTracker2FB>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_PASSTHROUGH_HTC) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_passthroughhtc_info.get(TreatIntegerAsHandle<XrPassthroughHTC>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    if (inhandle_type == XR_OBJECT_TYPE_PLANE_DETECTOR_EXT) {
        // Get the object and parent of the handle
        GenValidUsageXrHandleInfo *handle_info = g_planedetectorext_info.get(TreatIntegerAsHandle<XrPlaneDetectorEXT>(inhandle));
        outhandle_type = handle_info->direct_parent_type;
        outhandle = handle_info->direct_parent_handle;
        return true;
    }
    return false;
}

// Implementation of VerifyXrParent function
bool VerifyXrParent(XrObjectType handle1_type, const uint64_t handle1,
                    XrObjectType handle2_type, const uint64_t handle2,
                    bool check_this) {
    if (IsIntegerNullHandle(handle1) || IsIntegerNullHandle(handle2)) {
        return false;
    } else if (check_this && handle1_type == handle2_type) {
        return (handle1 == handle2);
    }
    if (handle1_type == XR_OBJECT_TYPE_INSTANCE && handle2_type != XR_OBJECT_TYPE_INSTANCE) {
        XrObjectType parent_type;
        uint64_t parent_handle;
        if (!GetXrParent(handle2_type, handle2, parent_type, parent_handle)) {
            return false;
        }
        return VerifyXrParent(handle1_type, handle1, parent_type, parent_handle, true);
    } else if (handle2_type == XR_OBJECT_TYPE_INSTANCE && handle1_type != XR_OBJECT_TYPE_INSTANCE) {
        XrObjectType parent_type;
        uint64_t parent_handle;
        if (!GetXrParent(handle1_type, handle1, parent_type, parent_handle)) {
            return false;
        }
        return VerifyXrParent(parent_type, parent_handle, handle2_type, handle2, true);
    } else {
        XrObjectType parent1_type;
        uint64_t parent1_handle;
                XrObjectType parent2_type;
        uint64_t parent2_handle;
        if (!GetXrParent(handle1_type, handle1, parent1_type, parent1_handle)) {
            return false;
        }
        if (!GetXrParent(handle2_type, handle2, parent2_type, parent2_handle)) {
            return false;
        }
        if (parent1_type == handle2_type) {
            return (parent1_handle == handle2);
        } else if (handle1_type == parent2_type) {
            return (handle1 == parent2_handle);
        } else {
            return VerifyXrParent(parent1_type, parent1_handle, parent2_type, parent2_handle, true);
        }
    }
    return false;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrApiLayerProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_API_LAYER_PROPERTIES) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrApiLayerProperties",
                             value->type, "VUID-XrApiLayerProperties-type-type", XR_TYPE_API_LAYER_PROPERTIES, "XR_TYPE_API_LAYER_PROPERTIES");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrApiLayerProperties-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrApiLayerProperties struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrApiLayerProperties : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrApiLayerProperties-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrApiLayerProperties struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_API_LAYER_NAME_SIZE < std::strlen(value->layerName)) {
        CoreValidLogMessage(instance_info, "VUID-XrApiLayerProperties-layerName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrApiLayerProperties member layerName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (XR_MAX_API_LAYER_DESCRIPTION_SIZE < std::strlen(value->description)) {
        CoreValidLogMessage(instance_info, "VUID-XrApiLayerProperties-description-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrApiLayerProperties member description length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtensionProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EXTENSION_PROPERTIES) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrExtensionProperties",
                             value->type, "VUID-XrExtensionProperties-type-type", XR_TYPE_EXTENSION_PROPERTIES, "XR_TYPE_EXTENSION_PROPERTIES");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrExtensionProperties-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrExtensionProperties struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrExtensionProperties : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrExtensionProperties-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrExtensionProperties struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_EXTENSION_NAME_SIZE < std::strlen(value->extensionName)) {
        CoreValidLogMessage(instance_info, "VUID-XrExtensionProperties-extensionName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrExtensionProperties member extensionName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrApplicationInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_APPLICATION_NAME_SIZE < std::strlen(value->applicationName)) {
        CoreValidLogMessage(instance_info, "VUID-XrApplicationInfo-applicationName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrApplicationInfo member applicationName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (XR_MAX_ENGINE_NAME_SIZE < std::strlen(value->engineName)) {
        CoreValidLogMessage(instance_info, "VUID-XrApplicationInfo-engineName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrApplicationInfo member engineName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INSTANCE_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInstanceCreateInfo",
                             value->type, "VUID-XrInstanceCreateInfo-type-type", XR_TYPE_INSTANCE_CREATE_INFO, "XR_TYPE_INSTANCE_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT);
    valid_ext_structs.push_back(XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInstanceCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInstanceCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInstanceCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult instance_create_flags_result = ValidateXrInstanceCreateFlags(value->createFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == instance_create_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrInstanceCreateInfo invalid member XrInstanceCreateFlags \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrApplicationInfo is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->applicationInfo);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-applicationInfo-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrInstanceCreateInfo member applicationInfo is invalid");
        return xr_result;
    }
    // Optional array must be non-NULL when value->enabledApiLayerCount is non-zero
    if (0 != value->enabledApiLayerCount && nullptr == value->enabledApiLayerNames) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-enabledApiLayerNames-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrInstanceCreateInfo member enabledApiLayerCount is NULL, but value->enabledApiLayerCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->enabledApiLayerNames && 0 != value->enabledApiLayerCount) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-enabledApiLayerNames-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrInstanceCreateInfo contains invalid NULL for char \"enabledApiLayerNames\" is which not "
                            "optional since \"enabledApiLayerCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrInstanceCreateInfo-enabledApiLayerNames-parameter" null-termination
    // Optional array must be non-NULL when value->enabledExtensionCount is non-zero
    if (0 != value->enabledExtensionCount && nullptr == value->enabledExtensionNames) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-enabledExtensionNames-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrInstanceCreateInfo member enabledExtensionCount is NULL, but value->enabledExtensionCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->enabledExtensionNames && 0 != value->enabledExtensionCount) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfo-enabledExtensionNames-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrInstanceCreateInfo contains invalid NULL for char \"enabledExtensionNames\" is which not "
                            "optional since \"enabledExtensionCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrInstanceCreateInfo-enabledExtensionNames-parameter" null-termination
    std::vector<std::string> enabled_extension_vec;
    for (uint32_t extension = 0; extension < value->enabledExtensionCount; ++extension) {
        enabled_extension_vec.push_back(value->enabledExtensionNames[extension]);
    }
    if (!ValidateInstanceExtensionDependencies(nullptr, command_name, "XrInstanceCreateInfo",
                                               objects_info, enabled_extension_vec)) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INSTANCE_PROPERTIES) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInstanceProperties",
                             value->type, "VUID-XrInstanceProperties-type-type", XR_TYPE_INSTANCE_PROPERTIES, "XR_TYPE_INSTANCE_PROPERTIES");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceProperties-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInstanceProperties struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInstanceProperties : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInstanceProperties-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInstanceProperties struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_RUNTIME_NAME_SIZE < std::strlen(value->runtimeName)) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceProperties-runtimeName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrInstanceProperties member runtimeName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataBuffer* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_BUFFER) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataBuffer",
                             value->type, "VUID-XrEventDataBuffer-type-type", XR_TYPE_EVENT_DATA_BUFFER, "XR_TYPE_EVENT_DATA_BUFFER");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataBuffer-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataBuffer struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataBuffer : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataBuffer-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataBuffer struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemGetInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_GET_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemGetInfo",
                             value->type, "VUID-XrSystemGetInfo-type-type", XR_TYPE_SYSTEM_GET_INFO, "XR_TYPE_SYSTEM_GET_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemGetInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemGetInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemGetInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemGetInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemGetInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFormFactor value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSystemGetInfo", "formFactor", objects_info, value->formFactor)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSystemGetInfo contains invalid XrFormFactor \"formFactor\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->formFactor));
        CoreValidLogMessage(instance_info, "VUID-XrSystemGetInfo-formFactor-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemGraphicsProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemTrackingProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_PROPERTIES) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemProperties",
                             value->type, "VUID-XrSystemProperties-type-type", XR_TYPE_SYSTEM_PROPERTIES, "XR_TYPE_SYSTEM_PROPERTIES");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT);
    valid_ext_structs.push_back(XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemProperties-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemProperties struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemProperties : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemProperties-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemProperties struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_SYSTEM_NAME_SIZE < std::strlen(value->systemName)) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemProperties-systemName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSystemProperties member systemName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSystemTrackingProperties is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->trackingProperties);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemProperties-trackingProperties-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSystemProperties member trackingProperties is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SESSION_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSessionCreateInfo",
                             value->type, "VUID-XrSessionCreateInfo-type-type", XR_TYPE_SESSION_CREATE_INFO, "XR_TYPE_SESSION_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_D3D11_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_D3D12_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_EGL_MNDX);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR);
    valid_ext_structs.push_back(XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR);
    valid_ext_structs.push_back(XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSessionCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSessionCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSessionCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult session_create_flags_result = ValidateXrSessionCreateFlags(value->createFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == session_create_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSessionCreateInfo invalid member XrSessionCreateFlags \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfo-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector3f* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceVelocity* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_VELOCITY) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceVelocity",
                             value->type, "VUID-XrSpaceVelocity-type-type", XR_TYPE_SPACE_VELOCITY, "XR_TYPE_SPACE_VELOCITY");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceVelocity-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceVelocity struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceVelocity : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceVelocity-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceVelocity struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_velocity_flags_result = ValidateXrSpaceVelocityFlags(value->velocityFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == space_velocity_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceVelocity invalid member XrSpaceVelocityFlags \"velocityFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->velocityFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSpaceVelocity-velocityFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrQuaternionf* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPosef* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrReferenceSpaceCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_REFERENCE_SPACE_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrReferenceSpaceCreateInfo",
                             value->type, "VUID-XrReferenceSpaceCreateInfo-type-type", XR_TYPE_REFERENCE_SPACE_CREATE_INFO, "XR_TYPE_REFERENCE_SPACE_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrReferenceSpaceCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrReferenceSpaceCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrReferenceSpaceCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrReferenceSpaceCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrReferenceSpaceCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrReferenceSpaceType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrReferenceSpaceCreateInfo", "referenceSpaceType", objects_info, value->referenceSpaceType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrReferenceSpaceCreateInfo contains invalid XrReferenceSpaceType \"referenceSpaceType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->referenceSpaceType));
        CoreValidLogMessage(instance_info, "VUID-XrReferenceSpaceCreateInfo-referenceSpaceType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent2Df* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSpaceCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_SPACE_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionSpaceCreateInfo",
                             value->type, "VUID-XrActionSpaceCreateInfo-type-type", XR_TYPE_ACTION_SPACE_CREATE_INFO, "XR_TYPE_ACTION_SPACE_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionSpaceCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionSpaceCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionSpaceCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionSpaceCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionSpaceCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrActionSpaceCreateInfo-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceLocation* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_LOCATION) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceLocation",
                             value->type, "VUID-XrSpaceLocation-type-type", XR_TYPE_SPACE_LOCATION, "XR_TYPE_SPACE_LOCATION");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT);
    valid_ext_structs.push_back(XR_TYPE_SPACE_VELOCITY);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceLocation-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceLocation struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceLocation : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceLocation-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceLocation struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_location_flags_result = ValidateXrSpaceLocationFlags(value->locationFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == space_location_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceLocation invalid member XrSpaceLocationFlags \"locationFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSpaceLocation-locationFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationProperties* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_CONFIGURATION_PROPERTIES) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewConfigurationProperties",
                             value->type, "VUID-XrViewConfigurationProperties-type-type", XR_TYPE_VIEW_CONFIGURATION_PROPERTIES, "XR_TYPE_VIEW_CONFIGURATION_PROPERTIES");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationProperties-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewConfigurationProperties struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewConfigurationProperties : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationProperties-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewConfigurationProperties struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrViewConfigurationProperties", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrViewConfigurationProperties contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationProperties-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationView* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_CONFIGURATION_VIEW) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewConfigurationView",
                             value->type, "VUID-XrViewConfigurationView-type-type", XR_TYPE_VIEW_CONFIGURATION_VIEW, "XR_TYPE_VIEW_CONFIGURATION_VIEW");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO);
    valid_ext_structs.push_back(XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT);
    valid_ext_structs.push_back(XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationView-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewConfigurationView struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewConfigurationView : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationView-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewConfigurationView struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainCreateInfo",
                             value->type, "VUID-XrSwapchainCreateInfo-type-type", XR_TYPE_SWAPCHAIN_CREATE_INFO, "XR_TYPE_SWAPCHAIN_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB);
    valid_ext_structs.push_back(XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB);
    valid_ext_structs.push_back(XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult swapchain_create_flags_result = ValidateXrSwapchainCreateFlags(value->createFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == swapchain_create_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSwapchainCreateInfo invalid member XrSwapchainCreateFlags \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfo-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    ValidateXrFlagsResult swapchain_usage_flags_result = ValidateXrSwapchainUsageFlags(value->usageFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == swapchain_usage_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSwapchainCreateInfo invalid member XrSwapchainUsageFlags \"usageFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->usageFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfo-usageFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageBaseHeader* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrSwapchainImageBaseHeader-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrSwapchainImageBaseHeader-next-next" because it is a base structure
#if defined(XR_USE_GRAPHICS_API_OPENGL)
    if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR) {
        const XrSwapchainImageOpenGLKHR* new_value = reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_enable")) {
            std::string error_str = "XrSwapchainImageBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR\"";
            error_str += " which requires extension \"XR_KHR_opengl_enable\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
    if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR) {
        const XrSwapchainImageOpenGLESKHR* new_value = reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_opengl_es_enable")) {
            std::string error_str = "XrSwapchainImageBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR\"";
            error_str += " which requires extension \"XR_KHR_opengl_es_enable\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
    if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR) {
        const XrSwapchainImageVulkanKHR* new_value = reinterpret_cast<const XrSwapchainImageVulkanKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_vulkan_enable")) {
            std::string error_str = "XrSwapchainImageBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR\"";
            error_str += " which requires extension \"XR_KHR_vulkan_enable\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
    if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR) {
        const XrSwapchainImageD3D11KHR* new_value = reinterpret_cast<const XrSwapchainImageD3D11KHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D11_enable")) {
            std::string error_str = "XrSwapchainImageBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR\"";
            error_str += " which requires extension \"XR_KHR_D3D11_enable\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
    if (value->type == XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR) {
        const XrSwapchainImageD3D12KHR* new_value = reinterpret_cast<const XrSwapchainImageD3D12KHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_D3D12_enable")) {
            std::string error_str = "XrSwapchainImageBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR\"";
            error_str += " which requires extension \"XR_KHR_D3D12_enable\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
    InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageBaseHeader",
                         value->type, "VUID-XrSwapchainImageBaseHeader-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageAcquireInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageAcquireInfo",
                             value->type, "VUID-XrSwapchainImageAcquireInfo-type-type", XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO, "XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageAcquireInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageAcquireInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageAcquireInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageAcquireInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageAcquireInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageWaitInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageWaitInfo",
                             value->type, "VUID-XrSwapchainImageWaitInfo-type-type", XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO, "XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageWaitInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageWaitInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageWaitInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageWaitInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageWaitInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageReleaseInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageReleaseInfo",
                             value->type, "VUID-XrSwapchainImageReleaseInfo-type-type", XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO, "XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageReleaseInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageReleaseInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageReleaseInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageReleaseInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageReleaseInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionBeginInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SESSION_BEGIN_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSessionBeginInfo",
                             value->type, "VUID-XrSessionBeginInfo-type-type", XR_TYPE_SESSION_BEGIN_INFO, "XR_TYPE_SESSION_BEGIN_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionBeginInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSessionBeginInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSessionBeginInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSessionBeginInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSessionBeginInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSessionBeginInfo", "primaryViewConfigurationType", objects_info, value->primaryViewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSessionBeginInfo contains invalid XrViewConfigurationType \"primaryViewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->primaryViewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrSessionBeginInfo-primaryViewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameWaitInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FRAME_WAIT_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFrameWaitInfo",
                             value->type, "VUID-XrFrameWaitInfo-type-type", XR_TYPE_FRAME_WAIT_INFO, "XR_TYPE_FRAME_WAIT_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameWaitInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFrameWaitInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFrameWaitInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFrameWaitInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFrameWaitInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameState* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FRAME_STATE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFrameState",
                             value->type, "VUID-XrFrameState-type-type", XR_TYPE_FRAME_STATE, "XR_TYPE_FRAME_STATE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameState-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFrameState struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFrameState : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFrameState-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFrameState struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameBeginInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FRAME_BEGIN_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFrameBeginInfo",
                             value->type, "VUID-XrFrameBeginInfo-type-type", XR_TYPE_FRAME_BEGIN_INFO, "XR_TYPE_FRAME_BEGIN_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameBeginInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFrameBeginInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFrameBeginInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFrameBeginInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFrameBeginInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerBaseHeader* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrCompositionLayerBaseHeader-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrCompositionLayerBaseHeader-next-next" because it is a base structure
    // NOTE: Can't validate "VUID-XrCompositionLayerBaseHeader-layerFlags-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrCompositionLayerBaseHeader-space-parameter" because it is a base structure
    if (value->type == XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
        const XrCompositionLayerProjection* new_value = reinterpret_cast<const XrCompositionLayerProjection*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_QUAD) {
        const XrCompositionLayerQuad* new_value = reinterpret_cast<const XrCompositionLayerQuad*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
        const XrCompositionLayerCubeKHR* new_value = reinterpret_cast<const XrCompositionLayerCubeKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_cube")) {
            std::string error_str = "XrCompositionLayerBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_COMPOSITION_LAYER_CUBE_KHR\"";
            error_str += " which requires extension \"XR_KHR_composition_layer_cube\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
        const XrCompositionLayerCylinderKHR* new_value = reinterpret_cast<const XrCompositionLayerCylinderKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_cylinder")) {
            std::string error_str = "XrCompositionLayerBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR\"";
            error_str += " which requires extension \"XR_KHR_composition_layer_cylinder\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
        const XrCompositionLayerEquirectKHR* new_value = reinterpret_cast<const XrCompositionLayerEquirectKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_equirect")) {
            std::string error_str = "XrCompositionLayerBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR\"";
            error_str += " which requires extension \"XR_KHR_composition_layer_equirect\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
        const XrCompositionLayerEquirect2KHR* new_value = reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_composition_layer_equirect2")) {
            std::string error_str = "XrCompositionLayerBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR\"";
            error_str += " which requires extension \"XR_KHR_composition_layer_equirect2\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
        const XrCompositionLayerPassthroughHTC* new_value = reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTC_passthrough")) {
            std::string error_str = "XrCompositionLayerBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC\"";
            error_str += " which requires extension \"XR_HTC_passthrough\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerBaseHeader",
                         value->type, "VUID-XrCompositionLayerBaseHeader-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameEndInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FRAME_END_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFrameEndInfo",
                             value->type, "VUID-XrFrameEndInfo-type-type", XR_TYPE_FRAME_END_INFO, "XR_TYPE_FRAME_END_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_FRAME_END_INFO_ML);
    valid_ext_structs.push_back(XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML);
    valid_ext_structs.push_back(XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META);
    valid_ext_structs.push_back(XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFrameEndInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFrameEndInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFrameEndInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrEnvironmentBlendMode value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFrameEndInfo", "environmentBlendMode", objects_info, value->environmentBlendMode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFrameEndInfo contains invalid XrEnvironmentBlendMode \"environmentBlendMode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->environmentBlendMode));
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-environmentBlendMode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Optional array must be non-NULL when value->layerCount is non-zero
    if (0 != value->layerCount && nullptr == value->layers) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFrameEndInfo member layerCount is NULL, but value->layerCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->layers) {
        for (uint32_t value_layers_inc = 0; value_layers_inc < value->layerCount; ++value_layers_inc) {
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerProjection and it is valid
            {
                const XrCompositionLayerProjection* const* new_compositionlayerprojection_value = reinterpret_cast<const XrCompositionLayerProjection* const*>(value->layers);
                if (new_compositionlayerprojection_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
                    if (nullptr != new_compositionlayerprojection_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayerprojection_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerQuad and it is valid
            {
                const XrCompositionLayerQuad* const* new_compositionlayerquad_value = reinterpret_cast<const XrCompositionLayerQuad* const*>(value->layers);
                if (new_compositionlayerquad_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_QUAD) {
                    if (nullptr != new_compositionlayerquad_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayerquad_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCubeKHR and it is valid
            {
                const XrCompositionLayerCubeKHR* const* new_compositionlayercubekhr_value = reinterpret_cast<const XrCompositionLayerCubeKHR* const*>(value->layers);
                if (new_compositionlayercubekhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
                    if (nullptr != new_compositionlayercubekhr_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayercubekhr_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCylinderKHR and it is valid
            {
                const XrCompositionLayerCylinderKHR* const* new_compositionlayercylinderkhr_value = reinterpret_cast<const XrCompositionLayerCylinderKHR* const*>(value->layers);
                if (new_compositionlayercylinderkhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
                    if (nullptr != new_compositionlayercylinderkhr_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayercylinderkhr_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirectKHR and it is valid
            {
                const XrCompositionLayerEquirectKHR* const* new_compositionlayerequirectkhr_value = reinterpret_cast<const XrCompositionLayerEquirectKHR* const*>(value->layers);
                if (new_compositionlayerequirectkhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
                    if (nullptr != new_compositionlayerequirectkhr_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayerequirectkhr_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirect2KHR and it is valid
            {
                const XrCompositionLayerEquirect2KHR* const* new_compositionlayerequirect2khr_value = reinterpret_cast<const XrCompositionLayerEquirect2KHR* const*>(value->layers);
                if (new_compositionlayerequirect2khr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
                    if (nullptr != new_compositionlayerequirect2khr_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayerequirect2khr_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerPassthroughHTC and it is valid
            {
                const XrCompositionLayerPassthroughHTC* const* new_compositionlayerpassthroughhtc_value = reinterpret_cast<const XrCompositionLayerPassthroughHTC* const*>(value->layers);
                if (new_compositionlayerpassthroughhtc_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
                    if (nullptr != new_compositionlayerpassthroughhtc_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_compositionlayerpassthroughhtc_value[value_layers_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrFrameEndInfo member layers";
                            error_message += "[";
                            error_message += std::to_string(value_layers_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate that the base-structure XrCompositionLayerBaseHeader is valid
            if (nullptr != value->layers[value_layers_inc]) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, value->layers[value_layers_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfo-layers-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        "Structure XrFrameEndInfo member layers is invalid");
                    return xr_result;
                }
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewLocateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_LOCATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewLocateInfo",
                             value->type, "VUID-XrViewLocateInfo-type-type", XR_TYPE_VIEW_LOCATE_INFO, "XR_TYPE_VIEW_LOCATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewLocateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewLocateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewLocateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewLocateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewLocateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrViewLocateInfo", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrViewLocateInfo contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrViewLocateInfo-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrViewLocateInfo-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewState* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_STATE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewState",
                             value->type, "VUID-XrViewState-type-type", XR_TYPE_VIEW_STATE, "XR_TYPE_VIEW_STATE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewState-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewState struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewState : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewState-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewState struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult view_state_flags_result = ValidateXrViewStateFlags(value->viewStateFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == view_state_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrViewState invalid member XrViewStateFlags \"viewStateFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewStateFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrViewState-viewStateFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFovf* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrView* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrView",
                             value->type, "VUID-XrView-type-type", XR_TYPE_VIEW, "XR_TYPE_VIEW");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrView-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrView struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrView : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrView-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrView struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSetCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_SET_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionSetCreateInfo",
                             value->type, "VUID-XrActionSetCreateInfo-type-type", XR_TYPE_ACTION_SET_CREATE_INFO, "XR_TYPE_ACTION_SET_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionSetCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionSetCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionSetCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionSetCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionSetCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_ACTION_SET_NAME_SIZE < std::strlen(value->actionSetName)) {
        CoreValidLogMessage(instance_info, "VUID-XrActionSetCreateInfo-actionSetName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionSetCreateInfo member actionSetName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE < std::strlen(value->localizedActionSetName)) {
        CoreValidLogMessage(instance_info, "VUID-XrActionSetCreateInfo-localizedActionSetName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionSetCreateInfo member localizedActionSetName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionCreateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_CREATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionCreateInfo",
                             value->type, "VUID-XrActionCreateInfo-type-type", XR_TYPE_ACTION_CREATE_INFO, "XR_TYPE_ACTION_CREATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionCreateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionCreateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionCreateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_ACTION_NAME_SIZE < std::strlen(value->actionName)) {
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-actionName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionCreateInfo member actionName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrActionType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrActionCreateInfo", "actionType", objects_info, value->actionType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrActionCreateInfo contains invalid XrActionType \"actionType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->actionType));
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-actionType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Optional array must be non-NULL when value->countSubactionPaths is non-zero
    if (0 != value->countSubactionPaths && nullptr == value->subactionPaths) {
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-subactionPaths-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionCreateInfo member countSubactionPaths is NULL, but value->countSubactionPaths is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrActionCreateInfo-subactionPaths-parameter" type
    if (XR_MAX_LOCALIZED_ACTION_NAME_SIZE < std::strlen(value->localizedActionName)) {
        CoreValidLogMessage(instance_info, "VUID-XrActionCreateInfo-localizedActionName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionCreateInfo member localizedActionName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionSuggestedBinding* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrActionSuggestedBinding-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileSuggestedBinding* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInteractionProfileSuggestedBinding",
                             value->type, "VUID-XrInteractionProfileSuggestedBinding-type-type", XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING, "XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_BINDING_MODIFICATIONS_KHR);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileSuggestedBinding-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInteractionProfileSuggestedBinding struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInteractionProfileSuggestedBinding : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileSuggestedBinding-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInteractionProfileSuggestedBinding struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->countSuggestedBindings && nullptr != value->suggestedBindings) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileSuggestedBinding-countSuggestedBindings-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrInteractionProfileSuggestedBinding member countSuggestedBindings is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->suggestedBindings && 0 != value->countSuggestedBindings) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileSuggestedBinding-suggestedBindings-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrInteractionProfileSuggestedBinding contains invalid NULL for XrActionSuggestedBinding \"suggestedBindings\" is which not "
                            "optional since \"countSuggestedBindings\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->suggestedBindings) {
        for (uint32_t value_suggestedbindings_inc = 0; value_suggestedbindings_inc < value->countSuggestedBindings; ++value_suggestedbindings_inc) {
            // Validate that the structure XrActionSuggestedBinding is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->suggestedBindings[value_suggestedbindings_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileSuggestedBinding-suggestedBindings-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrInteractionProfileSuggestedBinding member suggestedBindings is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionActionSetsAttachInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSessionActionSetsAttachInfo",
                             value->type, "VUID-XrSessionActionSetsAttachInfo-type-type", XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO, "XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionActionSetsAttachInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSessionActionSetsAttachInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSessionActionSetsAttachInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSessionActionSetsAttachInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSessionActionSetsAttachInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->countActionSets && nullptr != value->actionSets) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionActionSetsAttachInfo-countActionSets-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSessionActionSetsAttachInfo member countActionSets is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->actionSets && 0 != value->countActionSets) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionActionSetsAttachInfo-actionSets-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSessionActionSetsAttachInfo contains invalid NULL for XrActionSet \"actionSets\" is which not "
                            "optional since \"countActionSets\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->actionSets) {
        for (uint32_t value_actionsets_inc = 0; value_actionsets_inc < value->countActionSets; ++value_actionsets_inc) {
            {
                // writeValidateInlineHandleValidation
                ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&value->actionSets[value_actionsets_inc]);
                if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                    // Not a valid handle or NULL (which is not valid in this case)
                    std::ostringstream oss;
                    oss << "Invalid XrActionSet handle \"actionSets\" ";
                    oss << HandleToHexString(value->actionSets[value_actionsets_inc]);
                    CoreValidLogMessage(instance_info, "VUID-XrSessionActionSetsAttachInfo-actionSets-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info, oss.str());
                    return XR_ERROR_HANDLE_INVALID;
                }
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileState* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INTERACTION_PROFILE_STATE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInteractionProfileState",
                             value->type, "VUID-XrInteractionProfileState-type-type", XR_TYPE_INTERACTION_PROFILE_STATE, "XR_TYPE_INTERACTION_PROFILE_STATE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileState-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInteractionProfileState struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInteractionProfileState : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileState-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInteractionProfileState struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateGetInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_STATE_GET_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionStateGetInfo",
                             value->type, "VUID-XrActionStateGetInfo-type-type", XR_TYPE_ACTION_STATE_GET_INFO, "XR_TYPE_ACTION_STATE_GET_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionStateGetInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionStateGetInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionStateGetInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionStateGetInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionStateGetInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrActionStateGetInfo-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateBoolean* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_STATE_BOOLEAN) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionStateBoolean",
                             value->type, "VUID-XrActionStateBoolean-type-type", XR_TYPE_ACTION_STATE_BOOLEAN, "XR_TYPE_ACTION_STATE_BOOLEAN");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionStateBoolean-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionStateBoolean struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionStateBoolean : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionStateBoolean-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionStateBoolean struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateFloat* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_STATE_FLOAT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionStateFloat",
                             value->type, "VUID-XrActionStateFloat-type-type", XR_TYPE_ACTION_STATE_FLOAT, "XR_TYPE_ACTION_STATE_FLOAT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionStateFloat-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionStateFloat struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionStateFloat : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionStateFloat-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionStateFloat struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector2f* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStateVector2f* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_STATE_VECTOR2F) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionStateVector2f",
                             value->type, "VUID-XrActionStateVector2f-type-type", XR_TYPE_ACTION_STATE_VECTOR2F, "XR_TYPE_ACTION_STATE_VECTOR2F");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionStateVector2f-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionStateVector2f struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionStateVector2f : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionStateVector2f-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionStateVector2f struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionStatePose* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTION_STATE_POSE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionStatePose",
                             value->type, "VUID-XrActionStatePose-type-type", XR_TYPE_ACTION_STATE_POSE, "XR_TYPE_ACTION_STATE_POSE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionStatePose-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionStatePose struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionStatePose : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionStatePose-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionStatePose struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSet* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&value->actionSet);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrActionSet handle \"actionSet\" ";
            oss << HandleToHexString(value->actionSet);
            CoreValidLogMessage(instance_info, "VUID-XrActiveActionSet-actionSet-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActionsSyncInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTIONS_SYNC_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActionsSyncInfo",
                             value->type, "VUID-XrActionsSyncInfo-type-type", XR_TYPE_ACTIONS_SYNC_INFO, "XR_TYPE_ACTIONS_SYNC_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActionsSyncInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActionsSyncInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActionsSyncInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActionsSyncInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActionsSyncInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->countActiveActionSets is non-zero
    if (0 != value->countActiveActionSets && nullptr == value->activeActionSets) {
        CoreValidLogMessage(instance_info, "VUID-XrActionsSyncInfo-activeActionSets-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActionsSyncInfo member countActiveActionSets is NULL, but value->countActiveActionSets is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->activeActionSets) {
        for (uint32_t value_activeactionsets_inc = 0; value_activeactionsets_inc < value->countActiveActionSets; ++value_activeactionsets_inc) {
            // Validate that the structure XrActiveActionSet is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->activeActionSets[value_activeactionsets_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrActionsSyncInfo-activeActionSets-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrActionsSyncInfo member activeActionSets is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBoundSourcesForActionEnumerateInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBoundSourcesForActionEnumerateInfo",
                             value->type, "VUID-XrBoundSourcesForActionEnumerateInfo-type-type", XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO, "XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBoundSourcesForActionEnumerateInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBoundSourcesForActionEnumerateInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBoundSourcesForActionEnumerateInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBoundSourcesForActionEnumerateInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBoundSourcesForActionEnumerateInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrBoundSourcesForActionEnumerateInfo-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInputSourceLocalizedNameGetInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInputSourceLocalizedNameGetInfo",
                             value->type, "VUID-XrInputSourceLocalizedNameGetInfo-type-type", XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO, "XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInputSourceLocalizedNameGetInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInputSourceLocalizedNameGetInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInputSourceLocalizedNameGetInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInputSourceLocalizedNameGetInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInputSourceLocalizedNameGetInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult input_source_localized_name_flags_result = ValidateXrInputSourceLocalizedNameFlags(value->whichComponents);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == input_source_localized_name_flags_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInputSourceLocalizedNameGetInfo-whichComponents-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrInputSourceLocalizedNameFlags \"whichComponents\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != input_source_localized_name_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrInputSourceLocalizedNameGetInfo invalid member XrInputSourceLocalizedNameFlags \"whichComponents\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->whichComponents));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrInputSourceLocalizedNameGetInfo-whichComponents-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticActionInfo* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAPTIC_ACTION_INFO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHapticActionInfo",
                             value->type, "VUID-XrHapticActionInfo-type-type", XR_TYPE_HAPTIC_ACTION_INFO, "XR_TYPE_HAPTIC_ACTION_INFO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticActionInfo-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHapticActionInfo struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHapticActionInfo : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHapticActionInfo-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHapticActionInfo struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrHapticActionInfo-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticBaseHeader* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrHapticBaseHeader-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrHapticBaseHeader-next-next" because it is a base structure
    if (value->type == XR_TYPE_HAPTIC_VIBRATION) {
        const XrHapticVibration* new_value = reinterpret_cast<const XrHapticVibration*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
        const XrHapticAmplitudeEnvelopeVibrationFB* new_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_haptic_amplitude_envelope")) {
            std::string error_str = "XrHapticBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB\"";
            error_str += " which requires extension \"XR_FB_haptic_amplitude_envelope\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrHapticBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
        const XrHapticPcmVibrationFB* new_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_haptic_pcm")) {
            std::string error_str = "XrHapticBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_HAPTIC_PCM_VIBRATION_FB\"";
            error_str += " which requires extension \"XR_FB_haptic_pcm\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrHapticBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrHapticBaseHeader",
                         value->type, "VUID-XrHapticBaseHeader-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset2Di* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent2Di* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect2Di* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainSubImage* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&value->swapchain);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSwapchain handle \"swapchain\" ";
            oss << HandleToHexString(value->swapchain);
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainSubImage-swapchain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerProjectionView* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerProjectionView",
                             value->type, "VUID-XrCompositionLayerProjectionView-type-type", XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW, "XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR);
    valid_ext_structs.push_back(XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjectionView-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerProjectionView struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerProjectionView : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjectionView-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerProjectionView struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjectionView-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerProjectionView member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerProjection* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerProjection",
                             value->type, "VUID-XrCompositionLayerProjection-type-type", XR_TYPE_COMPOSITION_LAYER_PROJECTION, "XR_TYPE_COMPOSITION_LAYER_PROJECTION");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO);
    valid_ext_structs.push_back(XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT);
    valid_ext_structs.push_back(XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerProjection struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerProjection : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerProjection struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerProjection invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Non-optional array length must be non-zero
    if (0 >= value->viewCount && nullptr != value->views) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-viewCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerProjection member viewCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->views && 0 != value->viewCount) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-views-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrCompositionLayerProjection contains invalid NULL for XrCompositionLayerProjectionView \"views\" is which not "
                            "optional since \"viewCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->views) {
        for (uint32_t value_views_inc = 0; value_views_inc < value->viewCount; ++value_views_inc) {
            // Validate that the structure XrCompositionLayerProjectionView is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->views[value_views_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerProjection-views-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrCompositionLayerProjection member views is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerQuad* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_QUAD) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerQuad",
                             value->type, "VUID-XrCompositionLayerQuad-type-type", XR_TYPE_COMPOSITION_LAYER_QUAD, "XR_TYPE_COMPOSITION_LAYER_QUAD");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerQuad struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerQuad : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerQuad struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerQuad invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrEyeVisibility value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerQuad", "eyeVisibility", objects_info, value->eyeVisibility)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerQuad contains invalid XrEyeVisibility \"eyeVisibility\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->eyeVisibility));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-eyeVisibility-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerQuad-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerQuad member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataBaseHeader* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrEventDataBaseHeader-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrEventDataBaseHeader-next-next" because it is a base structure
    if (value->type == XR_TYPE_EVENT_DATA_EVENTS_LOST) {
        const XrEventDataEventsLost* new_value = reinterpret_cast<const XrEventDataEventsLost*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING) {
        const XrEventDataInstanceLossPending* new_value = reinterpret_cast<const XrEventDataInstanceLossPending*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED) {
        const XrEventDataSessionStateChanged* new_value = reinterpret_cast<const XrEventDataSessionStateChanged*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING) {
        const XrEventDataReferenceSpaceChangePending* new_value = reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED) {
        const XrEventDataInteractionProfileChanged* new_value = reinterpret_cast<const XrEventDataInteractionProfileChanged*>(value);
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR) {
        const XrEventDataVisibilityMaskChangedKHR* new_value = reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_visibility_mask")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR\"";
            error_str += " which requires extension \"XR_KHR_visibility_mask\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT) {
        const XrEventDataPerfSettingsEXT* new_value = reinterpret_cast<const XrEventDataPerfSettingsEXT*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_performance_settings")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT\"";
            error_str += " which requires extension \"XR_EXT_performance_settings\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX) {
        const XrEventDataMainSessionVisibilityChangedEXTX* new_value = reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXTX_overlay")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX\"";
            error_str += " which requires extension \"XR_EXTX_overlay\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB) {
        const XrEventDataDisplayRefreshRateChangedFB* new_value = reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_display_refresh_rate")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB\"";
            error_str += " which requires extension \"XR_FB_display_refresh_rate\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX) {
        const XrEventDataViveTrackerConnectedHTCX* new_value = reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_HTCX_vive_tracker_interaction")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX\"";
            error_str += " which requires extension \"XR_HTCX_vive_tracker_interaction\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB) {
        const XrEventDataSpatialAnchorCreateCompleteFB* new_value = reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB) {
        const XrEventDataSpaceSetStatusCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO) {
        const XrEventDataMarkerTrackingUpdateVARJO* new_value = reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VARJO_marker_tracking")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO\"";
            error_str += " which requires extension \"XR_VARJO_marker_tracking\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML) {
        const XrEventDataLocalizationChangedML* new_value = reinterpret_cast<const XrEventDataLocalizationChangedML*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_localization_map")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML\"";
            error_str += " which requires extension \"XR_ML_localization_map\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB) {
        const XrEventDataSpaceQueryResultsAvailableFB* new_value = reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB) {
        const XrEventDataSpaceQueryCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB) {
        const XrEventDataSpaceSaveCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB) {
        const XrEventDataSpaceEraseCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_storage\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB) {
        const XrEventDataSpaceShareCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_sharing")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_sharing\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB) {
        const XrEventDataSpaceListSaveCompleteFB* new_value = reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_storage_batch")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_storage_batch\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML) {
        const XrEventDataHeadsetFitChangedML* new_value = reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML\"";
            error_str += " which requires extension \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML) {
        const XrEventDataEyeCalibrationChangedML* new_value = reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_ML_user_calibration")) {
            std::string error_str = "XrEventDataBaseHeader being used with child struct type ";
            error_str += "\"XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML\"";
            error_str += " which requires extension \"XR_ML_user_calibration\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrEventDataBaseHeader-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataBaseHeader",
                         value->type, "VUID-XrEventDataBaseHeader-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataEventsLost* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_EVENTS_LOST) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataEventsLost",
                             value->type, "VUID-XrEventDataEventsLost-type-type", XR_TYPE_EVENT_DATA_EVENTS_LOST, "XR_TYPE_EVENT_DATA_EVENTS_LOST");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataEventsLost-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataEventsLost struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataEventsLost : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataEventsLost-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataEventsLost struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataInstanceLossPending* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataInstanceLossPending",
                             value->type, "VUID-XrEventDataInstanceLossPending-type-type", XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING, "XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataInstanceLossPending-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataInstanceLossPending struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataInstanceLossPending : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataInstanceLossPending-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataInstanceLossPending struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSessionStateChanged* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSessionStateChanged",
                             value->type, "VUID-XrEventDataSessionStateChanged-type-type", XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED, "XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSessionStateChanged-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSessionStateChanged struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSessionStateChanged : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSessionStateChanged-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSessionStateChanged struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataSessionStateChanged-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSessionState value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSessionStateChanged", "state", objects_info, value->state)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSessionStateChanged contains invalid XrSessionState \"state\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->state));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSessionStateChanged-state-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataReferenceSpaceChangePending* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataReferenceSpaceChangePending",
                             value->type, "VUID-XrEventDataReferenceSpaceChangePending-type-type", XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING, "XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataReferenceSpaceChangePending-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataReferenceSpaceChangePending struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataReferenceSpaceChangePending : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataReferenceSpaceChangePending-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataReferenceSpaceChangePending struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataReferenceSpaceChangePending-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrReferenceSpaceType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataReferenceSpaceChangePending", "referenceSpaceType", objects_info, value->referenceSpaceType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataReferenceSpaceChangePending contains invalid XrReferenceSpaceType \"referenceSpaceType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->referenceSpaceType));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataReferenceSpaceChangePending-referenceSpaceType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataInteractionProfileChanged* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataInteractionProfileChanged",
                             value->type, "VUID-XrEventDataInteractionProfileChanged-type-type", XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED, "XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataInteractionProfileChanged-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataInteractionProfileChanged struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataInteractionProfileChanged : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataInteractionProfileChanged-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataInteractionProfileChanged struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataInteractionProfileChanged-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticVibration* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAPTIC_VIBRATION) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHapticVibration",
                             value->type, "VUID-XrHapticVibration-type-type", XR_TYPE_HAPTIC_VIBRATION, "XR_TYPE_HAPTIC_VIBRATION");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticVibration-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHapticVibration struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHapticVibration : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHapticVibration-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHapticVibration struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset2Df* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect2Df* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector4f* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrColor4f* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerCubeKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerCubeKHR",
                             value->type, "VUID-XrCompositionLayerCubeKHR-type-type", XR_TYPE_COMPOSITION_LAYER_CUBE_KHR, "XR_TYPE_COMPOSITION_LAYER_CUBE_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerCubeKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerCubeKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerCubeKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerCubeKHR invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrEyeVisibility value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerCubeKHR", "eyeVisibility", objects_info, value->eyeVisibility)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerCubeKHR contains invalid XrEyeVisibility \"eyeVisibility\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->eyeVisibility));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-eyeVisibility-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&value->swapchain);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSwapchain handle \"swapchain\" ";
            oss << HandleToHexString(value->swapchain);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCubeKHR-swapchain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInstanceCreateInfoAndroidKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInstanceCreateInfoAndroidKHR",
                             value->type, "VUID-XrInstanceCreateInfoAndroidKHR-type-type", XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR, "XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfoAndroidKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInstanceCreateInfoAndroidKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInstanceCreateInfoAndroidKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfoAndroidKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInstanceCreateInfoAndroidKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->applicationVM) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfoAndroidKHR-applicationVM-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrInstanceCreateInfoAndroidKHR contains invalid NULL for void \"applicationVM\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->applicationActivity) {
        CoreValidLogMessage(instance_info, "VUID-XrInstanceCreateInfoAndroidKHR-applicationActivity-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrInstanceCreateInfoAndroidKHR contains invalid NULL for void \"applicationActivity\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthInfoKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerDepthInfoKHR",
                             value->type, "VUID-XrCompositionLayerDepthInfoKHR-type-type", XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR, "XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthInfoKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerDepthInfoKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerDepthInfoKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthInfoKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerDepthInfoKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthInfoKHR-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerDepthInfoKHR member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanSwapchainFormatListCreateInfoKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVulkanSwapchainFormatListCreateInfoKHR",
                             value->type, "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-type-type", XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR, "XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVulkanSwapchainFormatListCreateInfoKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVulkanSwapchainFormatListCreateInfoKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVulkanSwapchainFormatListCreateInfoKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->viewFormatCount is non-zero
    if (0 != value->viewFormatCount && nullptr == value->viewFormats) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-viewFormats-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrVulkanSwapchainFormatListCreateInfoKHR member viewFormatCount is NULL, but value->viewFormatCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->viewFormats && 0 != value->viewFormatCount) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-viewFormats-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVulkanSwapchainFormatListCreateInfoKHR contains invalid NULL for VkFormat \"viewFormats\" is which not "
                            "optional since \"viewFormatCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVulkanSwapchainFormatListCreateInfoKHR-viewFormats-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerCylinderKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerCylinderKHR",
                             value->type, "VUID-XrCompositionLayerCylinderKHR-type-type", XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR, "XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerCylinderKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerCylinderKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerCylinderKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerCylinderKHR invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrEyeVisibility value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerCylinderKHR", "eyeVisibility", objects_info, value->eyeVisibility)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerCylinderKHR contains invalid XrEyeVisibility \"eyeVisibility\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->eyeVisibility));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-eyeVisibility-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerCylinderKHR-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerCylinderKHR member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerEquirectKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerEquirectKHR",
                             value->type, "VUID-XrCompositionLayerEquirectKHR-type-type", XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR, "XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerEquirectKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerEquirectKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerEquirectKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerEquirectKHR invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrEyeVisibility value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerEquirectKHR", "eyeVisibility", objects_info, value->eyeVisibility)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerEquirectKHR contains invalid XrEyeVisibility \"eyeVisibility\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->eyeVisibility));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-eyeVisibility-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirectKHR-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerEquirectKHR member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLWin32KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingOpenGLWin32KHR",
                             value->type, "VUID-XrGraphicsBindingOpenGLWin32KHR-type-type", XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR, "XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLWin32KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingOpenGLWin32KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingOpenGLWin32KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLWin32KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingOpenGLWin32KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLXlibKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingOpenGLXlibKHR",
                             value->type, "VUID-XrGraphicsBindingOpenGLXlibKHR-type-type", XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR, "XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLXlibKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingOpenGLXlibKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingOpenGLXlibKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLXlibKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingOpenGLXlibKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->xDisplay) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLXlibKHR-xDisplay-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrGraphicsBindingOpenGLXlibKHR contains invalid NULL for Display \"xDisplay\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrGraphicsBindingOpenGLXlibKHR-xDisplay-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLXcbKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingOpenGLXcbKHR",
                             value->type, "VUID-XrGraphicsBindingOpenGLXcbKHR-type-type", XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR, "XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLXcbKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingOpenGLXcbKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingOpenGLXcbKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLXcbKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingOpenGLXcbKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLWaylandKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingOpenGLWaylandKHR",
                             value->type, "VUID-XrGraphicsBindingOpenGLWaylandKHR-type-type", XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR, "XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLWaylandKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingOpenGLWaylandKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingOpenGLWaylandKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLWaylandKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingOpenGLWaylandKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageOpenGLKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageOpenGLKHR",
                             value->type, "VUID-XrSwapchainImageOpenGLKHR-type-type", XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR, "XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageOpenGLKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageOpenGLKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageOpenGLKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageOpenGLKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageOpenGLKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsOpenGLKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsRequirementsOpenGLKHR",
                             value->type, "VUID-XrGraphicsRequirementsOpenGLKHR-type-type", XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR, "XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsOpenGLKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsRequirementsOpenGLKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsRequirementsOpenGLKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsOpenGLKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsRequirementsOpenGLKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingOpenGLESAndroidKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingOpenGLESAndroidKHR",
                             value->type, "VUID-XrGraphicsBindingOpenGLESAndroidKHR-type-type", XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR, "XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLESAndroidKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingOpenGLESAndroidKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingOpenGLESAndroidKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingOpenGLESAndroidKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingOpenGLESAndroidKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageOpenGLESKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageOpenGLESKHR",
                             value->type, "VUID-XrSwapchainImageOpenGLESKHR-type-type", XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR, "XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageOpenGLESKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageOpenGLESKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageOpenGLESKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageOpenGLESKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageOpenGLESKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsOpenGLESKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsRequirementsOpenGLESKHR",
                             value->type, "VUID-XrGraphicsRequirementsOpenGLESKHR-type-type", XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR, "XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsOpenGLESKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsRequirementsOpenGLESKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsRequirementsOpenGLESKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsOpenGLESKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsRequirementsOpenGLESKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingVulkanKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingVulkanKHR",
                             value->type, "VUID-XrGraphicsBindingVulkanKHR-type-type", XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR, "XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingVulkanKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingVulkanKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingVulkanKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingVulkanKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingVulkanKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageVulkanKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageVulkanKHR",
                             value->type, "VUID-XrSwapchainImageVulkanKHR-type-type", XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR, "XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageVulkanKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageVulkanKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageVulkanKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageVulkanKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageVulkanKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsVulkanKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsRequirementsVulkanKHR",
                             value->type, "VUID-XrGraphicsRequirementsVulkanKHR-type-type", XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR, "XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsVulkanKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsRequirementsVulkanKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsRequirementsVulkanKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsVulkanKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsRequirementsVulkanKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingD3D11KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_D3D11_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingD3D11KHR",
                             value->type, "VUID-XrGraphicsBindingD3D11KHR-type-type", XR_TYPE_GRAPHICS_BINDING_D3D11_KHR, "XR_TYPE_GRAPHICS_BINDING_D3D11_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D11KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingD3D11KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingD3D11KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D11KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingD3D11KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->device) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D11KHR-device-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrGraphicsBindingD3D11KHR contains invalid NULL for ID3D11Device \"device\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrGraphicsBindingD3D11KHR-device-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageD3D11KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageD3D11KHR",
                             value->type, "VUID-XrSwapchainImageD3D11KHR-type-type", XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR, "XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D11KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageD3D11KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageD3D11KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D11KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageD3D11KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->texture) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D11KHR-texture-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSwapchainImageD3D11KHR contains invalid NULL for ID3D11Texture2D \"texture\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSwapchainImageD3D11KHR-texture-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsD3D11KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsRequirementsD3D11KHR",
                             value->type, "VUID-XrGraphicsRequirementsD3D11KHR-type-type", XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR, "XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsD3D11KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsRequirementsD3D11KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsRequirementsD3D11KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsD3D11KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsRequirementsD3D11KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingD3D12KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_D3D12_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingD3D12KHR",
                             value->type, "VUID-XrGraphicsBindingD3D12KHR-type-type", XR_TYPE_GRAPHICS_BINDING_D3D12_KHR, "XR_TYPE_GRAPHICS_BINDING_D3D12_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D12KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingD3D12KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingD3D12KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D12KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingD3D12KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->device) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D12KHR-device-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrGraphicsBindingD3D12KHR contains invalid NULL for ID3D12Device \"device\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrGraphicsBindingD3D12KHR-device-parameter" type
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->queue) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingD3D12KHR-queue-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrGraphicsBindingD3D12KHR contains invalid NULL for ID3D12CommandQueue \"queue\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrGraphicsBindingD3D12KHR-queue-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageD3D12KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageD3D12KHR",
                             value->type, "VUID-XrSwapchainImageD3D12KHR-type-type", XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR, "XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D12KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageD3D12KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageD3D12KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D12KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageD3D12KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->texture) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageD3D12KHR-texture-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSwapchainImageD3D12KHR contains invalid NULL for ID3D12Resource \"texture\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSwapchainImageD3D12KHR-texture-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsRequirementsD3D12KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsRequirementsD3D12KHR",
                             value->type, "VUID-XrGraphicsRequirementsD3D12KHR-type-type", XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR, "XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsD3D12KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsRequirementsD3D12KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsRequirementsD3D12KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsRequirementsD3D12KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsRequirementsD3D12KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_D3D12)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVisibilityMaskKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VISIBILITY_MASK_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVisibilityMaskKHR",
                             value->type, "VUID-XrVisibilityMaskKHR-type-type", XR_TYPE_VISIBILITY_MASK_KHR, "XR_TYPE_VISIBILITY_MASK_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVisibilityMaskKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVisibilityMaskKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVisibilityMaskKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVisibilityMaskKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVisibilityMaskKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrVisibilityMaskKHR-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrVisibilityMaskKHR member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVisibilityMaskKHR-vertices-parameter" type
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrVisibilityMaskKHR-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrVisibilityMaskKHR member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVisibilityMaskKHR-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVisibilityMaskChangedKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVisibilityMaskChangedKHR",
                             value->type, "VUID-XrEventDataVisibilityMaskChangedKHR-type-type", XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR, "XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVisibilityMaskChangedKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVisibilityMaskChangedKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVisibilityMaskChangedKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVisibilityMaskChangedKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVisibilityMaskChangedKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVisibilityMaskChangedKHR-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataVisibilityMaskChangedKHR", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataVisibilityMaskChangedKHR contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVisibilityMaskChangedKHR-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerColorScaleBiasKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerColorScaleBiasKHR",
                             value->type, "VUID-XrCompositionLayerColorScaleBiasKHR-type-type", XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR, "XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerColorScaleBiasKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerColorScaleBiasKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerColorScaleBiasKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerColorScaleBiasKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerColorScaleBiasKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLoaderInitInfoBaseHeaderKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrLoaderInitInfoBaseHeaderKHR-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrLoaderInitInfoBaseHeaderKHR-next-next" because it is a base structure
#if defined(XR_USE_PLATFORM_ANDROID)
    if (value->type == XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR) {
        const XrLoaderInitInfoAndroidKHR* new_value = reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_KHR_loader_init_android")) {
            std::string error_str = "XrLoaderInitInfoBaseHeaderKHR being used with child struct type ";
            error_str += "\"XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR\"";
            error_str += " which requires extension \"XR_KHR_loader_init_android\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrLoaderInitInfoBaseHeaderKHR-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_PLATFORM_ANDROID)
    InvalidStructureType(instance_info, command_name, objects_info, "XrLoaderInitInfoBaseHeaderKHR",
                         value->type, "VUID-XrLoaderInitInfoBaseHeaderKHR-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

#if defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLoaderInitInfoAndroidKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrLoaderInitInfoAndroidKHR",
                             value->type, "VUID-XrLoaderInitInfoAndroidKHR-type-type", XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR, "XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrLoaderInitInfoAndroidKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrLoaderInitInfoAndroidKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrLoaderInitInfoAndroidKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrLoaderInitInfoAndroidKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrLoaderInitInfoAndroidKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->applicationVM) {
        CoreValidLogMessage(instance_info, "VUID-XrLoaderInitInfoAndroidKHR-applicationVM-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrLoaderInitInfoAndroidKHR contains invalid NULL for void \"applicationVM\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->applicationContext) {
        CoreValidLogMessage(instance_info, "VUID-XrLoaderInitInfoAndroidKHR-applicationContext-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrLoaderInitInfoAndroidKHR contains invalid NULL for void \"applicationContext\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanInstanceCreateInfoKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVulkanInstanceCreateInfoKHR",
                             value->type, "VUID-XrVulkanInstanceCreateInfoKHR-type-type", XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR, "XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanInstanceCreateInfoKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVulkanInstanceCreateInfoKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVulkanInstanceCreateInfoKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVulkanInstanceCreateInfoKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVulkanInstanceCreateInfoKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult vulkan_instance_create_flags_khr_result = ValidateXrVulkanInstanceCreateFlagsKHR(value->createFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == vulkan_instance_create_flags_khr_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrVulkanInstanceCreateInfoKHR invalid member XrVulkanInstanceCreateFlagsKHR \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrVulkanInstanceCreateInfoKHR-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->pfnGetInstanceProcAddr) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanInstanceCreateInfoKHR-pfnGetInstanceProcAddr-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVulkanInstanceCreateInfoKHR contains invalid NULL for PFN_vkGetInstanceProcAddr \"pfnGetInstanceProcAddr\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVulkanInstanceCreateInfoKHR-pfnGetInstanceProcAddr-parameter" type
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->vulkanCreateInfo) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanInstanceCreateInfoKHR-vulkanCreateInfo-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVulkanInstanceCreateInfoKHR contains invalid NULL for VkInstanceCreateInfo \"vulkanCreateInfo\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVulkanInstanceCreateInfoKHR-vulkanCreateInfo-parameter" type
    // NOTE: Can't validate "VUID-XrVulkanInstanceCreateInfoKHR-vulkanAllocator-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanDeviceCreateInfoKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVulkanDeviceCreateInfoKHR",
                             value->type, "VUID-XrVulkanDeviceCreateInfoKHR-type-type", XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR, "XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanDeviceCreateInfoKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVulkanDeviceCreateInfoKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVulkanDeviceCreateInfoKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVulkanDeviceCreateInfoKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVulkanDeviceCreateInfoKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult vulkan_device_create_flags_khr_result = ValidateXrVulkanDeviceCreateFlagsKHR(value->createFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == vulkan_device_create_flags_khr_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrVulkanDeviceCreateInfoKHR invalid member XrVulkanDeviceCreateFlagsKHR \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrVulkanDeviceCreateInfoKHR-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->pfnGetInstanceProcAddr) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanDeviceCreateInfoKHR-pfnGetInstanceProcAddr-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVulkanDeviceCreateInfoKHR contains invalid NULL for PFN_vkGetInstanceProcAddr \"pfnGetInstanceProcAddr\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVulkanDeviceCreateInfoKHR-pfnGetInstanceProcAddr-parameter" type
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->vulkanCreateInfo) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanDeviceCreateInfoKHR-vulkanCreateInfo-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVulkanDeviceCreateInfoKHR contains invalid NULL for VkDeviceCreateInfo \"vulkanCreateInfo\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVulkanDeviceCreateInfoKHR-vulkanCreateInfo-parameter" type
    // NOTE: Can't validate "VUID-XrVulkanDeviceCreateInfoKHR-vulkanAllocator-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanGraphicsDeviceGetInfoKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVulkanGraphicsDeviceGetInfoKHR",
                             value->type, "VUID-XrVulkanGraphicsDeviceGetInfoKHR-type-type", XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR, "XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanGraphicsDeviceGetInfoKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVulkanGraphicsDeviceGetInfoKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVulkanGraphicsDeviceGetInfoKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVulkanGraphicsDeviceGetInfoKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVulkanGraphicsDeviceGetInfoKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerEquirect2KHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerEquirect2KHR",
                             value->type, "VUID-XrCompositionLayerEquirect2KHR-type-type", XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR, "XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerEquirect2KHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerEquirect2KHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerEquirect2KHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerEquirect2KHR invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrEyeVisibility value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerEquirect2KHR", "eyeVisibility", objects_info, value->eyeVisibility)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerEquirect2KHR contains invalid XrEyeVisibility \"eyeVisibility\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->eyeVisibility));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-eyeVisibility-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->subImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerEquirect2KHR-subImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerEquirect2KHR member subImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBindingModificationBaseHeaderKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrBindingModificationBaseHeaderKHR-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrBindingModificationBaseHeaderKHR-next-next" because it is a base structure
    if (value->type == XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT) {
        const XrInteractionProfileDpadBindingEXT* new_value = reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_EXT_dpad_binding")) {
            std::string error_str = "XrBindingModificationBaseHeaderKHR being used with child struct type ";
            error_str += "\"XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT\"";
            error_str += " which requires extension \"XR_EXT_dpad_binding\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrBindingModificationBaseHeaderKHR-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE) {
        const XrInteractionProfileAnalogThresholdVALVE* new_value = reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_VALVE_analog_threshold")) {
            std::string error_str = "XrBindingModificationBaseHeaderKHR being used with child struct type ";
            error_str += "\"XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE\"";
            error_str += " which requires extension \"XR_VALVE_analog_threshold\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrBindingModificationBaseHeaderKHR-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrBindingModificationBaseHeaderKHR",
                         value->type, "VUID-XrBindingModificationBaseHeaderKHR-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBindingModificationsKHR* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BINDING_MODIFICATIONS_KHR) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBindingModificationsKHR",
                             value->type, "VUID-XrBindingModificationsKHR-type-type", XR_TYPE_BINDING_MODIFICATIONS_KHR, "XR_TYPE_BINDING_MODIFICATIONS_KHR");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBindingModificationsKHR struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBindingModificationsKHR : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBindingModificationsKHR struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->bindingModificationCount is non-zero
    if (0 != value->bindingModificationCount && nullptr == value->bindingModifications) {
        CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-bindingModifications-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrBindingModificationsKHR member bindingModificationCount is NULL, but value->bindingModificationCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->bindingModifications) {
        for (uint32_t value_bindingmodifications_inc = 0; value_bindingmodifications_inc < value->bindingModificationCount; ++value_bindingmodifications_inc) {
            // Validate if XrBindingModificationBaseHeaderKHR is a child structure of type XrInteractionProfileDpadBindingEXT and it is valid
            {
                const XrInteractionProfileDpadBindingEXT* const* new_interactionprofiledpadbindingext_value = reinterpret_cast<const XrInteractionProfileDpadBindingEXT* const*>(value->bindingModifications);
                if (new_interactionprofiledpadbindingext_value[value_bindingmodifications_inc]->type == XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT) {
                    if (nullptr != new_interactionprofiledpadbindingext_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_interactionprofiledpadbindingext_value[value_bindingmodifications_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrBindingModificationsKHR member bindingModifications";
                            error_message += "[";
                            error_message += std::to_string(value_bindingmodifications_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-bindingModifications-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate if XrBindingModificationBaseHeaderKHR is a child structure of type XrInteractionProfileAnalogThresholdVALVE and it is valid
            {
                const XrInteractionProfileAnalogThresholdVALVE* const* new_interactionprofileanalogthresholdvalve_value = reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE* const*>(value->bindingModifications);
                if (new_interactionprofileanalogthresholdvalve_value[value_bindingmodifications_inc]->type == XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE) {
                    if (nullptr != new_interactionprofileanalogthresholdvalve_value) {
                        xr_result = ValidateXrStruct(instance_info, command_name,
                                                                        objects_info, check_members, new_interactionprofileanalogthresholdvalve_value[value_bindingmodifications_inc]);
                        if (XR_SUCCESS != xr_result) {
                            std::string error_message = "Structure XrBindingModificationsKHR member bindingModifications";
                            error_message += "[";
                            error_message += std::to_string(value_bindingmodifications_inc);
                            error_message += "]";
                            error_message += " is invalid";
                            CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-bindingModifications-parameter",
                                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                                objects_info,
                                                error_message);
                            return XR_ERROR_VALIDATION_FAILURE;
                            break;
                        } else {
                            continue;
                            }
                    }
                }
            }
            // Validate that the base-structure XrBindingModificationBaseHeaderKHR is valid
            if (nullptr != value->bindingModifications[value_bindingmodifications_inc]) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, value->bindingModifications[value_bindingmodifications_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(instance_info, "VUID-XrBindingModificationsKHR-bindingModifications-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        "Structure XrBindingModificationsKHR member bindingModifications is invalid");
                    return xr_result;
                }
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataPerfSettingsEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataPerfSettingsEXT",
                             value->type, "VUID-XrEventDataPerfSettingsEXT-type-type", XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT, "XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataPerfSettingsEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataPerfSettingsEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataPerfSettingsEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrPerfSettingsDomainEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataPerfSettingsEXT", "domain", objects_info, value->domain)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataPerfSettingsEXT contains invalid XrPerfSettingsDomainEXT \"domain\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->domain));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-domain-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPerfSettingsSubDomainEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataPerfSettingsEXT", "subDomain", objects_info, value->subDomain)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataPerfSettingsEXT contains invalid XrPerfSettingsSubDomainEXT \"subDomain\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->subDomain));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-subDomain-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPerfSettingsNotificationLevelEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataPerfSettingsEXT", "fromLevel", objects_info, value->fromLevel)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataPerfSettingsEXT contains invalid XrPerfSettingsNotificationLevelEXT \"fromLevel\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->fromLevel));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-fromLevel-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPerfSettingsNotificationLevelEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataPerfSettingsEXT", "toLevel", objects_info, value->toLevel)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataPerfSettingsEXT contains invalid XrPerfSettingsNotificationLevelEXT \"toLevel\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->toLevel));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPerfSettingsEXT-toLevel-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsObjectNameInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDebugUtilsObjectNameInfoEXT",
                             value->type, "VUID-XrDebugUtilsObjectNameInfoEXT-type-type", XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT, "XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsObjectNameInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDebugUtilsObjectNameInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDebugUtilsObjectNameInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsObjectNameInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDebugUtilsObjectNameInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrObjectType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrDebugUtilsObjectNameInfoEXT", "objectType", objects_info, value->objectType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrDebugUtilsObjectNameInfoEXT contains invalid XrObjectType \"objectType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->objectType));
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsObjectNameInfoEXT-objectType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrDebugUtilsObjectNameInfoEXT-objectName-parameter" null-termination
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsLabelEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DEBUG_UTILS_LABEL_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDebugUtilsLabelEXT",
                             value->type, "VUID-XrDebugUtilsLabelEXT-type-type", XR_TYPE_DEBUG_UTILS_LABEL_EXT, "XR_TYPE_DEBUG_UTILS_LABEL_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsLabelEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDebugUtilsLabelEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDebugUtilsLabelEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsLabelEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDebugUtilsLabelEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->labelName) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsLabelEXT-labelName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrDebugUtilsLabelEXT contains invalid NULL for char \"labelName\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrDebugUtilsLabelEXT-labelName-parameter" null-termination
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsMessengerCallbackDataEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDebugUtilsMessengerCallbackDataEXT",
                             value->type, "VUID-XrDebugUtilsMessengerCallbackDataEXT-type-type", XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT, "XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCallbackDataEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDebugUtilsMessengerCallbackDataEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDebugUtilsMessengerCallbackDataEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCallbackDataEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDebugUtilsMessengerCallbackDataEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // NOTE: Can't validate "VUID-XrDebugUtilsMessengerCallbackDataEXT-messageId-parameter" null-termination
    // NOTE: Can't validate "VUID-XrDebugUtilsMessengerCallbackDataEXT-functionName-parameter" null-termination
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->message) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCallbackDataEXT-message-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrDebugUtilsMessengerCallbackDataEXT contains invalid NULL for char \"message\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrDebugUtilsMessengerCallbackDataEXT-message-parameter" null-termination
    // Optional array must be non-NULL when value->objectCount is non-zero
    if (0 != value->objectCount && nullptr == value->objects) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCallbackDataEXT-objects-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrDebugUtilsMessengerCallbackDataEXT member objectCount is NULL, but value->objectCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Optional array must be non-NULL when value->sessionLabelCount is non-zero
    if (0 != value->sessionLabelCount && nullptr == value->sessionLabels) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCallbackDataEXT-sessionLabels-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrDebugUtilsMessengerCallbackDataEXT member sessionLabelCount is NULL, but value->sessionLabelCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDebugUtilsMessengerCreateInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDebugUtilsMessengerCreateInfoEXT",
                             value->type, "VUID-XrDebugUtilsMessengerCreateInfoEXT-type-type", XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT, "XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDebugUtilsMessengerCreateInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDebugUtilsMessengerCreateInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDebugUtilsMessengerCreateInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult debug_utils_message_severity_flags_ext_result = ValidateXrDebugUtilsMessageSeverityFlagsEXT(value->messageSeverities);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == debug_utils_message_severity_flags_ext_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-messageSeverities-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrDebugUtilsMessageSeverityFlagsEXT \"messageSeverities\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != debug_utils_message_severity_flags_ext_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrDebugUtilsMessengerCreateInfoEXT invalid member XrDebugUtilsMessageSeverityFlagsEXT \"messageSeverities\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->messageSeverities));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-messageSeverities-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    ValidateXrFlagsResult debug_utils_message_type_flags_ext_result = ValidateXrDebugUtilsMessageTypeFlagsEXT(value->messageTypes);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == debug_utils_message_type_flags_ext_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-messageTypes-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrDebugUtilsMessageTypeFlagsEXT \"messageTypes\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != debug_utils_message_type_flags_ext_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrDebugUtilsMessengerCreateInfoEXT invalid member XrDebugUtilsMessageTypeFlagsEXT \"messageTypes\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->messageTypes));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-messageTypes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->userCallback) {
        CoreValidLogMessage(instance_info, "VUID-XrDebugUtilsMessengerCreateInfoEXT-userCallback-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrDebugUtilsMessengerCreateInfoEXT contains invalid NULL for PFN_xrDebugUtilsMessengerCallbackEXT \"userCallback\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrDebugUtilsMessengerCreateInfoEXT-userCallback-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemEyeGazeInteractionPropertiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemEyeGazeInteractionPropertiesEXT",
                             value->type, "VUID-XrSystemEyeGazeInteractionPropertiesEXT-type-type", XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT, "XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemEyeGazeInteractionPropertiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemEyeGazeInteractionPropertiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemEyeGazeInteractionPropertiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemEyeGazeInteractionPropertiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemEyeGazeInteractionPropertiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazeSampleTimeEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEyeGazeSampleTimeEXT",
                             value->type, "VUID-XrEyeGazeSampleTimeEXT-type-type", XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT, "XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazeSampleTimeEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEyeGazeSampleTimeEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEyeGazeSampleTimeEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazeSampleTimeEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEyeGazeSampleTimeEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSessionCreateInfoOverlayEXTX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSessionCreateInfoOverlayEXTX",
                             value->type, "VUID-XrSessionCreateInfoOverlayEXTX-type-type", XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX, "XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfoOverlayEXTX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSessionCreateInfoOverlayEXTX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSessionCreateInfoOverlayEXTX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfoOverlayEXTX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSessionCreateInfoOverlayEXTX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult overlay_session_create_flags_extx_result = ValidateXrOverlaySessionCreateFlagsEXTX(value->createFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == overlay_session_create_flags_extx_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfoOverlayEXTX-createFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrOverlaySessionCreateFlagsEXTX \"createFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != overlay_session_create_flags_extx_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSessionCreateInfoOverlayEXTX invalid member XrOverlaySessionCreateFlagsEXTX \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSessionCreateInfoOverlayEXTX-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataMainSessionVisibilityChangedEXTX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataMainSessionVisibilityChangedEXTX",
                             value->type, "VUID-XrEventDataMainSessionVisibilityChangedEXTX-type-type", XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX, "XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMainSessionVisibilityChangedEXTX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataMainSessionVisibilityChangedEXTX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataMainSessionVisibilityChangedEXTX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMainSessionVisibilityChangedEXTX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataMainSessionVisibilityChangedEXTX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult overlay_main_session_flags_extx_result = ValidateXrOverlayMainSessionFlagsEXTX(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == overlay_main_session_flags_extx_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMainSessionVisibilityChangedEXTX-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrOverlayMainSessionFlagsEXTX \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != overlay_main_session_flags_extx_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataMainSessionVisibilityChangedEXTX invalid member XrOverlayMainSessionFlagsEXTX \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMainSessionVisibilityChangedEXTX-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorCreateInfoMSFT",
                             value->type, "VUID-XrSpatialAnchorCreateInfoMSFT-type-type", XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT, "XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorSpaceCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorSpaceCreateInfoMSFT",
                             value->type, "VUID-XrSpatialAnchorSpaceCreateInfoMSFT-type-type", XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT, "XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorSpaceCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorSpaceCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorSpaceCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorSpaceCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorSpaceCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorMSFTHandle(&value->anchor);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpatialAnchorMSFT handle \"anchor\" ";
            oss << HandleToHexString(value->anchor);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorSpaceCreateInfoMSFT-anchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerImageLayoutFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerImageLayoutFB",
                             value->type, "VUID-XrCompositionLayerImageLayoutFB-type-type", XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB, "XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerImageLayoutFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerImageLayoutFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerImageLayoutFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerImageLayoutFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerImageLayoutFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_image_layout_flags_fb_result = ValidateXrCompositionLayerImageLayoutFlagsFB(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_image_layout_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerImageLayoutFB invalid member XrCompositionLayerImageLayoutFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerImageLayoutFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerAlphaBlendFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerAlphaBlendFB",
                             value->type, "VUID-XrCompositionLayerAlphaBlendFB-type-type", XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB, "XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerAlphaBlendFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerAlphaBlendFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerAlphaBlendFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrBlendFactorFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerAlphaBlendFB", "srcFactorColor", objects_info, value->srcFactorColor)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerAlphaBlendFB contains invalid XrBlendFactorFB \"srcFactorColor\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->srcFactorColor));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-srcFactorColor-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrBlendFactorFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerAlphaBlendFB", "dstFactorColor", objects_info, value->dstFactorColor)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerAlphaBlendFB contains invalid XrBlendFactorFB \"dstFactorColor\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dstFactorColor));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-dstFactorColor-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrBlendFactorFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerAlphaBlendFB", "srcFactorAlpha", objects_info, value->srcFactorAlpha)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerAlphaBlendFB contains invalid XrBlendFactorFB \"srcFactorAlpha\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->srcFactorAlpha));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-srcFactorAlpha-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrBlendFactorFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerAlphaBlendFB", "dstFactorAlpha", objects_info, value->dstFactorAlpha)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerAlphaBlendFB contains invalid XrBlendFactorFB \"dstFactorAlpha\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dstFactorAlpha));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerAlphaBlendFB-dstFactorAlpha-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationDepthRangeEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewConfigurationDepthRangeEXT",
                             value->type, "VUID-XrViewConfigurationDepthRangeEXT-type-type", XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT, "XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationDepthRangeEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewConfigurationDepthRangeEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewConfigurationDepthRangeEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationDepthRangeEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewConfigurationDepthRangeEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_PLATFORM_EGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGraphicsBindingEGLMNDX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GRAPHICS_BINDING_EGL_MNDX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGraphicsBindingEGLMNDX",
                             value->type, "VUID-XrGraphicsBindingEGLMNDX-type-type", XR_TYPE_GRAPHICS_BINDING_EGL_MNDX, "XR_TYPE_GRAPHICS_BINDING_EGL_MNDX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingEGLMNDX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGraphicsBindingEGLMNDX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGraphicsBindingEGLMNDX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingEGLMNDX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGraphicsBindingEGLMNDX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->getProcAddress) {
        CoreValidLogMessage(instance_info, "VUID-XrGraphicsBindingEGLMNDX-getProcAddress-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrGraphicsBindingEGLMNDX contains invalid NULL for PFN_xrEglGetProcAddressMNDX \"getProcAddress\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrGraphicsBindingEGLMNDX-getProcAddress-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_EGL)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeSpaceCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialGraphNodeSpaceCreateInfoMSFT",
                             value->type, "VUID-XrSpatialGraphNodeSpaceCreateInfoMSFT-type-type", XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT, "XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeSpaceCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialGraphNodeSpaceCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialGraphNodeSpaceCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeSpaceCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialGraphNodeSpaceCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSpatialGraphNodeTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpatialGraphNodeSpaceCreateInfoMSFT", "nodeType", objects_info, value->nodeType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpatialGraphNodeSpaceCreateInfoMSFT contains invalid XrSpatialGraphNodeTypeMSFT \"nodeType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->nodeType));
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeSpaceCreateInfoMSFT-nodeType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialGraphStaticNodeBindingCreateInfoMSFT",
                             value->type, "VUID-XrSpatialGraphStaticNodeBindingCreateInfoMSFT-type-type", XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT, "XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphStaticNodeBindingCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialGraphStaticNodeBindingCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialGraphStaticNodeBindingCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphStaticNodeBindingCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialGraphStaticNodeBindingCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphStaticNodeBindingCreateInfoMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialGraphNodeBindingPropertiesGetInfoMSFT",
                             value->type, "VUID-XrSpatialGraphNodeBindingPropertiesGetInfoMSFT-type-type", XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT, "XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeBindingPropertiesGetInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialGraphNodeBindingPropertiesGetInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialGraphNodeBindingPropertiesGetInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeBindingPropertiesGetInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialGraphNodeBindingPropertiesGetInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialGraphNodeBindingPropertiesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialGraphNodeBindingPropertiesMSFT",
                             value->type, "VUID-XrSpatialGraphNodeBindingPropertiesMSFT-type-type", XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT, "XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeBindingPropertiesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialGraphNodeBindingPropertiesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialGraphNodeBindingPropertiesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialGraphNodeBindingPropertiesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialGraphNodeBindingPropertiesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHandTrackingPropertiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemHandTrackingPropertiesEXT",
                             value->type, "VUID-XrSystemHandTrackingPropertiesEXT-type-type", XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT, "XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemHandTrackingPropertiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemHandTrackingPropertiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemHandTrackingPropertiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemHandTrackingPropertiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemHandTrackingPropertiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackerCreateInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackerCreateInfoEXT",
                             value->type, "VUID-XrHandTrackerCreateInfoEXT-type-type", XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT, "XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_HAND_POSE_TYPE_INFO_MSFT);
    valid_ext_structs.push_back(XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackerCreateInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackerCreateInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackerCreateInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackerCreateInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackerCreateInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandTrackerCreateInfoEXT", "hand", objects_info, value->hand)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandTrackerCreateInfoEXT contains invalid XrHandEXT \"hand\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->hand));
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackerCreateInfoEXT-hand-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrHandJointSetEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandTrackerCreateInfoEXT", "handJointSet", objects_info, value->handJointSet)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandTrackerCreateInfoEXT contains invalid XrHandJointSetEXT \"handJointSet\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->handJointSet));
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackerCreateInfoEXT-handJointSet-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointsLocateInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandJointsLocateInfoEXT",
                             value->type, "VUID-XrHandJointsLocateInfoEXT-type-type", XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT, "XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointsLocateInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandJointsLocateInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandJointsLocateInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandJointsLocateInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandJointsLocateInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrHandJointsLocateInfoEXT-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointLocationEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_location_flags_result = ValidateXrSpaceLocationFlags(value->locationFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == space_location_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrHandJointLocationEXT invalid member XrSpaceLocationFlags \"locationFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationEXT-locationFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointVelocityEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_velocity_flags_result = ValidateXrSpaceVelocityFlags(value->velocityFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == space_velocity_flags_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocityEXT-velocityFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrSpaceVelocityFlags \"velocityFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != space_velocity_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrHandJointVelocityEXT invalid member XrSpaceVelocityFlags \"velocityFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->velocityFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocityEXT-velocityFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointLocationsEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_JOINT_LOCATIONS_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandJointLocationsEXT",
                             value->type, "VUID-XrHandJointLocationsEXT-type-type", XR_TYPE_HAND_JOINT_LOCATIONS_EXT, "XR_TYPE_HAND_JOINT_LOCATIONS_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_HAND_JOINT_VELOCITIES_EXT);
    valid_ext_structs.push_back(XR_TYPE_HAND_TRACKING_AIM_STATE_FB);
    valid_ext_structs.push_back(XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB);
    valid_ext_structs.push_back(XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT);
    valid_ext_structs.push_back(XR_TYPE_HAND_TRACKING_SCALE_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationsEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandJointLocationsEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandJointLocationsEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationsEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandJointLocationsEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->jointCount && nullptr != value->jointLocations) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationsEXT-jointCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandJointLocationsEXT member jointCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->jointLocations && 0 != value->jointCount) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationsEXT-jointLocations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHandJointLocationsEXT contains invalid NULL for XrHandJointLocationEXT \"jointLocations\" is which not "
                            "optional since \"jointCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->jointLocations) {
        for (uint32_t value_jointlocations_inc = 0; value_jointlocations_inc < value->jointCount; ++value_jointlocations_inc) {
            // Validate that the structure XrHandJointLocationEXT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->jointLocations[value_jointlocations_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrHandJointLocationsEXT-jointLocations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrHandJointLocationsEXT member jointLocations is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointVelocitiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_JOINT_VELOCITIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandJointVelocitiesEXT",
                             value->type, "VUID-XrHandJointVelocitiesEXT-type-type", XR_TYPE_HAND_JOINT_VELOCITIES_EXT, "XR_TYPE_HAND_JOINT_VELOCITIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocitiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandJointVelocitiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandJointVelocitiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocitiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandJointVelocitiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->jointCount && nullptr != value->jointVelocities) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocitiesEXT-jointCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandJointVelocitiesEXT member jointCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->jointVelocities && 0 != value->jointCount) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocitiesEXT-jointVelocities-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHandJointVelocitiesEXT contains invalid NULL for XrHandJointVelocityEXT \"jointVelocities\" is which not "
                            "optional since \"jointCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->jointVelocities) {
        for (uint32_t value_jointvelocities_inc = 0; value_jointvelocities_inc < value->jointCount; ++value_jointvelocities_inc) {
            // Validate that the structure XrHandJointVelocityEXT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->jointVelocities[value_jointvelocities_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrHandJointVelocitiesEXT-jointVelocities-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrHandJointVelocitiesEXT member jointVelocities is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHandTrackingMeshPropertiesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemHandTrackingMeshPropertiesMSFT",
                             value->type, "VUID-XrSystemHandTrackingMeshPropertiesMSFT-type-type", XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT, "XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemHandTrackingMeshPropertiesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemHandTrackingMeshPropertiesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemHandTrackingMeshPropertiesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemHandTrackingMeshPropertiesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemHandTrackingMeshPropertiesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshSpaceCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandMeshSpaceCreateInfoMSFT",
                             value->type, "VUID-XrHandMeshSpaceCreateInfoMSFT-type-type", XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT, "XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshSpaceCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandMeshSpaceCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandMeshSpaceCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshSpaceCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandMeshSpaceCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandPoseTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandMeshSpaceCreateInfoMSFT", "handPoseType", objects_info, value->handPoseType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandMeshSpaceCreateInfoMSFT contains invalid XrHandPoseTypeMSFT \"handPoseType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->handPoseType));
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshSpaceCreateInfoMSFT-handPoseType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshUpdateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandMeshUpdateInfoMSFT",
                             value->type, "VUID-XrHandMeshUpdateInfoMSFT-type-type", XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT, "XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshUpdateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandMeshUpdateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandMeshUpdateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshUpdateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandMeshUpdateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandPoseTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandMeshUpdateInfoMSFT", "handPoseType", objects_info, value->handPoseType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandMeshUpdateInfoMSFT contains invalid XrHandPoseTypeMSFT \"handPoseType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->handPoseType));
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshUpdateInfoMSFT-handPoseType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshIndexBufferMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshIndexBufferMSFT-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandMeshIndexBufferMSFT member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHandMeshIndexBufferMSFT-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshVertexMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshVertexBufferMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshVertexBufferMSFT-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandMeshVertexBufferMSFT member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHandMeshVertexBufferMSFT-vertices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandMeshMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_MESH_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandMeshMSFT",
                             value->type, "VUID-XrHandMeshMSFT-type-type", XR_TYPE_HAND_MESH_MSFT, "XR_TYPE_HAND_MESH_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandMeshMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandMeshMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandMeshMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Validate that the structure XrHandMeshIndexBufferMSFT is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->indexBuffer);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshMSFT-indexBuffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandMeshMSFT member indexBuffer is invalid");
        return xr_result;
    }
    // Validate that the structure XrHandMeshVertexBufferMSFT is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->vertexBuffer);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandMeshMSFT-vertexBuffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandMeshMSFT member vertexBuffer is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandPoseTypeInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_POSE_TYPE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandPoseTypeInfoMSFT",
                             value->type, "VUID-XrHandPoseTypeInfoMSFT-type-type", XR_TYPE_HAND_POSE_TYPE_INFO_MSFT, "XR_TYPE_HAND_POSE_TYPE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandPoseTypeInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandPoseTypeInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandPoseTypeInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandPoseTypeInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandPoseTypeInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandPoseTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandPoseTypeInfoMSFT", "handPoseType", objects_info, value->handPoseType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandPoseTypeInfoMSFT contains invalid XrHandPoseTypeMSFT \"handPoseType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->handPoseType));
        CoreValidLogMessage(instance_info, "VUID-XrHandPoseTypeInfoMSFT-handPoseType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationSessionBeginInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationSessionBeginInfoMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationSessionBeginInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationSessionBeginInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationSessionBeginInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->viewConfigurationCount && nullptr != value->enabledViewConfigurationTypes) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-viewConfigurationCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSecondaryViewConfigurationSessionBeginInfoMSFT member viewConfigurationCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->enabledViewConfigurationTypes && 0 != value->viewConfigurationCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-enabledViewConfigurationTypes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSecondaryViewConfigurationSessionBeginInfoMSFT contains invalid NULL for XrViewConfigurationType \"enabledViewConfigurationTypes\" is which not "
                            "optional since \"viewConfigurationCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->enabledViewConfigurationTypes) {
        for (uint32_t value_enabledviewconfigurationtypes_inc = 0; value_enabledviewconfigurationtypes_inc < value->viewConfigurationCount; ++value_enabledviewconfigurationtypes_inc) {
            // Make sure the enum type XrViewConfigurationType value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrSecondaryViewConfigurationSessionBeginInfoMSFT", "enabledViewConfigurationTypes", objects_info, value->enabledViewConfigurationTypes[value_enabledviewconfigurationtypes_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrSecondaryViewConfigurationSessionBeginInfoMSFT contains invalid XrViewConfigurationType \"enabledViewConfigurationTypes\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->enabledViewConfigurationTypes[value_enabledviewconfigurationtypes_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSessionBeginInfoMSFT-enabledViewConfigurationTypes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationStateMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationStateMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationStateMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationStateMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationStateMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationStateMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationStateMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationStateMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSecondaryViewConfigurationStateMSFT", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSecondaryViewConfigurationStateMSFT contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationStateMSFT-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationFrameStateMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationFrameStateMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationFrameStateMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationFrameStateMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationFrameStateMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->viewConfigurationCount && nullptr != value->viewConfigurationStates) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-viewConfigurationCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSecondaryViewConfigurationFrameStateMSFT member viewConfigurationCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->viewConfigurationStates && 0 != value->viewConfigurationCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-viewConfigurationStates-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSecondaryViewConfigurationFrameStateMSFT contains invalid NULL for XrSecondaryViewConfigurationStateMSFT \"viewConfigurationStates\" is which not "
                            "optional since \"viewConfigurationCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->viewConfigurationStates) {
        for (uint32_t value_viewconfigurationstates_inc = 0; value_viewconfigurationstates_inc < value->viewConfigurationCount; ++value_viewconfigurationstates_inc) {
            // Validate that the structure XrSecondaryViewConfigurationStateMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->viewConfigurationStates[value_viewconfigurationstates_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameStateMSFT-viewConfigurationStates-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSecondaryViewConfigurationFrameStateMSFT member viewConfigurationStates is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationLayerInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationLayerInfoMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationLayerInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationLayerInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationLayerInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSecondaryViewConfigurationLayerInfoMSFT", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSecondaryViewConfigurationLayerInfoMSFT contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrEnvironmentBlendMode value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSecondaryViewConfigurationLayerInfoMSFT", "environmentBlendMode", objects_info, value->environmentBlendMode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSecondaryViewConfigurationLayerInfoMSFT contains invalid XrEnvironmentBlendMode \"environmentBlendMode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->environmentBlendMode));
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-environmentBlendMode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->layerCount && nullptr != value->layers) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layerCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layerCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->layers && 0 != value->layerCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSecondaryViewConfigurationLayerInfoMSFT contains invalid NULL for XrCompositionLayerBaseHeader \"layers\" is which not "
                            "optional since \"layerCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->layers) {
        for (uint32_t value_layers_inc = 0; value_layers_inc < value->layerCount; ++value_layers_inc) {
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerProjection and it is valid
            {
                const XrCompositionLayerProjection* const* new_compositionlayerprojection_value = reinterpret_cast<const XrCompositionLayerProjection* const*>(value->layers);
                if (new_compositionlayerprojection_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayerprojection_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerQuad and it is valid
            {
                const XrCompositionLayerQuad* const* new_compositionlayerquad_value = reinterpret_cast<const XrCompositionLayerQuad* const*>(value->layers);
                if (new_compositionlayerquad_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_QUAD) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayerquad_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCubeKHR and it is valid
            {
                const XrCompositionLayerCubeKHR* const* new_compositionlayercubekhr_value = reinterpret_cast<const XrCompositionLayerCubeKHR* const*>(value->layers);
                if (new_compositionlayercubekhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayercubekhr_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCylinderKHR and it is valid
            {
                const XrCompositionLayerCylinderKHR* const* new_compositionlayercylinderkhr_value = reinterpret_cast<const XrCompositionLayerCylinderKHR* const*>(value->layers);
                if (new_compositionlayercylinderkhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayercylinderkhr_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirectKHR and it is valid
            {
                const XrCompositionLayerEquirectKHR* const* new_compositionlayerequirectkhr_value = reinterpret_cast<const XrCompositionLayerEquirectKHR* const*>(value->layers);
                if (new_compositionlayerequirectkhr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayerequirectkhr_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirect2KHR and it is valid
            {
                const XrCompositionLayerEquirect2KHR* const* new_compositionlayerequirect2khr_value = reinterpret_cast<const XrCompositionLayerEquirect2KHR* const*>(value->layers);
                if (new_compositionlayerequirect2khr_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayerequirect2khr_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerPassthroughHTC and it is valid
            {
                const XrCompositionLayerPassthroughHTC* const* new_compositionlayerpassthroughhtc_value = reinterpret_cast<const XrCompositionLayerPassthroughHTC* const*>(value->layers);
                if (new_compositionlayerpassthroughhtc_value[value_layers_inc]->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
                    xr_result = ValidateXrStruct(instance_info, command_name,
                                                                    objects_info, check_members, new_compositionlayerpassthroughhtc_value[value_layers_inc]);
                    if (XR_SUCCESS != xr_result) {
                        std::string error_message = "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers";
                        error_message += "[";
                        error_message += std::to_string(value_layers_inc);
                        error_message += "]";
                        error_message += " is invalid";
                        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                            objects_info,
                                            error_message);
                        return XR_ERROR_VALIDATION_FAILURE;
                        break;
                    } else {
                        continue;
                    }
                }
            }
            // Validate that the base-structure XrCompositionLayerBaseHeader is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, value->layers[value_layers_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationLayerInfoMSFT-layers-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSecondaryViewConfigurationLayerInfoMSFT member layers is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationFrameEndInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationFrameEndInfoMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationFrameEndInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationFrameEndInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationFrameEndInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->viewConfigurationCount && nullptr != value->viewConfigurationLayersInfo) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-viewConfigurationCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSecondaryViewConfigurationFrameEndInfoMSFT member viewConfigurationCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->viewConfigurationLayersInfo && 0 != value->viewConfigurationCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-viewConfigurationLayersInfo-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSecondaryViewConfigurationFrameEndInfoMSFT contains invalid NULL for XrSecondaryViewConfigurationLayerInfoMSFT \"viewConfigurationLayersInfo\" is which not "
                            "optional since \"viewConfigurationCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->viewConfigurationLayersInfo) {
        for (uint32_t value_viewconfigurationlayersinfo_inc = 0; value_viewconfigurationlayersinfo_inc < value->viewConfigurationCount; ++value_viewconfigurationlayersinfo_inc) {
            // Validate that the structure XrSecondaryViewConfigurationLayerInfoMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->viewConfigurationLayersInfo[value_viewconfigurationlayersinfo_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationFrameEndInfoMSFT-viewConfigurationLayersInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSecondaryViewConfigurationFrameEndInfoMSFT member viewConfigurationLayersInfo is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSecondaryViewConfigurationSwapchainCreateInfoMSFT",
                             value->type, "VUID-XrSecondaryViewConfigurationSwapchainCreateInfoMSFT-type-type", XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT, "XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSwapchainCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSecondaryViewConfigurationSwapchainCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSecondaryViewConfigurationSwapchainCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSwapchainCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSecondaryViewConfigurationSwapchainCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrViewConfigurationType value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSecondaryViewConfigurationSwapchainCreateInfoMSFT", "viewConfigurationType", objects_info, value->viewConfigurationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSecondaryViewConfigurationSwapchainCreateInfoMSFT contains invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->viewConfigurationType));
        CoreValidLogMessage(instance_info, "VUID-XrSecondaryViewConfigurationSwapchainCreateInfoMSFT-viewConfigurationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelKeyStateMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrControllerModelKeyStateMSFT",
                             value->type, "VUID-XrControllerModelKeyStateMSFT-type-type", XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT, "XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelKeyStateMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrControllerModelKeyStateMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrControllerModelKeyStateMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelKeyStateMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrControllerModelKeyStateMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelNodePropertiesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrControllerModelNodePropertiesMSFT",
                             value->type, "VUID-XrControllerModelNodePropertiesMSFT-type-type", XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT, "XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodePropertiesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrControllerModelNodePropertiesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrControllerModelNodePropertiesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodePropertiesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrControllerModelNodePropertiesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT < std::strlen(value->parentNodeName)) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodePropertiesMSFT-parentNodeName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrControllerModelNodePropertiesMSFT member parentNodeName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT < std::strlen(value->nodeName)) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodePropertiesMSFT-nodeName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrControllerModelNodePropertiesMSFT member nodeName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelPropertiesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrControllerModelPropertiesMSFT",
                             value->type, "VUID-XrControllerModelPropertiesMSFT-type-type", XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT, "XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelPropertiesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrControllerModelPropertiesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrControllerModelPropertiesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelPropertiesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrControllerModelPropertiesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->nodeCapacityInput is non-zero
    if (0 != value->nodeCapacityInput && nullptr == value->nodeProperties) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelPropertiesMSFT-nodeProperties-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrControllerModelPropertiesMSFT member nodeCapacityInput is NULL, but value->nodeCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->nodeProperties) {
        for (uint32_t value_nodeproperties_inc = 0; value_nodeproperties_inc < value->nodeCapacityInput; ++value_nodeproperties_inc) {
            // Validate that the structure XrControllerModelNodePropertiesMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->nodeProperties[value_nodeproperties_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrControllerModelPropertiesMSFT-nodeProperties-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrControllerModelPropertiesMSFT member nodeProperties is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelNodeStateMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrControllerModelNodeStateMSFT",
                             value->type, "VUID-XrControllerModelNodeStateMSFT-type-type", XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT, "XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodeStateMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrControllerModelNodeStateMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrControllerModelNodeStateMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelNodeStateMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrControllerModelNodeStateMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrControllerModelStateMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_CONTROLLER_MODEL_STATE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrControllerModelStateMSFT",
                             value->type, "VUID-XrControllerModelStateMSFT-type-type", XR_TYPE_CONTROLLER_MODEL_STATE_MSFT, "XR_TYPE_CONTROLLER_MODEL_STATE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelStateMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrControllerModelStateMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrControllerModelStateMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelStateMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrControllerModelStateMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->nodeCapacityInput is non-zero
    if (0 != value->nodeCapacityInput && nullptr == value->nodeStates) {
        CoreValidLogMessage(instance_info, "VUID-XrControllerModelStateMSFT-nodeStates-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrControllerModelStateMSFT member nodeCapacityInput is NULL, but value->nodeCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->nodeStates) {
        for (uint32_t value_nodestates_inc = 0; value_nodestates_inc < value->nodeCapacityInput; ++value_nodestates_inc) {
            // Validate that the structure XrControllerModelNodeStateMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->nodeStates[value_nodestates_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrControllerModelStateMSFT-nodeStates-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrControllerModelStateMSFT member nodeStates is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewConfigurationViewFovEPIC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewConfigurationViewFovEPIC",
                             value->type, "VUID-XrViewConfigurationViewFovEPIC-type-type", XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC, "XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationViewFovEPIC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewConfigurationViewFovEPIC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewConfigurationViewFovEPIC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewConfigurationViewFovEPIC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewConfigurationViewFovEPIC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHolographicWindowAttachmentMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHolographicWindowAttachmentMSFT",
                             value->type, "VUID-XrHolographicWindowAttachmentMSFT-type-type", XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT, "XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHolographicWindowAttachmentMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHolographicWindowAttachmentMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHolographicWindowAttachmentMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHolographicWindowAttachmentMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHolographicWindowAttachmentMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->holographicSpace) {
        CoreValidLogMessage(instance_info, "VUID-XrHolographicWindowAttachmentMSFT-holographicSpace-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHolographicWindowAttachmentMSFT contains invalid NULL for IUnknown \"holographicSpace\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHolographicWindowAttachmentMSFT-holographicSpace-parameter" type
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->coreWindow) {
        CoreValidLogMessage(instance_info, "VUID-XrHolographicWindowAttachmentMSFT-coreWindow-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHolographicWindowAttachmentMSFT contains invalid NULL for IUnknown \"coreWindow\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHolographicWindowAttachmentMSFT-coreWindow-parameter" type
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerReprojectionInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerReprojectionInfoMSFT",
                             value->type, "VUID-XrCompositionLayerReprojectionInfoMSFT-type-type", XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT, "XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerReprojectionInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerReprojectionInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerReprojectionInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerReprojectionInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerReprojectionInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrReprojectionModeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerReprojectionInfoMSFT", "reprojectionMode", objects_info, value->reprojectionMode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerReprojectionInfoMSFT contains invalid XrReprojectionModeMSFT \"reprojectionMode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->reprojectionMode));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerReprojectionInfoMSFT-reprojectionMode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerReprojectionPlaneOverrideMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerReprojectionPlaneOverrideMSFT",
                             value->type, "VUID-XrCompositionLayerReprojectionPlaneOverrideMSFT-type-type", XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT, "XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerReprojectionPlaneOverrideMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerReprojectionPlaneOverrideMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerReprojectionPlaneOverrideMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerReprojectionPlaneOverrideMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerReprojectionPlaneOverrideMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrAndroidSurfaceSwapchainCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrAndroidSurfaceSwapchainCreateInfoFB",
                             value->type, "VUID-XrAndroidSurfaceSwapchainCreateInfoFB-type-type", XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB, "XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrAndroidSurfaceSwapchainCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrAndroidSurfaceSwapchainCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrAndroidSurfaceSwapchainCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrAndroidSurfaceSwapchainCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrAndroidSurfaceSwapchainCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult android_surface_swapchain_flags_fb_result = ValidateXrAndroidSurfaceSwapchainFlagsFB(value->createFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == android_surface_swapchain_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrAndroidSurfaceSwapchainCreateInfoFB-createFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrAndroidSurfaceSwapchainFlagsFB \"createFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != android_surface_swapchain_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrAndroidSurfaceSwapchainCreateInfoFB invalid member XrAndroidSurfaceSwapchainFlagsFB \"createFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->createFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrAndroidSurfaceSwapchainCreateInfoFB-createFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateBaseHeaderFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrSwapchainStateBaseHeaderFB-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrSwapchainStateBaseHeaderFB-next-next" because it is a base structure
    if (value->type == XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB) {
        const XrSwapchainStateFoveationFB* new_value = reinterpret_cast<const XrSwapchainStateFoveationFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_foveation")) {
            std::string error_str = "XrSwapchainStateBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB\"";
            error_str += " which requires extension \"XR_FB_foveation\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
    if (value->type == XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB) {
        const XrSwapchainStateAndroidSurfaceDimensionsFB* new_value = reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_android_surface")) {
            std::string error_str = "XrSwapchainStateBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB\"";
            error_str += " which requires extension \"XR_FB_swapchain_update_state_android_surface\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
    if (value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB) {
        const XrSwapchainStateSamplerOpenGLESFB* new_value = reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_opengl_es")) {
            std::string error_str = "XrSwapchainStateBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB\"";
            error_str += " which requires extension \"XR_FB_swapchain_update_state_opengl_es\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
    if (value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB) {
        const XrSwapchainStateSamplerVulkanFB* new_value = reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_swapchain_update_state_vulkan")) {
            std::string error_str = "XrSwapchainStateBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB\"";
            error_str += " which requires extension \"XR_FB_swapchain_update_state_vulkan\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
    InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainStateBaseHeaderFB",
                         value->type, "VUID-XrSwapchainStateBaseHeaderFB-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSecureContentFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerSecureContentFB",
                             value->type, "VUID-XrCompositionLayerSecureContentFB-type-type", XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB, "XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSecureContentFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerSecureContentFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerSecureContentFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSecureContentFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerSecureContentFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_secure_content_flags_fb_result = ValidateXrCompositionLayerSecureContentFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == composition_layer_secure_content_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSecureContentFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrCompositionLayerSecureContentFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != composition_layer_secure_content_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerSecureContentFB invalid member XrCompositionLayerSecureContentFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSecureContentFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointLocationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_location_flags_result = ValidateXrSpaceLocationFlags(value->locationFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == space_location_flags_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationFB-locationFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrSpaceLocationFlags \"locationFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != space_location_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrBodyJointLocationFB invalid member XrSpaceLocationFlags \"locationFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationFB-locationFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemBodyTrackingPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemBodyTrackingPropertiesFB",
                             value->type, "VUID-XrSystemBodyTrackingPropertiesFB-type-type", XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB, "XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemBodyTrackingPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemBodyTrackingPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemBodyTrackingPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemBodyTrackingPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemBodyTrackingPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyTrackerCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BODY_TRACKER_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBodyTrackerCreateInfoFB",
                             value->type, "VUID-XrBodyTrackerCreateInfoFB-type-type", XR_TYPE_BODY_TRACKER_CREATE_INFO_FB, "XR_TYPE_BODY_TRACKER_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyTrackerCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBodyTrackerCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBodyTrackerCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBodyTrackerCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBodyTrackerCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrBodyJointSetFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrBodyTrackerCreateInfoFB", "bodyJointSet", objects_info, value->bodyJointSet)) {
        std::ostringstream oss_enum;
        oss_enum << "XrBodyTrackerCreateInfoFB contains invalid XrBodyJointSetFB \"bodyJointSet\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->bodyJointSet));
        CoreValidLogMessage(instance_info, "VUID-XrBodyTrackerCreateInfoFB-bodyJointSet-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodySkeletonJointFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodySkeletonFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BODY_SKELETON_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBodySkeletonFB",
                             value->type, "VUID-XrBodySkeletonFB-type-type", XR_TYPE_BODY_SKELETON_FB, "XR_TYPE_BODY_SKELETON_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBodySkeletonFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBodySkeletonFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBodySkeletonFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBodySkeletonFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBodySkeletonFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->jointCount && nullptr != value->joints) {
        CoreValidLogMessage(instance_info, "VUID-XrBodySkeletonFB-jointCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrBodySkeletonFB member jointCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->joints && 0 != value->jointCount) {
        CoreValidLogMessage(instance_info, "VUID-XrBodySkeletonFB-joints-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrBodySkeletonFB contains invalid NULL for XrBodySkeletonJointFB \"joints\" is which not "
                            "optional since \"jointCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrBodySkeletonFB-joints-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointsLocateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBodyJointsLocateInfoFB",
                             value->type, "VUID-XrBodyJointsLocateInfoFB-type-type", XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB, "XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointsLocateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBodyJointsLocateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBodyJointsLocateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointsLocateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBodyJointsLocateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrBodyJointsLocateInfoFB-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBodyJointLocationsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BODY_JOINT_LOCATIONS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBodyJointLocationsFB",
                             value->type, "VUID-XrBodyJointLocationsFB-type-type", XR_TYPE_BODY_JOINT_LOCATIONS_FB, "XR_TYPE_BODY_JOINT_LOCATIONS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBodyJointLocationsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBodyJointLocationsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBodyJointLocationsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->jointCount && nullptr != value->jointLocations) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationsFB-jointCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrBodyJointLocationsFB member jointCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->jointLocations && 0 != value->jointCount) {
        CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationsFB-jointLocations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrBodyJointLocationsFB contains invalid NULL for XrBodyJointLocationFB \"jointLocations\" is which not "
                            "optional since \"jointCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->jointLocations) {
        for (uint32_t value_jointlocations_inc = 0; value_jointlocations_inc < value->jointCount; ++value_jointlocations_inc) {
            // Validate that the structure XrBodyJointLocationFB is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->jointLocations[value_jointlocations_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrBodyJointLocationsFB-jointLocations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrBodyJointLocationsFB member jointLocations is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileDpadBindingEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInteractionProfileDpadBindingEXT",
                             value->type, "VUID-XrInteractionProfileDpadBindingEXT-type-type", XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT, "XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInteractionProfileDpadBindingEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInteractionProfileDpadBindingEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInteractionProfileDpadBindingEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&value->actionSet);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrActionSet handle \"actionSet\" ";
            oss << HandleToHexString(value->actionSet);
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-actionSet-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticVibration and it is valid
    {
        const XrHapticVibration* new_hapticvibration_value = reinterpret_cast<const XrHapticVibration*>(value->onHaptic);
        if (new_hapticvibration_value->type == XR_TYPE_HAPTIC_VIBRATION) {
            if (nullptr != new_hapticvibration_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticvibration_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticAmplitudeEnvelopeVibrationFB and it is valid
    {
        const XrHapticAmplitudeEnvelopeVibrationFB* new_hapticamplitudeenvelopevibrationfb_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value->onHaptic);
        if (new_hapticamplitudeenvelopevibrationfb_value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
            if (nullptr != new_hapticamplitudeenvelopevibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticamplitudeenvelopevibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticPcmVibrationFB and it is valid
    {
        const XrHapticPcmVibrationFB* new_hapticpcmvibrationfb_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value->onHaptic);
        if (new_hapticpcmvibrationfb_value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
            if (nullptr != new_hapticpcmvibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticpcmvibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrHapticBaseHeader is valid
    if (nullptr != value->onHaptic) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->onHaptic);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-onHaptic-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrInteractionProfileDpadBindingEXT member onHaptic is invalid");
            return xr_result;
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticVibration and it is valid
    {
        const XrHapticVibration* new_hapticvibration_value = reinterpret_cast<const XrHapticVibration*>(value->offHaptic);
        if (new_hapticvibration_value->type == XR_TYPE_HAPTIC_VIBRATION) {
            if (nullptr != new_hapticvibration_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticvibration_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticAmplitudeEnvelopeVibrationFB and it is valid
    {
        const XrHapticAmplitudeEnvelopeVibrationFB* new_hapticamplitudeenvelopevibrationfb_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value->offHaptic);
        if (new_hapticamplitudeenvelopevibrationfb_value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
            if (nullptr != new_hapticamplitudeenvelopevibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticamplitudeenvelopevibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticPcmVibrationFB and it is valid
    {
        const XrHapticPcmVibrationFB* new_hapticpcmvibrationfb_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value->offHaptic);
        if (new_hapticpcmvibrationfb_value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
            if (nullptr != new_hapticpcmvibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticpcmvibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileDpadBindingEXT member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrHapticBaseHeader is valid
    if (nullptr != value->offHaptic) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->offHaptic);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileDpadBindingEXT-offHaptic-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrInteractionProfileDpadBindingEXT member offHaptic is invalid");
            return xr_result;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrInteractionProfileAnalogThresholdVALVE* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrInteractionProfileAnalogThresholdVALVE",
                             value->type, "VUID-XrInteractionProfileAnalogThresholdVALVE-type-type", XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE, "XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrInteractionProfileAnalogThresholdVALVE struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrInteractionProfileAnalogThresholdVALVE : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrInteractionProfileAnalogThresholdVALVE struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionHandle(&value->action);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrAction handle \"action\" ";
            oss << HandleToHexString(value->action);
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticVibration and it is valid
    {
        const XrHapticVibration* new_hapticvibration_value = reinterpret_cast<const XrHapticVibration*>(value->onHaptic);
        if (new_hapticvibration_value->type == XR_TYPE_HAPTIC_VIBRATION) {
            if (nullptr != new_hapticvibration_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticvibration_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticAmplitudeEnvelopeVibrationFB and it is valid
    {
        const XrHapticAmplitudeEnvelopeVibrationFB* new_hapticamplitudeenvelopevibrationfb_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value->onHaptic);
        if (new_hapticamplitudeenvelopevibrationfb_value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
            if (nullptr != new_hapticamplitudeenvelopevibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticamplitudeenvelopevibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticPcmVibrationFB and it is valid
    {
        const XrHapticPcmVibrationFB* new_hapticpcmvibrationfb_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value->onHaptic);
        if (new_hapticpcmvibrationfb_value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
            if (nullptr != new_hapticpcmvibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticpcmvibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member onHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-onHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrHapticBaseHeader is valid
    if (nullptr != value->onHaptic) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->onHaptic);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-onHaptic-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrInteractionProfileAnalogThresholdVALVE member onHaptic is invalid");
            return xr_result;
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticVibration and it is valid
    {
        const XrHapticVibration* new_hapticvibration_value = reinterpret_cast<const XrHapticVibration*>(value->offHaptic);
        if (new_hapticvibration_value->type == XR_TYPE_HAPTIC_VIBRATION) {
            if (nullptr != new_hapticvibration_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticvibration_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticAmplitudeEnvelopeVibrationFB and it is valid
    {
        const XrHapticAmplitudeEnvelopeVibrationFB* new_hapticamplitudeenvelopevibrationfb_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(value->offHaptic);
        if (new_hapticamplitudeenvelopevibrationfb_value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
            if (nullptr != new_hapticamplitudeenvelopevibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticamplitudeenvelopevibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrHapticBaseHeader is a child structure of type XrHapticPcmVibrationFB and it is valid
    {
        const XrHapticPcmVibrationFB* new_hapticpcmvibrationfb_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(value->offHaptic);
        if (new_hapticpcmvibrationfb_value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
            if (nullptr != new_hapticpcmvibrationfb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_hapticpcmvibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrInteractionProfileAnalogThresholdVALVE member offHaptic";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-offHaptic-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrHapticBaseHeader is valid
    if (nullptr != value->offHaptic) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->offHaptic);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrInteractionProfileAnalogThresholdVALVE-offHaptic-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrInteractionProfileAnalogThresholdVALVE member offHaptic is invalid");
            return xr_result;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandJointsMotionRangeInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandJointsMotionRangeInfoEXT",
                             value->type, "VUID-XrHandJointsMotionRangeInfoEXT-type-type", XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT, "XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandJointsMotionRangeInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandJointsMotionRangeInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandJointsMotionRangeInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandJointsMotionRangeInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandJointsMotionRangeInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandJointsMotionRangeEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandJointsMotionRangeInfoEXT", "handJointsMotionRange", objects_info, value->handJointsMotionRange)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandJointsMotionRangeInfoEXT contains invalid XrHandJointsMotionRangeEXT \"handJointsMotionRange\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->handJointsMotionRange));
        CoreValidLogMessage(instance_info, "VUID-XrHandJointsMotionRangeInfoEXT-handJointsMotionRange-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUuidMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObserverCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneObserverCreateInfoMSFT",
                             value->type, "VUID-XrSceneObserverCreateInfoMSFT-type-type", XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT, "XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneObserverCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneObserverCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneObserverCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneObserverCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneObserverCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneCreateInfoMSFT",
                             value->type, "VUID-XrSceneCreateInfoMSFT-type-type", XR_TYPE_SCENE_CREATE_INFO_MSFT, "XR_TYPE_SCENE_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneSphereBoundMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneOrientedBoxBoundMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneFrustumBoundMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneBoundsMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSceneBoundsMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Optional array must be non-NULL when value->sphereCount is non-zero
    if (0 != value->sphereCount && nullptr == value->spheres) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneBoundsMSFT-spheres-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneBoundsMSFT member sphereCount is NULL, but value->sphereCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneBoundsMSFT-spheres-parameter" type
    // Optional array must be non-NULL when value->boxCount is non-zero
    if (0 != value->boxCount && nullptr == value->boxes) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneBoundsMSFT-boxes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneBoundsMSFT member boxCount is NULL, but value->boxCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneBoundsMSFT-boxes-parameter" type
    // Optional array must be non-NULL when value->frustumCount is non-zero
    if (0 != value->frustumCount && nullptr == value->frustums) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneBoundsMSFT-frustums-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneBoundsMSFT member frustumCount is NULL, but value->frustumCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneBoundsMSFT-frustums-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrNewSceneComputeInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrNewSceneComputeInfoMSFT",
                             value->type, "VUID-XrNewSceneComputeInfoMSFT-type-type", XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT, "XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrNewSceneComputeInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrNewSceneComputeInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrNewSceneComputeInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->requestedFeatureCount && nullptr != value->requestedFeatures) {
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-requestedFeatureCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrNewSceneComputeInfoMSFT member requestedFeatureCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->requestedFeatures && 0 != value->requestedFeatureCount) {
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-requestedFeatures-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrNewSceneComputeInfoMSFT contains invalid NULL for XrSceneComputeFeatureMSFT \"requestedFeatures\" is which not "
                            "optional since \"requestedFeatureCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->requestedFeatures) {
        for (uint32_t value_requestedfeatures_inc = 0; value_requestedfeatures_inc < value->requestedFeatureCount; ++value_requestedfeatures_inc) {
            // Make sure the enum type XrSceneComputeFeatureMSFT value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrNewSceneComputeInfoMSFT", "requestedFeatures", objects_info, value->requestedFeatures[value_requestedfeatures_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrNewSceneComputeInfoMSFT contains invalid XrSceneComputeFeatureMSFT \"requestedFeatures\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->requestedFeatures[value_requestedfeatures_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-requestedFeatures-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Make sure the enum type XrSceneComputeConsistencyMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrNewSceneComputeInfoMSFT", "consistency", objects_info, value->consistency)) {
        std::ostringstream oss_enum;
        oss_enum << "XrNewSceneComputeInfoMSFT contains invalid XrSceneComputeConsistencyMSFT \"consistency\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->consistency));
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-consistency-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSceneBoundsMSFT is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->bounds);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrNewSceneComputeInfoMSFT-bounds-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrNewSceneComputeInfoMSFT member bounds is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVisualMeshComputeLodInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVisualMeshComputeLodInfoMSFT",
                             value->type, "VUID-XrVisualMeshComputeLodInfoMSFT-type-type", XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT, "XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVisualMeshComputeLodInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVisualMeshComputeLodInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVisualMeshComputeLodInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVisualMeshComputeLodInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVisualMeshComputeLodInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMeshComputeLodMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrVisualMeshComputeLodInfoMSFT", "lod", objects_info, value->lod)) {
        std::ostringstream oss_enum;
        oss_enum << "XrVisualMeshComputeLodInfoMSFT contains invalid XrMeshComputeLodMSFT \"lod\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->lod));
        CoreValidLogMessage(instance_info, "VUID-XrVisualMeshComputeLodInfoMSFT-lod-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSceneComponentTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSceneComponentMSFT", "componentType", objects_info, value->componentType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSceneComponentMSFT contains invalid XrSceneComponentTypeMSFT \"componentType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->componentType));
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentMSFT-componentType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_COMPONENTS_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneComponentsMSFT",
                             value->type, "VUID-XrSceneComponentsMSFT-type-type", XR_TYPE_SCENE_COMPONENTS_MSFT, "XR_TYPE_SCENE_COMPONENTS_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SCENE_MARKER_QR_CODES_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_MARKERS_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_MESHES_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_OBJECTS_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_PLANES_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneComponentsMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneComponentsMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneComponentsMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->componentCapacityInput is non-zero
    if (0 != value->componentCapacityInput && nullptr == value->components) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsMSFT-components-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneComponentsMSFT member componentCapacityInput is NULL, but value->componentCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->components) {
        for (uint32_t value_components_inc = 0; value_components_inc < value->componentCapacityInput; ++value_components_inc) {
            // Validate that the structure XrSceneComponentMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->components[value_components_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsMSFT-components-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneComponentsMSFT member components is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsGetInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneComponentsGetInfoMSFT",
                             value->type, "VUID-XrSceneComponentsGetInfoMSFT-type-type", XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT, "XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT);
    valid_ext_structs.push_back(XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsGetInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneComponentsGetInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneComponentsGetInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsGetInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneComponentsGetInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSceneComponentTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSceneComponentsGetInfoMSFT", "componentType", objects_info, value->componentType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSceneComponentsGetInfoMSFT contains invalid XrSceneComponentTypeMSFT \"componentType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->componentType));
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsGetInfoMSFT-componentType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentLocationMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_location_flags_result = ValidateXrSpaceLocationFlags(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == space_location_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSceneComponentLocationMSFT invalid member XrSpaceLocationFlags \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentLocationMSFT-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentLocationsMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneComponentLocationsMSFT",
                             value->type, "VUID-XrSceneComponentLocationsMSFT-type-type", XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT, "XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentLocationsMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneComponentLocationsMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneComponentLocationsMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentLocationsMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneComponentLocationsMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->locationCount is non-zero
    if (0 != value->locationCount && nullptr == value->locations) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentLocationsMSFT-locations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneComponentLocationsMSFT member locationCount is NULL, but value->locationCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->locations) {
        for (uint32_t value_locations_inc = 0; value_locations_inc < value->locationCount; ++value_locations_inc) {
            // Validate that the structure XrSceneComponentLocationMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->locations[value_locations_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneComponentLocationsMSFT-locations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneComponentLocationsMSFT member locations is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentsLocateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneComponentsLocateInfoMSFT",
                             value->type, "VUID-XrSceneComponentsLocateInfoMSFT-type-type", XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT, "XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsLocateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneComponentsLocateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneComponentsLocateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsLocateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneComponentsLocateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsLocateInfoMSFT-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Optional array must be non-NULL when value->componentIdCount is non-zero
    if (0 != value->componentIdCount && nullptr == value->componentIds) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentsLocateInfoMSFT-componentIds-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneComponentsLocateInfoMSFT member componentIdCount is NULL, but value->componentIdCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneComponentsLocateInfoMSFT-componentIds-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSceneObjectTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSceneObjectMSFT", "objectType", objects_info, value->objectType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSceneObjectMSFT contains invalid XrSceneObjectTypeMSFT \"objectType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->objectType));
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectMSFT-objectType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectsMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_OBJECTS_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneObjectsMSFT",
                             value->type, "VUID-XrSceneObjectsMSFT-type-type", XR_TYPE_SCENE_OBJECTS_MSFT, "XR_TYPE_SCENE_OBJECTS_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectsMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneObjectsMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneObjectsMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectsMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneObjectsMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->sceneObjectCount is non-zero
    if (0 != value->sceneObjectCount && nullptr == value->sceneObjects) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectsMSFT-sceneObjects-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneObjectsMSFT member sceneObjectCount is NULL, but value->sceneObjectCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->sceneObjects) {
        for (uint32_t value_sceneobjects_inc = 0; value_sceneobjects_inc < value->sceneObjectCount; ++value_sceneobjects_inc) {
            // Validate that the structure XrSceneObjectMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->sceneObjects[value_sceneobjects_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneObjectsMSFT-sceneObjects-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneObjectsMSFT member sceneObjects is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneComponentParentFilterInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneComponentParentFilterInfoMSFT",
                             value->type, "VUID-XrSceneComponentParentFilterInfoMSFT-type-type", XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT, "XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentParentFilterInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneComponentParentFilterInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneComponentParentFilterInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneComponentParentFilterInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneComponentParentFilterInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneObjectTypesFilterInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneObjectTypesFilterInfoMSFT",
                             value->type, "VUID-XrSceneObjectTypesFilterInfoMSFT-type-type", XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT, "XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectTypesFilterInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneObjectTypesFilterInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneObjectTypesFilterInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectTypesFilterInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneObjectTypesFilterInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->objectTypeCount is non-zero
    if (0 != value->objectTypeCount && nullptr == value->objectTypes) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneObjectTypesFilterInfoMSFT-objectTypes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneObjectTypesFilterInfoMSFT member objectTypeCount is NULL, but value->objectTypeCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->objectTypes) {
        for (uint32_t value_objecttypes_inc = 0; value_objecttypes_inc < value->objectTypeCount; ++value_objecttypes_inc) {
            // Make sure the enum type XrSceneObjectTypeMSFT value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrSceneObjectTypesFilterInfoMSFT", "objectTypes", objects_info, value->objectTypes[value_objecttypes_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrSceneObjectTypesFilterInfoMSFT contains invalid XrSceneObjectTypeMSFT \"objectTypes\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->objectTypes[value_objecttypes_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrSceneObjectTypesFilterInfoMSFT-objectTypes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlaneMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrScenePlaneAlignmentTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrScenePlaneMSFT", "alignment", objects_info, value->alignment)) {
        std::ostringstream oss_enum;
        oss_enum << "XrScenePlaneMSFT contains invalid XrScenePlaneAlignmentTypeMSFT \"alignment\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->alignment));
        CoreValidLogMessage(instance_info, "VUID-XrScenePlaneMSFT-alignment-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlanesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_PLANES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrScenePlanesMSFT",
                             value->type, "VUID-XrScenePlanesMSFT-type-type", XR_TYPE_SCENE_PLANES_MSFT, "XR_TYPE_SCENE_PLANES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrScenePlanesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrScenePlanesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrScenePlanesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrScenePlanesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrScenePlanesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->scenePlaneCount is non-zero
    if (0 != value->scenePlaneCount && nullptr == value->scenePlanes) {
        CoreValidLogMessage(instance_info, "VUID-XrScenePlanesMSFT-scenePlanes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrScenePlanesMSFT member scenePlaneCount is NULL, but value->scenePlaneCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->scenePlanes) {
        for (uint32_t value_sceneplanes_inc = 0; value_sceneplanes_inc < value->scenePlaneCount; ++value_sceneplanes_inc) {
            // Validate that the structure XrScenePlaneMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->scenePlanes[value_sceneplanes_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrScenePlanesMSFT-scenePlanes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrScenePlanesMSFT member scenePlanes is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrScenePlaneAlignmentFilterInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrScenePlaneAlignmentFilterInfoMSFT",
                             value->type, "VUID-XrScenePlaneAlignmentFilterInfoMSFT-type-type", XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT, "XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrScenePlaneAlignmentFilterInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrScenePlaneAlignmentFilterInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrScenePlaneAlignmentFilterInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrScenePlaneAlignmentFilterInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrScenePlaneAlignmentFilterInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->alignmentCount is non-zero
    if (0 != value->alignmentCount && nullptr == value->alignments) {
        CoreValidLogMessage(instance_info, "VUID-XrScenePlaneAlignmentFilterInfoMSFT-alignments-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrScenePlaneAlignmentFilterInfoMSFT member alignmentCount is NULL, but value->alignmentCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->alignments) {
        for (uint32_t value_alignments_inc = 0; value_alignments_inc < value->alignmentCount; ++value_alignments_inc) {
            // Make sure the enum type XrScenePlaneAlignmentTypeMSFT value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrScenePlaneAlignmentFilterInfoMSFT", "alignments", objects_info, value->alignments[value_alignments_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrScenePlaneAlignmentFilterInfoMSFT contains invalid XrScenePlaneAlignmentTypeMSFT \"alignments\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->alignments[value_alignments_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrScenePlaneAlignmentFilterInfoMSFT-alignments-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESHES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshesMSFT",
                             value->type, "VUID-XrSceneMeshesMSFT-type-type", XR_TYPE_SCENE_MESHES_MSFT, "XR_TYPE_SCENE_MESHES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->sceneMeshCount is non-zero
    if (0 != value->sceneMeshCount && nullptr == value->sceneMeshes) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshesMSFT-sceneMeshes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMeshesMSFT member sceneMeshCount is NULL, but value->sceneMeshCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->sceneMeshes) {
        for (uint32_t value_scenemeshes_inc = 0; value_scenemeshes_inc < value->sceneMeshCount; ++value_scenemeshes_inc) {
            // Validate that the structure XrSceneMeshMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->sceneMeshes[value_scenemeshes_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneMeshesMSFT-sceneMeshes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneMeshesMSFT member sceneMeshes is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshBuffersGetInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshBuffersGetInfoMSFT",
                             value->type, "VUID-XrSceneMeshBuffersGetInfoMSFT-type-type", XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT, "XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshBuffersGetInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshBuffersGetInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshBuffersGetInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshBuffersGetInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshBuffersGetInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshBuffersMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESH_BUFFERS_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshBuffersMSFT",
                             value->type, "VUID-XrSceneMeshBuffersMSFT-type-type", XR_TYPE_SCENE_MESH_BUFFERS_MSFT, "XR_TYPE_SCENE_MESH_BUFFERS_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshBuffersMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshBuffersMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshBuffersMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshBuffersMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshBuffersMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshVertexBufferMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshVertexBufferMSFT",
                             value->type, "VUID-XrSceneMeshVertexBufferMSFT-type-type", XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT, "XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshVertexBufferMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshVertexBufferMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshVertexBufferMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshVertexBufferMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshVertexBufferMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshVertexBufferMSFT-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMeshVertexBufferMSFT member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneMeshVertexBufferMSFT-vertices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshIndicesUint32MSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshIndicesUint32MSFT",
                             value->type, "VUID-XrSceneMeshIndicesUint32MSFT-type-type", XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT, "XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint32MSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshIndicesUint32MSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshIndicesUint32MSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint32MSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshIndicesUint32MSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint32MSFT-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMeshIndicesUint32MSFT member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneMeshIndicesUint32MSFT-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMeshIndicesUint16MSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMeshIndicesUint16MSFT",
                             value->type, "VUID-XrSceneMeshIndicesUint16MSFT-type-type", XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT, "XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint16MSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMeshIndicesUint16MSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMeshIndicesUint16MSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint16MSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMeshIndicesUint16MSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMeshIndicesUint16MSFT-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMeshIndicesUint16MSFT member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneMeshIndicesUint16MSFT-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSerializedSceneFragmentDataGetInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSerializedSceneFragmentDataGetInfoMSFT",
                             value->type, "VUID-XrSerializedSceneFragmentDataGetInfoMSFT-type-type", XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT, "XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSerializedSceneFragmentDataGetInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSerializedSceneFragmentDataGetInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSerializedSceneFragmentDataGetInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSerializedSceneFragmentDataGetInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSerializedSceneFragmentDataGetInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDeserializeSceneFragmentMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->bufferSize is non-zero
    if (0 != value->bufferSize && nullptr == value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrDeserializeSceneFragmentMSFT-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrDeserializeSceneFragmentMSFT member bufferSize is NULL, but value->bufferSize is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrDeserializeSceneFragmentMSFT-buffer-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneDeserializeInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneDeserializeInfoMSFT",
                             value->type, "VUID-XrSceneDeserializeInfoMSFT-type-type", XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT, "XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneDeserializeInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneDeserializeInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneDeserializeInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneDeserializeInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneDeserializeInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->fragmentCount is non-zero
    if (0 != value->fragmentCount && nullptr == value->fragments) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneDeserializeInfoMSFT-fragments-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneDeserializeInfoMSFT member fragmentCount is NULL, but value->fragmentCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->fragments) {
        for (uint32_t value_fragments_inc = 0; value_fragments_inc < value->fragmentCount; ++value_fragments_inc) {
            // Validate that the structure XrDeserializeSceneFragmentMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->fragments[value_fragments_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneDeserializeInfoMSFT-fragments-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneDeserializeInfoMSFT member fragments is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataDisplayRefreshRateChangedFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataDisplayRefreshRateChangedFB",
                             value->type, "VUID-XrEventDataDisplayRefreshRateChangedFB-type-type", XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB, "XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataDisplayRefreshRateChangedFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataDisplayRefreshRateChangedFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataDisplayRefreshRateChangedFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataDisplayRefreshRateChangedFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataDisplayRefreshRateChangedFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViveTrackerPathsHTCX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIVE_TRACKER_PATHS_HTCX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViveTrackerPathsHTCX",
                             value->type, "VUID-XrViveTrackerPathsHTCX-type-type", XR_TYPE_VIVE_TRACKER_PATHS_HTCX, "XR_TYPE_VIVE_TRACKER_PATHS_HTCX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViveTrackerPathsHTCX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViveTrackerPathsHTCX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViveTrackerPathsHTCX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViveTrackerPathsHTCX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViveTrackerPathsHTCX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataViveTrackerConnectedHTCX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataViveTrackerConnectedHTCX",
                             value->type, "VUID-XrEventDataViveTrackerConnectedHTCX-type-type", XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX, "XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataViveTrackerConnectedHTCX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataViveTrackerConnectedHTCX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataViveTrackerConnectedHTCX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataViveTrackerConnectedHTCX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataViveTrackerConnectedHTCX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->paths) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataViveTrackerConnectedHTCX-paths-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrEventDataViveTrackerConnectedHTCX contains invalid NULL for XrViveTrackerPathsHTCX \"paths\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrViveTrackerPathsHTCX is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, value->paths);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataViveTrackerConnectedHTCX-paths-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrEventDataViveTrackerConnectedHTCX member paths is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFacialTrackingPropertiesHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemFacialTrackingPropertiesHTC",
                             value->type, "VUID-XrSystemFacialTrackingPropertiesHTC-type-type", XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC, "XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemFacialTrackingPropertiesHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemFacialTrackingPropertiesHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemFacialTrackingPropertiesHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemFacialTrackingPropertiesHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemFacialTrackingPropertiesHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFacialExpressionsHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACIAL_EXPRESSIONS_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFacialExpressionsHTC",
                             value->type, "VUID-XrFacialExpressionsHTC-type-type", XR_TYPE_FACIAL_EXPRESSIONS_HTC, "XR_TYPE_FACIAL_EXPRESSIONS_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFacialExpressionsHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFacialExpressionsHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFacialExpressionsHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFacialExpressionsHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFacialExpressionsHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->expressionWeightings) {
        CoreValidLogMessage(instance_info, "VUID-XrFacialExpressionsHTC-expressionWeightings-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFacialExpressionsHTC contains invalid NULL for float \"expressionWeightings\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrFacialExpressionsHTC-expressionWeightings-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFacialTrackerCreateInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFacialTrackerCreateInfoHTC",
                             value->type, "VUID-XrFacialTrackerCreateInfoHTC-type-type", XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC, "XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFacialTrackerCreateInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFacialTrackerCreateInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFacialTrackerCreateInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFacialTrackerCreateInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFacialTrackerCreateInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFacialTrackingTypeHTC value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFacialTrackerCreateInfoHTC", "facialTrackingType", objects_info, value->facialTrackingType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFacialTrackerCreateInfoHTC contains invalid XrFacialTrackingTypeHTC \"facialTrackingType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->facialTrackingType));
        CoreValidLogMessage(instance_info, "VUID-XrFacialTrackerCreateInfoHTC-facialTrackingType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemColorSpacePropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemColorSpacePropertiesFB",
                             value->type, "VUID-XrSystemColorSpacePropertiesFB-type-type", XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB, "XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemColorSpacePropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemColorSpacePropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemColorSpacePropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemColorSpacePropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemColorSpacePropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrColorSpaceFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSystemColorSpacePropertiesFB", "colorSpace", objects_info, value->colorSpace)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSystemColorSpacePropertiesFB contains invalid XrColorSpaceFB \"colorSpace\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->colorSpace));
        CoreValidLogMessage(instance_info, "VUID-XrSystemColorSpacePropertiesFB-colorSpace-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVector4sFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingMeshFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_MESH_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingMeshFB",
                             value->type, "VUID-XrHandTrackingMeshFB-type-type", XR_TYPE_HAND_TRACKING_MESH_FB, "XR_TYPE_HAND_TRACKING_MESH_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingMeshFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingMeshFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingMeshFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingMeshFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingMeshFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->jointCapacityInput is non-zero
    if (0 != value->jointCapacityInput && nullptr == value->jointParents) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingMeshFB-jointParents-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandTrackingMeshFB member jointCapacityInput is NULL, but value->jointCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-jointBindPoses-parameter" type
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-jointRadii-parameter" type
            // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-jointParents-parameter" output enum buffer
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertexBlendWeights) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingMeshFB-vertexBlendWeights-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandTrackingMeshFB member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-vertexPositions-parameter" type
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-vertexNormals-parameter" type
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-vertexUVs-parameter" type
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-vertexBlendIndices-parameter" type
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-vertexBlendWeights-parameter" type
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingMeshFB-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandTrackingMeshFB member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHandTrackingMeshFB-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingScaleFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_SCALE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingScaleFB",
                             value->type, "VUID-XrHandTrackingScaleFB-type-type", XR_TYPE_HAND_TRACKING_SCALE_FB, "XR_TYPE_HAND_TRACKING_SCALE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingScaleFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingScaleFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingScaleFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingScaleFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingScaleFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingAimStateFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_AIM_STATE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingAimStateFB",
                             value->type, "VUID-XrHandTrackingAimStateFB-type-type", XR_TYPE_HAND_TRACKING_AIM_STATE_FB, "XR_TYPE_HAND_TRACKING_AIM_STATE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingAimStateFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingAimStateFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingAimStateFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingAimStateFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingAimStateFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult hand_tracking_aim_flags_fb_result = ValidateXrHandTrackingAimFlagsFB(value->status);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == hand_tracking_aim_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingAimStateFB-status-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrHandTrackingAimFlagsFB \"status\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != hand_tracking_aim_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrHandTrackingAimStateFB invalid member XrHandTrackingAimFlagsFB \"status\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->status));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingAimStateFB-status-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandCapsuleFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandJointEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandCapsuleFB", "joint", objects_info, value->joint)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandCapsuleFB contains invalid XrHandJointEXT \"joint\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->joint));
        CoreValidLogMessage(instance_info, "VUID-XrHandCapsuleFB-joint-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingCapsulesStateFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingCapsulesStateFB",
                             value->type, "VUID-XrHandTrackingCapsulesStateFB-type-type", XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB, "XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingCapsulesStateFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingCapsulesStateFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingCapsulesStateFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingCapsulesStateFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingCapsulesStateFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    for (uint32_t value_capsules_inc = 0; value_capsules_inc < XR_HAND_TRACKING_CAPSULE_COUNT_FB; ++value_capsules_inc) {
        // Validate that the structure XrHandCapsuleFB is valid
        xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                        check_members, &value->capsules[value_capsules_inc]);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrHandTrackingCapsulesStateFB-capsules-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrHandTrackingCapsulesStateFB member capsules is invalid");
            return xr_result;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemSpatialEntityPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemSpatialEntityPropertiesFB",
                             value->type, "VUID-XrSystemSpatialEntityPropertiesFB-type-type", XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB, "XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemSpatialEntityPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemSpatialEntityPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemSpatialEntityPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemSpatialEntityPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemSpatialEntityPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorCreateInfoFB",
                             value->type, "VUID-XrSpatialAnchorCreateInfoFB-type-type", XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB, "XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentStatusSetInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceComponentStatusSetInfoFB",
                             value->type, "VUID-XrSpaceComponentStatusSetInfoFB-type-type", XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB, "XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentStatusSetInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceComponentStatusSetInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceComponentStatusSetInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentStatusSetInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceComponentStatusSetInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSpaceComponentTypeFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceComponentStatusSetInfoFB", "componentType", objects_info, value->componentType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceComponentStatusSetInfoFB contains invalid XrSpaceComponentTypeFB \"componentType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->componentType));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentStatusSetInfoFB-componentType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentStatusFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_COMPONENT_STATUS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceComponentStatusFB",
                             value->type, "VUID-XrSpaceComponentStatusFB-type-type", XR_TYPE_SPACE_COMPONENT_STATUS_FB, "XR_TYPE_SPACE_COMPONENT_STATUS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentStatusFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceComponentStatusFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceComponentStatusFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentStatusFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceComponentStatusFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUuidEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpatialAnchorCreateCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpatialAnchorCreateCompleteFB",
                             value->type, "VUID-XrEventDataSpatialAnchorCreateCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpatialAnchorCreateCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpatialAnchorCreateCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpatialAnchorCreateCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpatialAnchorCreateCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpatialAnchorCreateCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpatialAnchorCreateCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpatialAnchorCreateCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpatialAnchorCreateCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataSpatialAnchorCreateCompleteFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceSetStatusCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceSetStatusCompleteFB",
                             value->type, "VUID-XrEventDataSpaceSetStatusCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSetStatusCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceSetStatusCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceSetStatusCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSetStatusCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceSetStatusCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceSetStatusCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceSetStatusCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSetStatusCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSetStatusCompleteFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSpaceComponentTypeFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceSetStatusCompleteFB", "componentType", objects_info, value->componentType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceSetStatusCompleteFB contains invalid XrSpaceComponentTypeFB \"componentType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->componentType));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSetStatusCompleteFB-componentType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationProfileCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationProfileCreateInfoFB",
                             value->type, "VUID-XrFoveationProfileCreateInfoFB-type-type", XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB, "XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationProfileCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationProfileCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationProfileCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationProfileCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationProfileCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainCreateInfoFoveationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainCreateInfoFoveationFB",
                             value->type, "VUID-XrSwapchainCreateInfoFoveationFB-type-type", XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB, "XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfoFoveationFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainCreateInfoFoveationFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainCreateInfoFoveationFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfoFoveationFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainCreateInfoFoveationFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult swapchain_create_foveation_flags_fb_result = ValidateXrSwapchainCreateFoveationFlagsFB(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == swapchain_create_foveation_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSwapchainCreateInfoFoveationFB invalid member XrSwapchainCreateFoveationFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainCreateInfoFoveationFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateFoveationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainStateFoveationFB",
                             value->type, "VUID-XrSwapchainStateFoveationFB-type-type", XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB, "XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateFoveationFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainStateFoveationFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainStateFoveationFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateFoveationFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainStateFoveationFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult swapchain_state_foveation_flags_fb_result = ValidateXrSwapchainStateFoveationFlagsFB(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == swapchain_state_foveation_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSwapchainStateFoveationFB invalid member XrSwapchainStateFoveationFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateFoveationFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrFoveationProfileFBHandle(&value->profile);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrFoveationProfileFB handle \"profile\" ";
            oss << HandleToHexString(value->profile);
            CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateFoveationFB-profile-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationLevelProfileCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationLevelProfileCreateInfoFB",
                             value->type, "VUID-XrFoveationLevelProfileCreateInfoFB-type-type", XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB, "XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationLevelProfileCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationLevelProfileCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationLevelProfileCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationLevelProfileCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationLevelProfileCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFoveationLevelFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFoveationLevelProfileCreateInfoFB", "level", objects_info, value->level)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationLevelProfileCreateInfoFB contains invalid XrFoveationLevelFB \"level\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->level));
        CoreValidLogMessage(instance_info, "VUID-XrFoveationLevelProfileCreateInfoFB-level-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrFoveationDynamicFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFoveationLevelProfileCreateInfoFB", "dynamic", objects_info, value->dynamic)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationLevelProfileCreateInfoFB contains invalid XrFoveationDynamicFB \"dynamic\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dynamic));
        CoreValidLogMessage(instance_info, "VUID-XrFoveationLevelProfileCreateInfoFB-dynamic-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemKeyboardTrackingPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemKeyboardTrackingPropertiesFB",
                             value->type, "VUID-XrSystemKeyboardTrackingPropertiesFB-type-type", XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB, "XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemKeyboardTrackingPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemKeyboardTrackingPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemKeyboardTrackingPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemKeyboardTrackingPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemKeyboardTrackingPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardTrackingDescriptionFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult keyboard_tracking_flags_fb_result = ValidateXrKeyboardTrackingFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == keyboard_tracking_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingDescriptionFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrKeyboardTrackingFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != keyboard_tracking_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrKeyboardTrackingDescriptionFB invalid member XrKeyboardTrackingFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingDescriptionFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB < std::strlen(value->name)) {
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingDescriptionFB-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrKeyboardTrackingDescriptionFB member name length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardSpaceCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrKeyboardSpaceCreateInfoFB",
                             value->type, "VUID-XrKeyboardSpaceCreateInfoFB-type-type", XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB, "XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardSpaceCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrKeyboardSpaceCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrKeyboardSpaceCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardSpaceCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrKeyboardSpaceCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrKeyboardTrackingQueryFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_KEYBOARD_TRACKING_QUERY_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrKeyboardTrackingQueryFB",
                             value->type, "VUID-XrKeyboardTrackingQueryFB-type-type", XR_TYPE_KEYBOARD_TRACKING_QUERY_FB, "XR_TYPE_KEYBOARD_TRACKING_QUERY_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingQueryFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrKeyboardTrackingQueryFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrKeyboardTrackingQueryFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingQueryFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrKeyboardTrackingQueryFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult keyboard_tracking_query_flags_fb_result = ValidateXrKeyboardTrackingQueryFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == keyboard_tracking_query_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingQueryFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrKeyboardTrackingQueryFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != keyboard_tracking_query_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrKeyboardTrackingQueryFB invalid member XrKeyboardTrackingQueryFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrKeyboardTrackingQueryFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrTriangleMeshCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrTriangleMeshCreateInfoFB",
                             value->type, "VUID-XrTriangleMeshCreateInfoFB-type-type", XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB, "XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrTriangleMeshCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrTriangleMeshCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrTriangleMeshCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrTriangleMeshCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrTriangleMeshCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult triangle_mesh_flags_fb_result = ValidateXrTriangleMeshFlagsFB(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == triangle_mesh_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrTriangleMeshCreateInfoFB invalid member XrTriangleMeshFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrTriangleMeshCreateInfoFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrWindingOrderFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrTriangleMeshCreateInfoFB", "windingOrder", objects_info, value->windingOrder)) {
        std::ostringstream oss_enum;
        oss_enum << "XrTriangleMeshCreateInfoFB contains invalid XrWindingOrderFB \"windingOrder\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->windingOrder));
        CoreValidLogMessage(instance_info, "VUID-XrTriangleMeshCreateInfoFB-windingOrder-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemPassthroughPropertiesFB",
                             value->type, "VUID-XrSystemPassthroughPropertiesFB-type-type", XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB, "XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemPassthroughPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemPassthroughPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemPassthroughPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughProperties2FB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemPassthroughProperties2FB",
                             value->type, "VUID-XrSystemPassthroughProperties2FB-type-type", XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB, "XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughProperties2FB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemPassthroughProperties2FB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemPassthroughProperties2FB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughProperties2FB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemPassthroughProperties2FB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult passthrough_capability_flags_fb_result = ValidateXrPassthroughCapabilityFlagsFB(value->capabilities);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == passthrough_capability_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughProperties2FB-capabilities-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPassthroughCapabilityFlagsFB \"capabilities\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != passthrough_capability_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSystemPassthroughProperties2FB invalid member XrPassthroughCapabilityFlagsFB \"capabilities\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->capabilities));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughProperties2FB-capabilities-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughCreateInfoFB",
                             value->type, "VUID-XrPassthroughCreateInfoFB-type-type", XR_TYPE_PASSTHROUGH_CREATE_INFO_FB, "XR_TYPE_PASSTHROUGH_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult passthrough_flags_fb_result = ValidateXrPassthroughFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == passthrough_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPassthroughFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != passthrough_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughCreateInfoFB invalid member XrPassthroughFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughLayerCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughLayerCreateInfoFB",
                             value->type, "VUID-XrPassthroughLayerCreateInfoFB-type-type", XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB, "XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughLayerCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughLayerCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughLayerCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughFBHandle(&value->passthrough);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughFB handle \"passthrough\" ";
            oss << HandleToHexString(value->passthrough);
            CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-passthrough-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    ValidateXrFlagsResult passthrough_flags_fb_result = ValidateXrPassthroughFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == passthrough_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPassthroughFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != passthrough_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughLayerCreateInfoFB invalid member XrPassthroughFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPassthroughLayerPurposeFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPassthroughLayerCreateInfoFB", "purpose", objects_info, value->purpose)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughLayerCreateInfoFB contains invalid XrPassthroughLayerPurposeFB \"purpose\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->purpose));
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughLayerCreateInfoFB-purpose-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerPassthroughFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerPassthroughFB",
                             value->type, "VUID-XrCompositionLayerPassthroughFB-type-type", XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB, "XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerPassthroughFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerPassthroughFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerPassthroughFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == composition_layer_flags_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrCompositionLayerFlags \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerPassthroughFB invalid member XrCompositionLayerFlags \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&value->layerHandle);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughLayerFB handle \"layerHandle\" ";
            oss << HandleToHexString(value->layerHandle);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughFB-layerHandle-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGeometryInstanceCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGeometryInstanceCreateInfoFB",
                             value->type, "VUID-XrGeometryInstanceCreateInfoFB-type-type", XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB, "XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGeometryInstanceCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGeometryInstanceCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGeometryInstanceCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&value->layer);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
            oss << HandleToHexString(value->layer);
            CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceCreateInfoFB-layer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&value->mesh);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
            oss << HandleToHexString(value->mesh);
            CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceCreateInfoFB-mesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceCreateInfoFB-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGeometryInstanceTransformFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGeometryInstanceTransformFB",
                             value->type, "VUID-XrGeometryInstanceTransformFB-type-type", XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB, "XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceTransformFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGeometryInstanceTransformFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGeometryInstanceTransformFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceTransformFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGeometryInstanceTransformFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrGeometryInstanceTransformFB-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughStyleFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_STYLE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughStyleFB",
                             value->type, "VUID-XrPassthroughStyleFB-type-type", XR_TYPE_PASSTHROUGH_STYLE_FB, "XR_TYPE_PASSTHROUGH_STYLE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB);
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META);
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META);
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB);
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughStyleFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughStyleFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughStyleFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughStyleFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughStyleFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapMonoToRgbaFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorMapMonoToRgbaFB",
                             value->type, "VUID-XrPassthroughColorMapMonoToRgbaFB-type-type", XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB, "XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapMonoToRgbaFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorMapMonoToRgbaFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorMapMonoToRgbaFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapMonoToRgbaFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorMapMonoToRgbaFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapMonoToMonoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorMapMonoToMonoFB",
                             value->type, "VUID-XrPassthroughColorMapMonoToMonoFB-type-type", XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB, "XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapMonoToMonoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorMapMonoToMonoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorMapMonoToMonoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapMonoToMonoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorMapMonoToMonoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughBrightnessContrastSaturationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughBrightnessContrastSaturationFB",
                             value->type, "VUID-XrPassthroughBrightnessContrastSaturationFB-type-type", XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB, "XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughBrightnessContrastSaturationFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughBrightnessContrastSaturationFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughBrightnessContrastSaturationFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughBrightnessContrastSaturationFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughBrightnessContrastSaturationFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataPassthroughStateChangedFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataPassthroughStateChangedFB",
                             value->type, "VUID-XrEventDataPassthroughStateChangedFB-type-type", XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB, "XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPassthroughStateChangedFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataPassthroughStateChangedFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataPassthroughStateChangedFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPassthroughStateChangedFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataPassthroughStateChangedFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult passthrough_state_changed_flags_fb_result = ValidateXrPassthroughStateChangedFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == passthrough_state_changed_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPassthroughStateChangedFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPassthroughStateChangedFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != passthrough_state_changed_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataPassthroughStateChangedFB invalid member XrPassthroughStateChangedFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrEventDataPassthroughStateChangedFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelPathInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RENDER_MODEL_PATH_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRenderModelPathInfoFB",
                             value->type, "VUID-XrRenderModelPathInfoFB-type-type", XR_TYPE_RENDER_MODEL_PATH_INFO_FB, "XR_TYPE_RENDER_MODEL_PATH_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPathInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRenderModelPathInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRenderModelPathInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPathInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRenderModelPathInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RENDER_MODEL_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRenderModelPropertiesFB",
                             value->type, "VUID-XrRenderModelPropertiesFB-type-type", XR_TYPE_RENDER_MODEL_PROPERTIES_FB, "XR_TYPE_RENDER_MODEL_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRenderModelPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRenderModelPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRenderModelPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_RENDER_MODEL_NAME_SIZE_FB < std::strlen(value->modelName)) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPropertiesFB-modelName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrRenderModelPropertiesFB member modelName length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    ValidateXrFlagsResult render_model_flags_fb_result = ValidateXrRenderModelFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == render_model_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPropertiesFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrRenderModelFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != render_model_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrRenderModelPropertiesFB invalid member XrRenderModelFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelPropertiesFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelBufferFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RENDER_MODEL_BUFFER_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRenderModelBufferFB",
                             value->type, "VUID-XrRenderModelBufferFB-type-type", XR_TYPE_RENDER_MODEL_BUFFER_FB, "XR_TYPE_RENDER_MODEL_BUFFER_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelBufferFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRenderModelBufferFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRenderModelBufferFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelBufferFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRenderModelBufferFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->bufferCapacityInput is non-zero
    if (0 != value->bufferCapacityInput && nullptr == value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelBufferFB-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrRenderModelBufferFB member bufferCapacityInput is NULL, but value->bufferCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrRenderModelBufferFB-buffer-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelLoadInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RENDER_MODEL_LOAD_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRenderModelLoadInfoFB",
                             value->type, "VUID-XrRenderModelLoadInfoFB-type-type", XR_TYPE_RENDER_MODEL_LOAD_INFO_FB, "XR_TYPE_RENDER_MODEL_LOAD_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelLoadInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRenderModelLoadInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRenderModelLoadInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelLoadInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRenderModelLoadInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemRenderModelPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemRenderModelPropertiesFB",
                             value->type, "VUID-XrSystemRenderModelPropertiesFB-type-type", XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB, "XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemRenderModelPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemRenderModelPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemRenderModelPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemRenderModelPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemRenderModelPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRenderModelCapabilitiesRequestFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRenderModelCapabilitiesRequestFB",
                             value->type, "VUID-XrRenderModelCapabilitiesRequestFB-type-type", XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB, "XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelCapabilitiesRequestFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRenderModelCapabilitiesRequestFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRenderModelCapabilitiesRequestFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelCapabilitiesRequestFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRenderModelCapabilitiesRequestFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult render_model_flags_fb_result = ValidateXrRenderModelFlagsFB(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == render_model_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelCapabilitiesRequestFB-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrRenderModelFlagsFB \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != render_model_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrRenderModelCapabilitiesRequestFB invalid member XrRenderModelFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrRenderModelCapabilitiesRequestFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrViewLocateFoveatedRenderingVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrViewLocateFoveatedRenderingVARJO",
                             value->type, "VUID-XrViewLocateFoveatedRenderingVARJO-type-type", XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO, "XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrViewLocateFoveatedRenderingVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrViewLocateFoveatedRenderingVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrViewLocateFoveatedRenderingVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrViewLocateFoveatedRenderingVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrViewLocateFoveatedRenderingVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveatedViewConfigurationViewVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveatedViewConfigurationViewVARJO",
                             value->type, "VUID-XrFoveatedViewConfigurationViewVARJO-type-type", XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO, "XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveatedViewConfigurationViewVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveatedViewConfigurationViewVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveatedViewConfigurationViewVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveatedViewConfigurationViewVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveatedViewConfigurationViewVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFoveatedRenderingPropertiesVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemFoveatedRenderingPropertiesVARJO",
                             value->type, "VUID-XrSystemFoveatedRenderingPropertiesVARJO-type-type", XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO, "XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemFoveatedRenderingPropertiesVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemFoveatedRenderingPropertiesVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemFoveatedRenderingPropertiesVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemFoveatedRenderingPropertiesVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemFoveatedRenderingPropertiesVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthTestVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerDepthTestVARJO",
                             value->type, "VUID-XrCompositionLayerDepthTestVARJO-type-type", XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO, "XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthTestVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerDepthTestVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerDepthTestVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthTestVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerDepthTestVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemMarkerTrackingPropertiesVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemMarkerTrackingPropertiesVARJO",
                             value->type, "VUID-XrSystemMarkerTrackingPropertiesVARJO-type-type", XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO, "XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemMarkerTrackingPropertiesVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemMarkerTrackingPropertiesVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemMarkerTrackingPropertiesVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemMarkerTrackingPropertiesVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemMarkerTrackingPropertiesVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataMarkerTrackingUpdateVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataMarkerTrackingUpdateVARJO",
                             value->type, "VUID-XrEventDataMarkerTrackingUpdateVARJO-type-type", XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO, "XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMarkerTrackingUpdateVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataMarkerTrackingUpdateVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataMarkerTrackingUpdateVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataMarkerTrackingUpdateVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataMarkerTrackingUpdateVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerSpaceCreateInfoVARJO* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerSpaceCreateInfoVARJO",
                             value->type, "VUID-XrMarkerSpaceCreateInfoVARJO-type-type", XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO, "XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerSpaceCreateInfoVARJO-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerSpaceCreateInfoVARJO struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerSpaceCreateInfoVARJO : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerSpaceCreateInfoVARJO-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerSpaceCreateInfoVARJO struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFrameEndInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FRAME_END_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFrameEndInfoML",
                             value->type, "VUID-XrFrameEndInfoML-type-type", XR_TYPE_FRAME_END_INFO_ML, "XR_TYPE_FRAME_END_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFrameEndInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFrameEndInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFrameEndInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult frame_end_info_flags_ml_result = ValidateXrFrameEndInfoFlagsML(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == frame_end_info_flags_ml_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrFrameEndInfoML invalid member XrFrameEndInfoFlagsML \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrFrameEndInfoML-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrGlobalDimmerFrameEndInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrGlobalDimmerFrameEndInfoML",
                             value->type, "VUID-XrGlobalDimmerFrameEndInfoML-type-type", XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML, "XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrGlobalDimmerFrameEndInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrGlobalDimmerFrameEndInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrGlobalDimmerFrameEndInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrGlobalDimmerFrameEndInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrGlobalDimmerFrameEndInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult global_dimmer_frame_end_info_flags_ml_result = ValidateXrGlobalDimmerFrameEndInfoFlagsML(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == global_dimmer_frame_end_info_flags_ml_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrGlobalDimmerFrameEndInfoML invalid member XrGlobalDimmerFrameEndInfoFlagsML \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrGlobalDimmerFrameEndInfoML-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_PLATFORM_ML)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCoordinateSpaceCreateInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCoordinateSpaceCreateInfoML",
                             value->type, "VUID-XrCoordinateSpaceCreateInfoML-type-type", XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML, "XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCoordinateSpaceCreateInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCoordinateSpaceCreateInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCoordinateSpaceCreateInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCoordinateSpaceCreateInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCoordinateSpaceCreateInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_ML)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemMarkerUnderstandingPropertiesML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemMarkerUnderstandingPropertiesML",
                             value->type, "VUID-XrSystemMarkerUnderstandingPropertiesML-type-type", XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML, "XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemMarkerUnderstandingPropertiesML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemMarkerUnderstandingPropertiesML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemMarkerUnderstandingPropertiesML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemMarkerUnderstandingPropertiesML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemMarkerUnderstandingPropertiesML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorCreateInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorCreateInfoML",
                             value->type, "VUID-XrMarkerDetectorCreateInfoML-type-type", XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML, "XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML);
    valid_ext_structs.push_back(XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML);
    valid_ext_structs.push_back(XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML);
    valid_ext_structs.push_back(XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCreateInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorCreateInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorCreateInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCreateInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorCreateInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMarkerDetectorProfileML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCreateInfoML", "profile", objects_info, value->profile)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCreateInfoML contains invalid XrMarkerDetectorProfileML \"profile\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->profile));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCreateInfoML-profile-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrMarkerTypeML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCreateInfoML", "markerType", objects_info, value->markerType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCreateInfoML contains invalid XrMarkerTypeML \"markerType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->markerType));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCreateInfoML-markerType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorArucoInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorArucoInfoML",
                             value->type, "VUID-XrMarkerDetectorArucoInfoML-type-type", XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML, "XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorArucoInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorArucoInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorArucoInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorArucoInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorArucoInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMarkerArucoDictML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorArucoInfoML", "arucoDict", objects_info, value->arucoDict)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorArucoInfoML contains invalid XrMarkerArucoDictML \"arucoDict\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->arucoDict));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorArucoInfoML-arucoDict-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorSizeInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorSizeInfoML",
                             value->type, "VUID-XrMarkerDetectorSizeInfoML-type-type", XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML, "XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorSizeInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorSizeInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorSizeInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorSizeInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorSizeInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorAprilTagInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorAprilTagInfoML",
                             value->type, "VUID-XrMarkerDetectorAprilTagInfoML-type-type", XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML, "XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorAprilTagInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorAprilTagInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorAprilTagInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorAprilTagInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorAprilTagInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMarkerAprilTagDictML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorAprilTagInfoML", "aprilTagDict", objects_info, value->aprilTagDict)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorAprilTagInfoML contains invalid XrMarkerAprilTagDictML \"aprilTagDict\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->aprilTagDict));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorAprilTagInfoML-aprilTagDict-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorCustomProfileInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorCustomProfileInfoML",
                             value->type, "VUID-XrMarkerDetectorCustomProfileInfoML-type-type", XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML, "XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorCustomProfileInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorCustomProfileInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorCustomProfileInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMarkerDetectorFpsML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCustomProfileInfoML", "fpsHint", objects_info, value->fpsHint)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCustomProfileInfoML contains invalid XrMarkerDetectorFpsML \"fpsHint\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->fpsHint));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-fpsHint-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrMarkerDetectorResolutionML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCustomProfileInfoML", "resolutionHint", objects_info, value->resolutionHint)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCustomProfileInfoML contains invalid XrMarkerDetectorResolutionML \"resolutionHint\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->resolutionHint));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-resolutionHint-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrMarkerDetectorCameraML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCustomProfileInfoML", "cameraHint", objects_info, value->cameraHint)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCustomProfileInfoML contains invalid XrMarkerDetectorCameraML \"cameraHint\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->cameraHint));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-cameraHint-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrMarkerDetectorCornerRefineMethodML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCustomProfileInfoML", "cornerRefineMethod", objects_info, value->cornerRefineMethod)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCustomProfileInfoML contains invalid XrMarkerDetectorCornerRefineMethodML \"cornerRefineMethod\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->cornerRefineMethod));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-cornerRefineMethod-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrMarkerDetectorFullAnalysisIntervalML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorCustomProfileInfoML", "fullAnalysisIntervalHint", objects_info, value->fullAnalysisIntervalHint)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorCustomProfileInfoML contains invalid XrMarkerDetectorFullAnalysisIntervalML \"fullAnalysisIntervalHint\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->fullAnalysisIntervalHint));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorCustomProfileInfoML-fullAnalysisIntervalHint-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorSnapshotInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorSnapshotInfoML",
                             value->type, "VUID-XrMarkerDetectorSnapshotInfoML-type-type", XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML, "XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorSnapshotInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorSnapshotInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorSnapshotInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorSnapshotInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorSnapshotInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerDetectorStateML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_DETECTOR_STATE_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerDetectorStateML",
                             value->type, "VUID-XrMarkerDetectorStateML-type-type", XR_TYPE_MARKER_DETECTOR_STATE_ML, "XR_TYPE_MARKER_DETECTOR_STATE_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorStateML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerDetectorStateML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerDetectorStateML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorStateML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerDetectorStateML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrMarkerDetectorStatusML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrMarkerDetectorStateML", "state", objects_info, value->state)) {
        std::ostringstream oss_enum;
        oss_enum << "XrMarkerDetectorStateML contains invalid XrMarkerDetectorStatusML \"state\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->state));
        CoreValidLogMessage(instance_info, "VUID-XrMarkerDetectorStateML-state-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMarkerSpaceCreateInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MARKER_SPACE_CREATE_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMarkerSpaceCreateInfoML",
                             value->type, "VUID-XrMarkerSpaceCreateInfoML-type-type", XR_TYPE_MARKER_SPACE_CREATE_INFO_ML, "XR_TYPE_MARKER_SPACE_CREATE_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMarkerSpaceCreateInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMarkerSpaceCreateInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMarkerSpaceCreateInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMarkerSpaceCreateInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMarkerSpaceCreateInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&value->markerDetector);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
            oss << HandleToHexString(value->markerDetector);
            CoreValidLogMessage(instance_info, "VUID-XrMarkerSpaceCreateInfoML-markerDetector-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_LOCALIZATION_MAP_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrLocalizationMapML",
                             value->type, "VUID-XrLocalizationMapML-type-type", XR_TYPE_LOCALIZATION_MAP_ML, "XR_TYPE_LOCALIZATION_MAP_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrLocalizationMapML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrLocalizationMapML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrLocalizationMapML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_LOCALIZATION_MAP_NAME_LENGTH_ML < std::strlen(value->name)) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapML-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrLocalizationMapML member name length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrLocalizationMapTypeML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrLocalizationMapML", "mapType", objects_info, value->mapType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrLocalizationMapML contains invalid XrLocalizationMapTypeML \"mapType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->mapType));
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapML-mapType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataLocalizationChangedML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataLocalizationChangedML",
                             value->type, "VUID-XrEventDataLocalizationChangedML-type-type", XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML, "XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataLocalizationChangedML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataLocalizationChangedML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataLocalizationChangedML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrLocalizationMapStateML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataLocalizationChangedML", "state", objects_info, value->state)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataLocalizationChangedML contains invalid XrLocalizationMapStateML \"state\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->state));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-state-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrLocalizationMapML is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->map);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-map-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrEventDataLocalizationChangedML member map is invalid");
        return xr_result;
    }
    // Make sure the enum type XrLocalizationMapConfidenceML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataLocalizationChangedML", "confidence", objects_info, value->confidence)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataLocalizationChangedML contains invalid XrLocalizationMapConfidenceML \"confidence\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->confidence));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-confidence-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    ValidateXrFlagsResult localization_map_error_flags_ml_result = ValidateXrLocalizationMapErrorFlagsML(value->errorFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == localization_map_error_flags_ml_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-errorFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrLocalizationMapErrorFlagsML \"errorFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != localization_map_error_flags_ml_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataLocalizationChangedML invalid member XrLocalizationMapErrorFlagsML \"errorFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->errorFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrEventDataLocalizationChangedML-errorFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapQueryInfoBaseHeaderML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrLocalizationMapQueryInfoBaseHeaderML-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrLocalizationMapQueryInfoBaseHeaderML-next-next" because it is a base structure
    InvalidStructureType(instance_info, command_name, objects_info, "XrLocalizationMapQueryInfoBaseHeaderML",
                         value->type, "VUID-XrLocalizationMapQueryInfoBaseHeaderML-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrMapLocalizationRequestInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrMapLocalizationRequestInfoML",
                             value->type, "VUID-XrMapLocalizationRequestInfoML-type-type", XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML, "XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrMapLocalizationRequestInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrMapLocalizationRequestInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrMapLocalizationRequestInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrMapLocalizationRequestInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrMapLocalizationRequestInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationMapImportInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrLocalizationMapImportInfoML",
                             value->type, "VUID-XrLocalizationMapImportInfoML-type-type", XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML, "XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapImportInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrLocalizationMapImportInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrLocalizationMapImportInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapImportInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrLocalizationMapImportInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->size && nullptr != value->data) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapImportInfoML-size-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrLocalizationMapImportInfoML member size is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->data && 0 != value->size) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationMapImportInfoML-data-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrLocalizationMapImportInfoML contains invalid NULL for char \"data\" is which not "
                            "optional since \"size\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrLocalizationMapImportInfoML-data-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalizationEnableEventsInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrLocalizationEnableEventsInfoML",
                             value->type, "VUID-XrLocalizationEnableEventsInfoML-type-type", XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML, "XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationEnableEventsInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrLocalizationEnableEventsInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrLocalizationEnableEventsInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrLocalizationEnableEventsInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrLocalizationEnableEventsInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorPersistenceNameMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT < std::strlen(value->name)) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorPersistenceNameMSFT-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpatialAnchorPersistenceNameMSFT member name length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorPersistenceInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorPersistenceInfoMSFT",
                             value->type, "VUID-XrSpatialAnchorPersistenceInfoMSFT-type-type", XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT, "XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorPersistenceInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorPersistenceInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorPersistenceInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorPersistenceInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorPersistenceInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Validate that the structure XrSpatialAnchorPersistenceNameMSFT is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->spatialAnchorPersistenceName);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorPersistenceInfoMSFT-spatialAnchorPersistenceName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpatialAnchorPersistenceInfoMSFT member spatialAnchorPersistenceName is invalid");
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorMSFTHandle(&value->spatialAnchor);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpatialAnchorMSFT handle \"spatialAnchor\" ";
            oss << HandleToHexString(value->spatialAnchor);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorPersistenceInfoMSFT-spatialAnchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT",
                             value->type, "VUID-XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT-type-type", XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT, "XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&value->spatialAnchorStore);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
            oss << HandleToHexString(value->spatialAnchorStore);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT-spatialAnchorStore-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Validate that the structure XrSpatialAnchorPersistenceNameMSFT is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->spatialAnchorPersistenceName);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT-spatialAnchorPersistenceName-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT member spatialAnchorPersistenceName is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSceneMarkerTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSceneMarkerMSFT", "markerType", objects_info, value->markerType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSceneMarkerMSFT contains invalid XrSceneMarkerTypeMSFT \"markerType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->markerType));
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerMSFT-markerType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkersMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MARKERS_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMarkersMSFT",
                             value->type, "VUID-XrSceneMarkersMSFT-type-type", XR_TYPE_SCENE_MARKERS_MSFT, "XR_TYPE_SCENE_MARKERS_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkersMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMarkersMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMarkersMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkersMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMarkersMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->sceneMarkerCapacityInput is non-zero
    if (0 != value->sceneMarkerCapacityInput && nullptr == value->sceneMarkers) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkersMSFT-sceneMarkers-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMarkersMSFT member sceneMarkerCapacityInput is NULL, but value->sceneMarkerCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->sceneMarkers) {
        for (uint32_t value_scenemarkers_inc = 0; value_scenemarkers_inc < value->sceneMarkerCapacityInput; ++value_scenemarkers_inc) {
            // Validate that the structure XrSceneMarkerMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->sceneMarkers[value_scenemarkers_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneMarkersMSFT-sceneMarkers-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneMarkersMSFT member sceneMarkers is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerTypeFilterMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMarkerTypeFilterMSFT",
                             value->type, "VUID-XrSceneMarkerTypeFilterMSFT-type-type", XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT, "XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerTypeFilterMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMarkerTypeFilterMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMarkerTypeFilterMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerTypeFilterMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMarkerTypeFilterMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->markerTypeCount is non-zero
    if (0 != value->markerTypeCount && nullptr == value->markerTypes) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerTypeFilterMSFT-markerTypes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMarkerTypeFilterMSFT member markerTypeCount is NULL, but value->markerTypeCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
            // NOTE: Can't validate "VUID-XrSceneMarkerTypeFilterMSFT-markerTypes-parameter" output enum buffer
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerQRCodeMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSceneMarkerQRCodeSymbolTypeMSFT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSceneMarkerQRCodeMSFT", "symbolType", objects_info, value->symbolType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSceneMarkerQRCodeMSFT contains invalid XrSceneMarkerQRCodeSymbolTypeMSFT \"symbolType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->symbolType));
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerQRCodeMSFT-symbolType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneMarkerQRCodesMSFT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_MARKER_QR_CODES_MSFT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneMarkerQRCodesMSFT",
                             value->type, "VUID-XrSceneMarkerQRCodesMSFT-type-type", XR_TYPE_SCENE_MARKER_QR_CODES_MSFT, "XR_TYPE_SCENE_MARKER_QR_CODES_MSFT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerQRCodesMSFT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneMarkerQRCodesMSFT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneMarkerQRCodesMSFT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerQRCodesMSFT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneMarkerQRCodesMSFT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->qrCodeCapacityInput is non-zero
    if (0 != value->qrCodeCapacityInput && nullptr == value->qrCodes) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerQRCodesMSFT-qrCodes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneMarkerQRCodesMSFT member qrCodeCapacityInput is NULL, but value->qrCodeCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->qrCodes) {
        for (uint32_t value_qrcodes_inc = 0; value_qrcodes_inc < value->qrCodeCapacityInput; ++value_qrcodes_inc) {
            // Validate that the structure XrSceneMarkerQRCodeMSFT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->qrCodes[value_qrcodes_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSceneMarkerQRCodesMSFT-qrCodes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSceneMarkerQRCodesMSFT member qrCodes is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryInfoBaseHeaderFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrSpaceQueryInfoBaseHeaderFB-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrSpaceQueryInfoBaseHeaderFB-next-next" because it is a base structure
    if (value->type == XR_TYPE_SPACE_QUERY_INFO_FB) {
        const XrSpaceQueryInfoFB* new_value = reinterpret_cast<const XrSpaceQueryInfoFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
            std::string error_str = "XrSpaceQueryInfoBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SPACE_QUERY_INFO_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceQueryInfoBaseHeaderFB",
                         value->type, "VUID-XrSpaceQueryInfoBaseHeaderFB-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceFilterInfoBaseHeaderFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // NOTE: Can't validate "VUID-XrSpaceFilterInfoBaseHeaderFB-type-parameter" because it is a base structure
    // NOTE: Can't validate "VUID-XrSpaceFilterInfoBaseHeaderFB-next-next" because it is a base structure
    if (value->type == XR_TYPE_SPACE_UUID_FILTER_INFO_FB) {
        const XrSpaceUuidFilterInfoFB* new_value = reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
            std::string error_str = "XrSpaceFilterInfoBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SPACE_UUID_FILTER_INFO_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSpaceFilterInfoBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    if (value->type == XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB) {
        const XrSpaceComponentFilterInfoFB* new_value = reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(value);
        if (nullptr != instance_info && !ExtensionEnabled(instance_info->enabled_extensions, "XR_FB_spatial_entity_query")) {
            std::string error_str = "XrSpaceFilterInfoBaseHeaderFB being used with child struct type ";
            error_str += "\"XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB\"";
            error_str += " which requires extension \"XR_FB_spatial_entity_query\" to be enabled, but it is not enabled";
            CoreValidLogMessage(instance_info, "VUID-XrSpaceFilterInfoBaseHeaderFB-type-type",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, error_str);
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return ValidateXrStruct(instance_info, command_name, objects_info, check_members, new_value);
    }
    InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceFilterInfoBaseHeaderFB",
                         value->type, "VUID-XrSpaceFilterInfoBaseHeaderFB-type-type");
    return XR_ERROR_VALIDATION_FAILURE;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_QUERY_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceQueryInfoFB",
                             value->type, "VUID-XrSpaceQueryInfoFB-type-type", XR_TYPE_SPACE_QUERY_INFO_FB, "XR_TYPE_SPACE_QUERY_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceQueryInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceQueryInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceQueryInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSpaceQueryActionFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceQueryInfoFB", "queryAction", objects_info, value->queryAction)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceQueryInfoFB contains invalid XrSpaceQueryActionFB \"queryAction\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->queryAction));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-queryAction-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate if XrSpaceFilterInfoBaseHeaderFB is a child structure of type XrSpaceUuidFilterInfoFB and it is valid
    {
        const XrSpaceUuidFilterInfoFB* new_spaceuuidfilterinfofb_value = reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(value->filter);
        if (new_spaceuuidfilterinfofb_value->type == XR_TYPE_SPACE_UUID_FILTER_INFO_FB) {
            if (nullptr != new_spaceuuidfilterinfofb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_spaceuuidfilterinfofb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrSpaceQueryInfoFB member filter";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-filter-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrSpaceFilterInfoBaseHeaderFB is a child structure of type XrSpaceComponentFilterInfoFB and it is valid
    {
        const XrSpaceComponentFilterInfoFB* new_spacecomponentfilterinfofb_value = reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(value->filter);
        if (new_spacecomponentfilterinfofb_value->type == XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB) {
            if (nullptr != new_spacecomponentfilterinfofb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_spacecomponentfilterinfofb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrSpaceQueryInfoFB member filter";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-filter-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrSpaceFilterInfoBaseHeaderFB is valid
    if (nullptr != value->filter) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->filter);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-filter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrSpaceQueryInfoFB member filter is invalid");
            return xr_result;
        }
    }
    // Validate if XrSpaceFilterInfoBaseHeaderFB is a child structure of type XrSpaceUuidFilterInfoFB and it is valid
    {
        const XrSpaceUuidFilterInfoFB* new_spaceuuidfilterinfofb_value = reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(value->excludeFilter);
        if (new_spaceuuidfilterinfofb_value->type == XR_TYPE_SPACE_UUID_FILTER_INFO_FB) {
            if (nullptr != new_spaceuuidfilterinfofb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_spaceuuidfilterinfofb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrSpaceQueryInfoFB member excludeFilter";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-excludeFilter-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate if XrSpaceFilterInfoBaseHeaderFB is a child structure of type XrSpaceComponentFilterInfoFB and it is valid
    {
        const XrSpaceComponentFilterInfoFB* new_spacecomponentfilterinfofb_value = reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(value->excludeFilter);
        if (new_spacecomponentfilterinfofb_value->type == XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB) {
            if (nullptr != new_spacecomponentfilterinfofb_value) {
                xr_result = ValidateXrStruct(instance_info, command_name,
                                                                objects_info, check_members, new_spacecomponentfilterinfofb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Structure XrSpaceQueryInfoFB member excludeFilter";
                    error_message += " is invalid";
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-excludeFilter-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                    }
            }
        }
    }
    // Validate that the base-structure XrSpaceFilterInfoBaseHeaderFB is valid
    if (nullptr != value->excludeFilter) {
        xr_result = ValidateXrStruct(instance_info, command_name,
                                                        objects_info, check_members, value->excludeFilter);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryInfoFB-excludeFilter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrSpaceQueryInfoFB member excludeFilter is invalid");
            return xr_result;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceStorageLocationFilterInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceStorageLocationFilterInfoFB",
                             value->type, "VUID-XrSpaceStorageLocationFilterInfoFB-type-type", XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB, "XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceStorageLocationFilterInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceStorageLocationFilterInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceStorageLocationFilterInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceStorageLocationFilterInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceStorageLocationFilterInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceStorageLocationFilterInfoFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceStorageLocationFilterInfoFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceStorageLocationFilterInfoFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceUuidFilterInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_UUID_FILTER_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceUuidFilterInfoFB",
                             value->type, "VUID-XrSpaceUuidFilterInfoFB-type-type", XR_TYPE_SPACE_UUID_FILTER_INFO_FB, "XR_TYPE_SPACE_UUID_FILTER_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUuidFilterInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceUuidFilterInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceUuidFilterInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUuidFilterInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceUuidFilterInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->uuidCount && nullptr != value->uuids) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUuidFilterInfoFB-uuidCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceUuidFilterInfoFB member uuidCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->uuids && 0 != value->uuidCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUuidFilterInfoFB-uuids-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSpaceUuidFilterInfoFB contains invalid NULL for XrUuidEXT \"uuids\" is which not "
                            "optional since \"uuidCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSpaceUuidFilterInfoFB-uuids-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceComponentFilterInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceComponentFilterInfoFB",
                             value->type, "VUID-XrSpaceComponentFilterInfoFB-type-type", XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB, "XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentFilterInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceComponentFilterInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceComponentFilterInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentFilterInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceComponentFilterInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrSpaceComponentTypeFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceComponentFilterInfoFB", "componentType", objects_info, value->componentType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceComponentFilterInfoFB contains invalid XrSpaceComponentTypeFB \"componentType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->componentType));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceComponentFilterInfoFB-componentType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryResultFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryResultFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceQueryResultsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_QUERY_RESULTS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceQueryResultsFB",
                             value->type, "VUID-XrSpaceQueryResultsFB-type-type", XR_TYPE_SPACE_QUERY_RESULTS_FB, "XR_TYPE_SPACE_QUERY_RESULTS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryResultsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceQueryResultsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceQueryResultsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryResultsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceQueryResultsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->resultCapacityInput is non-zero
    if (0 != value->resultCapacityInput && nullptr == value->results) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryResultsFB-results-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceQueryResultsFB member resultCapacityInput is NULL, but value->resultCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->results) {
        for (uint32_t value_results_inc = 0; value_results_inc < value->resultCapacityInput; ++value_results_inc) {
            // Validate that the structure XrSpaceQueryResultFB is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->results[value_results_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrSpaceQueryResultsFB-results-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrSpaceQueryResultsFB member results is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceQueryResultsAvailableFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceQueryResultsAvailableFB",
                             value->type, "VUID-XrEventDataSpaceQueryResultsAvailableFB-type-type", XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB, "XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceQueryResultsAvailableFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceQueryResultsAvailableFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceQueryResultsAvailableFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceQueryResultsAvailableFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceQueryResultsAvailableFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceQueryCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceQueryCompleteFB",
                             value->type, "VUID-XrEventDataSpaceQueryCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceQueryCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceQueryCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceQueryCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceQueryCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceQueryCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceQueryCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceQueryCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceQueryCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceSaveInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_SAVE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceSaveInfoFB",
                             value->type, "VUID-XrSpaceSaveInfoFB-type-type", XR_TYPE_SPACE_SAVE_INFO_FB, "XR_TYPE_SPACE_SAVE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceSaveInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceSaveInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceSaveInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceSaveInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceSaveInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpaceSaveInfoFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceSaveInfoFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceSaveInfoFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceSaveInfoFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrSpacePersistenceModeFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceSaveInfoFB", "persistenceMode", objects_info, value->persistenceMode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceSaveInfoFB contains invalid XrSpacePersistenceModeFB \"persistenceMode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->persistenceMode));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceSaveInfoFB-persistenceMode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceEraseInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_ERASE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceEraseInfoFB",
                             value->type, "VUID-XrSpaceEraseInfoFB-type-type", XR_TYPE_SPACE_ERASE_INFO_FB, "XR_TYPE_SPACE_ERASE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceEraseInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceEraseInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceEraseInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceEraseInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceEraseInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpaceEraseInfoFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceEraseInfoFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceEraseInfoFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceEraseInfoFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceSaveCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceSaveCompleteFB",
                             value->type, "VUID-XrEventDataSpaceSaveCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSaveCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceSaveCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceSaveCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSaveCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceSaveCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceSaveCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceSaveCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSaveCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSaveCompleteFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceSaveCompleteFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceSaveCompleteFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceSaveCompleteFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceEraseCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceEraseCompleteFB",
                             value->type, "VUID-XrEventDataSpaceEraseCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceEraseCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceEraseCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceEraseCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceEraseCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceEraseCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceEraseCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceEraseCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceEraseCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceEraseCompleteFB-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceEraseCompleteFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceEraseCompleteFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceEraseCompleteFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainImageFoveationVulkanFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainImageFoveationVulkanFB",
                             value->type, "VUID-XrSwapchainImageFoveationVulkanFB-type-type", XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB, "XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageFoveationVulkanFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainImageFoveationVulkanFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainImageFoveationVulkanFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainImageFoveationVulkanFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainImageFoveationVulkanFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateAndroidSurfaceDimensionsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainStateAndroidSurfaceDimensionsFB",
                             value->type, "VUID-XrSwapchainStateAndroidSurfaceDimensionsFB-type-type", XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB, "XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateAndroidSurfaceDimensionsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainStateAndroidSurfaceDimensionsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainStateAndroidSurfaceDimensionsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateAndroidSurfaceDimensionsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainStateAndroidSurfaceDimensionsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateSamplerOpenGLESFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainStateSamplerOpenGLESFB",
                             value->type, "VUID-XrSwapchainStateSamplerOpenGLESFB-type-type", XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB, "XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateSamplerOpenGLESFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainStateSamplerOpenGLESFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainStateSamplerOpenGLESFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateSamplerOpenGLESFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainStateSamplerOpenGLESFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSwapchainStateSamplerVulkanFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSwapchainStateSamplerVulkanFB",
                             value->type, "VUID-XrSwapchainStateSamplerVulkanFB-type-type", XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB, "XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateSamplerVulkanFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSwapchainStateSamplerVulkanFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSwapchainStateSamplerVulkanFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSwapchainStateSamplerVulkanFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSwapchainStateSamplerVulkanFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceShareInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_SHARE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceShareInfoFB",
                             value->type, "VUID-XrSpaceShareInfoFB-type-type", XR_TYPE_SPACE_SHARE_INFO_FB, "XR_TYPE_SPACE_SHARE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceShareInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceShareInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceShareInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->spaceCount && nullptr != value->spaces) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-spaceCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceShareInfoFB member spaceCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->spaces && 0 != value->spaceCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-spaces-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSpaceShareInfoFB contains invalid NULL for XrSpace \"spaces\" is which not "
                            "optional since \"spaceCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->spaces) {
        for (uint32_t value_spaces_inc = 0; value_spaces_inc < value->spaceCount; ++value_spaces_inc) {
            {
                // writeValidateInlineHandleValidation
                ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->spaces[value_spaces_inc]);
                if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                    // Not a valid handle or NULL (which is not valid in this case)
                    std::ostringstream oss;
                    oss << "Invalid XrSpace handle \"spaces\" ";
                    oss << HandleToHexString(value->spaces[value_spaces_inc]);
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-spaces-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info, oss.str());
                    return XR_ERROR_HANDLE_INVALID;
                }
            }
        }
    }
    // Non-optional array length must be non-zero
    if (0 >= value->userCount && nullptr != value->users) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-userCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceShareInfoFB member userCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->users && 0 != value->userCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-users-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSpaceShareInfoFB contains invalid NULL for XrSpaceUserFB \"users\" is which not "
                            "optional since \"userCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->users) {
        for (uint32_t value_users_inc = 0; value_users_inc < value->userCount; ++value_users_inc) {
            {
                // writeValidateInlineHandleValidation
                ValidateXrHandleResult handle_result = VerifyXrSpaceUserFBHandle(&value->users[value_users_inc]);
                if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                    // Not a valid handle or NULL (which is not valid in this case)
                    std::ostringstream oss;
                    oss << "Invalid XrSpaceUserFB handle \"users\" ";
                    oss << HandleToHexString(value->users[value_users_inc]);
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceShareInfoFB-users-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info, oss.str());
                    return XR_ERROR_HANDLE_INVALID;
                }
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceShareCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceShareCompleteFB",
                             value->type, "VUID-XrEventDataSpaceShareCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceShareCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceShareCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceShareCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceShareCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceShareCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceShareCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceShareCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceShareCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSpaceWarpInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerSpaceWarpInfoFB",
                             value->type, "VUID-XrCompositionLayerSpaceWarpInfoFB-type-type", XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB, "XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSpaceWarpInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerSpaceWarpInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerSpaceWarpInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSpaceWarpInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerSpaceWarpInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_space_warp_info_flags_fb_result = ValidateXrCompositionLayerSpaceWarpInfoFlagsFB(value->layerFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == composition_layer_space_warp_info_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerSpaceWarpInfoFB invalid member XrCompositionLayerSpaceWarpInfoFlagsFB \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSpaceWarpInfoFB-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->motionVectorSubImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSpaceWarpInfoFB-motionVectorSubImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerSpaceWarpInfoFB member motionVectorSubImage is invalid");
        return xr_result;
    }
    // Validate that the structure XrSwapchainSubImage is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->depthSubImage);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSpaceWarpInfoFB-depthSubImage-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerSpaceWarpInfoFB member depthSubImage is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemSpaceWarpPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemSpaceWarpPropertiesFB",
                             value->type, "VUID-XrSystemSpaceWarpPropertiesFB-type-type", XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB, "XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemSpaceWarpPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemSpaceWarpPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemSpaceWarpPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemSpaceWarpPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemSpaceWarpPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticAmplitudeEnvelopeVibrationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHapticAmplitudeEnvelopeVibrationFB",
                             value->type, "VUID-XrHapticAmplitudeEnvelopeVibrationFB-type-type", XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB, "XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticAmplitudeEnvelopeVibrationFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHapticAmplitudeEnvelopeVibrationFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHapticAmplitudeEnvelopeVibrationFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHapticAmplitudeEnvelopeVibrationFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHapticAmplitudeEnvelopeVibrationFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->amplitudeCount && nullptr != value->amplitudes) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticAmplitudeEnvelopeVibrationFB-amplitudeCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHapticAmplitudeEnvelopeVibrationFB member amplitudeCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->amplitudes && 0 != value->amplitudeCount) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticAmplitudeEnvelopeVibrationFB-amplitudes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHapticAmplitudeEnvelopeVibrationFB contains invalid NULL for float \"amplitudes\" is which not "
                            "optional since \"amplitudeCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHapticAmplitudeEnvelopeVibrationFB-amplitudes-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent3DfFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrOffset3DfFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRect3DfFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSemanticLabelsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SEMANTIC_LABELS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSemanticLabelsFB",
                             value->type, "VUID-XrSemanticLabelsFB-type-type", XR_TYPE_SEMANTIC_LABELS_FB, "XR_TYPE_SEMANTIC_LABELS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSemanticLabelsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSemanticLabelsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSemanticLabelsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->bufferCapacityInput is non-zero
    if (0 != value->bufferCapacityInput && nullptr == value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsFB-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSemanticLabelsFB member bufferCapacityInput is NULL, but value->bufferCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSemanticLabelsFB-buffer-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRoomLayoutFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ROOM_LAYOUT_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRoomLayoutFB",
                             value->type, "VUID-XrRoomLayoutFB-type-type", XR_TYPE_ROOM_LAYOUT_FB, "XR_TYPE_ROOM_LAYOUT_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRoomLayoutFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRoomLayoutFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRoomLayoutFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRoomLayoutFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRoomLayoutFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->wallUuidCapacityInput is non-zero
    if (0 != value->wallUuidCapacityInput && nullptr == value->wallUuids) {
        CoreValidLogMessage(instance_info, "VUID-XrRoomLayoutFB-wallUuids-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrRoomLayoutFB member wallUuidCapacityInput is NULL, but value->wallUuidCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrRoomLayoutFB-wallUuids-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrBoundary2DFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_BOUNDARY_2D_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrBoundary2DFB",
                             value->type, "VUID-XrBoundary2DFB-type-type", XR_TYPE_BOUNDARY_2D_FB, "XR_TYPE_BOUNDARY_2D_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrBoundary2DFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrBoundary2DFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrBoundary2DFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrBoundary2DFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrBoundary2DFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrBoundary2DFB-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrBoundary2DFB member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrBoundary2DFB-vertices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSemanticLabelsSupportInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSemanticLabelsSupportInfoFB",
                             value->type, "VUID-XrSemanticLabelsSupportInfoFB-type-type", XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB, "XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsSupportInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSemanticLabelsSupportInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSemanticLabelsSupportInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsSupportInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSemanticLabelsSupportInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult semantic_labels_support_flags_fb_result = ValidateXrSemanticLabelsSupportFlagsFB(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == semantic_labels_support_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSemanticLabelsSupportInfoFB invalid member XrSemanticLabelsSupportFlagsFB \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsSupportInfoFB-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->recognizedLabels) {
        CoreValidLogMessage(instance_info, "VUID-XrSemanticLabelsSupportInfoFB-recognizedLabels-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSemanticLabelsSupportInfoFB contains invalid NULL for char \"recognizedLabels\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSemanticLabelsSupportInfoFB-recognizedLabels-parameter" null-termination
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDigitalLensControlALMALENCE* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDigitalLensControlALMALENCE",
                             value->type, "VUID-XrDigitalLensControlALMALENCE-type-type", XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE, "XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDigitalLensControlALMALENCE-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDigitalLensControlALMALENCE struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDigitalLensControlALMALENCE : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDigitalLensControlALMALENCE-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDigitalLensControlALMALENCE struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult digital_lens_control_flags_almalence_result = ValidateXrDigitalLensControlFlagsALMALENCE(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == digital_lens_control_flags_almalence_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDigitalLensControlALMALENCE-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrDigitalLensControlFlagsALMALENCE \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != digital_lens_control_flags_almalence_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrDigitalLensControlALMALENCE invalid member XrDigitalLensControlFlagsALMALENCE \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrDigitalLensControlALMALENCE-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSceneCaptureCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSceneCaptureCompleteFB",
                             value->type, "VUID-XrEventDataSceneCaptureCompleteFB-type-type", XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSceneCaptureCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSceneCaptureCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSceneCaptureCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSceneCaptureCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSceneCaptureCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSceneCaptureCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSceneCaptureCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSceneCaptureCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSceneCaptureRequestInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSceneCaptureRequestInfoFB",
                             value->type, "VUID-XrSceneCaptureRequestInfoFB-type-type", XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB, "XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneCaptureRequestInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSceneCaptureRequestInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSceneCaptureRequestInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSceneCaptureRequestInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSceneCaptureRequestInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->requestByteCount is non-zero
    if (0 != value->requestByteCount && nullptr == value->request) {
        CoreValidLogMessage(instance_info, "VUID-XrSceneCaptureRequestInfoFB-request-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSceneCaptureRequestInfoFB member requestByteCount is NULL, but value->requestByteCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSceneCaptureRequestInfoFB-request-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceContainerFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_CONTAINER_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceContainerFB",
                             value->type, "VUID-XrSpaceContainerFB-type-type", XR_TYPE_SPACE_CONTAINER_FB, "XR_TYPE_SPACE_CONTAINER_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceContainerFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceContainerFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceContainerFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceContainerFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceContainerFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->uuidCapacityInput is non-zero
    if (0 != value->uuidCapacityInput && nullptr == value->uuids) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceContainerFB-uuids-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceContainerFB member uuidCapacityInput is NULL, but value->uuidCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSpaceContainerFB-uuids-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationEyeTrackedProfileCreateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationEyeTrackedProfileCreateInfoMETA",
                             value->type, "VUID-XrFoveationEyeTrackedProfileCreateInfoMETA-type-type", XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META, "XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedProfileCreateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationEyeTrackedProfileCreateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationEyeTrackedProfileCreateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedProfileCreateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationEyeTrackedProfileCreateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult foveation_eye_tracked_profile_create_flags_meta_result = ValidateXrFoveationEyeTrackedProfileCreateFlagsMETA(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == foveation_eye_tracked_profile_create_flags_meta_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedProfileCreateInfoMETA-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrFoveationEyeTrackedProfileCreateFlagsMETA \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != foveation_eye_tracked_profile_create_flags_meta_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationEyeTrackedProfileCreateInfoMETA invalid member XrFoveationEyeTrackedProfileCreateFlagsMETA \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedProfileCreateInfoMETA-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationEyeTrackedStateMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationEyeTrackedStateMETA",
                             value->type, "VUID-XrFoveationEyeTrackedStateMETA-type-type", XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META, "XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedStateMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationEyeTrackedStateMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationEyeTrackedStateMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedStateMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationEyeTrackedStateMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult foveation_eye_tracked_state_flags_meta_result = ValidateXrFoveationEyeTrackedStateFlagsMETA(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == foveation_eye_tracked_state_flags_meta_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedStateMETA-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrFoveationEyeTrackedStateFlagsMETA \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != foveation_eye_tracked_state_flags_meta_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationEyeTrackedStateMETA invalid member XrFoveationEyeTrackedStateFlagsMETA \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrFoveationEyeTrackedStateMETA-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFoveationEyeTrackedPropertiesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemFoveationEyeTrackedPropertiesMETA",
                             value->type, "VUID-XrSystemFoveationEyeTrackedPropertiesMETA-type-type", XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META, "XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemFoveationEyeTrackedPropertiesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemFoveationEyeTrackedPropertiesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemFoveationEyeTrackedPropertiesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemFoveationEyeTrackedPropertiesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemFoveationEyeTrackedPropertiesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFaceTrackingPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemFaceTrackingPropertiesFB",
                             value->type, "VUID-XrSystemFaceTrackingPropertiesFB-type-type", XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB, "XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemFaceTrackingPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemFaceTrackingPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemFaceTrackingPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemFaceTrackingPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemFaceTrackingPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceTrackerCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_TRACKER_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceTrackerCreateInfoFB",
                             value->type, "VUID-XrFaceTrackerCreateInfoFB-type-type", XR_TYPE_FACE_TRACKER_CREATE_INFO_FB, "XR_TYPE_FACE_TRACKER_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceTrackerCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceTrackerCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceTrackerCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFaceExpressionSetFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFaceTrackerCreateInfoFB", "faceExpressionSet", objects_info, value->faceExpressionSet)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFaceTrackerCreateInfoFB contains invalid XrFaceExpressionSetFB \"faceExpressionSet\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->faceExpressionSet));
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfoFB-faceExpressionSet-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_EXPRESSION_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceExpressionInfoFB",
                             value->type, "VUID-XrFaceExpressionInfoFB-type-type", XR_TYPE_FACE_EXPRESSION_INFO_FB, "XR_TYPE_FACE_EXPRESSION_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceExpressionInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceExpressionInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceExpressionInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionStatusFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionWeightsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceExpressionWeightsFB",
                             value->type, "VUID-XrFaceExpressionWeightsFB-type-type", XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB, "XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceExpressionWeightsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceExpressionWeightsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceExpressionWeightsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->weightCount && nullptr != value->weights) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-weightCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceExpressionWeightsFB member weightCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->weights && 0 != value->weightCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-weights-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFaceExpressionWeightsFB contains invalid NULL for float \"weights\" is which not "
                            "optional since \"weightCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrFaceExpressionWeightsFB-weights-parameter" type
    // Non-optional array length must be non-zero
    if (0 >= value->confidenceCount && nullptr != value->confidences) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-confidenceCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceExpressionWeightsFB member confidenceCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->confidences && 0 != value->confidenceCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-confidences-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFaceExpressionWeightsFB contains invalid NULL for float \"confidences\" is which not "
                            "optional since \"confidenceCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrFaceExpressionWeightsFB-confidences-parameter" type
    // Validate that the structure XrFaceExpressionStatusFB is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->status);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeightsFB-status-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceExpressionWeightsFB member status is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazeFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeTrackerCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EYE_TRACKER_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEyeTrackerCreateInfoFB",
                             value->type, "VUID-XrEyeTrackerCreateInfoFB-type-type", XR_TYPE_EYE_TRACKER_CREATE_INFO_FB, "XR_TYPE_EYE_TRACKER_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEyeTrackerCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEyeTrackerCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEyeTrackerCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEyeTrackerCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEyeTrackerCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazesInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EYE_GAZES_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEyeGazesInfoFB",
                             value->type, "VUID-XrEyeGazesInfoFB-type-type", XR_TYPE_EYE_GAZES_INFO_FB, "XR_TYPE_EYE_GAZES_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazesInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEyeGazesInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEyeGazesInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazesInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEyeGazesInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrEyeGazesInfoFB-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemEyeTrackingPropertiesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemEyeTrackingPropertiesFB",
                             value->type, "VUID-XrSystemEyeTrackingPropertiesFB-type-type", XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB, "XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemEyeTrackingPropertiesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemEyeTrackingPropertiesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemEyeTrackingPropertiesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemEyeTrackingPropertiesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemEyeTrackingPropertiesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEyeGazesFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EYE_GAZES_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEyeGazesFB",
                             value->type, "VUID-XrEyeGazesFB-type-type", XR_TYPE_EYE_GAZES_FB, "XR_TYPE_EYE_GAZES_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazesFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEyeGazesFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEyeGazesFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEyeGazesFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEyeGazesFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    for (uint32_t value_gaze_inc = 0; value_gaze_inc < XR_EYE_POSITION_COUNT_FB; ++value_gaze_inc) {
        // Validate that the structure XrEyeGazeFB is valid
        xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                        check_members, &value->gaze[value_gaze_inc]);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(instance_info, "VUID-XrEyeGazesFB-gaze-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info,
                                "Structure XrEyeGazesFB member gaze is invalid");
            return xr_result;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughKeyboardHandsIntensityFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughKeyboardHandsIntensityFB",
                             value->type, "VUID-XrPassthroughKeyboardHandsIntensityFB-type-type", XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB, "XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughKeyboardHandsIntensityFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughKeyboardHandsIntensityFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughKeyboardHandsIntensityFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughKeyboardHandsIntensityFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughKeyboardHandsIntensityFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerSettingsFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerSettingsFB",
                             value->type, "VUID-XrCompositionLayerSettingsFB-type-type", XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB, "XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSettingsFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerSettingsFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerSettingsFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSettingsFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerSettingsFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_settings_flags_fb_result = ValidateXrCompositionLayerSettingsFlagsFB(value->layerFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == composition_layer_settings_flags_fb_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSettingsFB-layerFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrCompositionLayerSettingsFlagsFB \"layerFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != composition_layer_settings_flags_fb_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerSettingsFB invalid member XrCompositionLayerSettingsFlagsFB \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerSettingsFB-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHapticPcmVibrationFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHapticPcmVibrationFB",
                             value->type, "VUID-XrHapticPcmVibrationFB-type-type", XR_TYPE_HAPTIC_PCM_VIBRATION_FB, "XR_TYPE_HAPTIC_PCM_VIBRATION_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticPcmVibrationFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHapticPcmVibrationFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHapticPcmVibrationFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHapticPcmVibrationFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHapticPcmVibrationFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->bufferSize && nullptr != value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticPcmVibrationFB-bufferSize-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHapticPcmVibrationFB member bufferSize is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->buffer && 0 != value->bufferSize) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticPcmVibrationFB-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHapticPcmVibrationFB contains invalid NULL for float \"buffer\" is which not "
                            "optional since \"bufferSize\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHapticPcmVibrationFB-buffer-parameter" type
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->samplesConsumed) {
        CoreValidLogMessage(instance_info, "VUID-XrHapticPcmVibrationFB-samplesConsumed-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHapticPcmVibrationFB contains invalid NULL for uint32_t \"samplesConsumed\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrHapticPcmVibrationFB-samplesConsumed-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrDevicePcmSampleRateStateFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrDevicePcmSampleRateStateFB",
                             value->type, "VUID-XrDevicePcmSampleRateStateFB-type-type", XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB, "XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrDevicePcmSampleRateStateFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrDevicePcmSampleRateStateFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrDevicePcmSampleRateStateFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrDevicePcmSampleRateStateFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrDevicePcmSampleRateStateFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerDepthTestFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerDepthTestFB",
                             value->type, "VUID-XrCompositionLayerDepthTestFB-type-type", XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB, "XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthTestFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerDepthTestFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerDepthTestFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthTestFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerDepthTestFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrCompareOpFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrCompositionLayerDepthTestFB", "compareOp", objects_info, value->compareOp)) {
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerDepthTestFB contains invalid XrCompareOpFB \"compareOp\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->compareOp));
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerDepthTestFB-compareOp-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrLocalDimmingFrameEndInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrLocalDimmingFrameEndInfoMETA",
                             value->type, "VUID-XrLocalDimmingFrameEndInfoMETA-type-type", XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META, "XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrLocalDimmingFrameEndInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrLocalDimmingFrameEndInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrLocalDimmingFrameEndInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrLocalDimmingFrameEndInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrLocalDimmingFrameEndInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrLocalDimmingModeMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrLocalDimmingFrameEndInfoMETA", "localDimmingMode", objects_info, value->localDimmingMode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrLocalDimmingFrameEndInfoMETA contains invalid XrLocalDimmingModeMETA \"localDimmingMode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->localDimmingMode));
        CoreValidLogMessage(instance_info, "VUID-XrLocalDimmingFrameEndInfoMETA-localDimmingMode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughPreferencesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_PREFERENCES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughPreferencesMETA",
                             value->type, "VUID-XrPassthroughPreferencesMETA-type-type", XR_TYPE_PASSTHROUGH_PREFERENCES_META, "XR_TYPE_PASSTHROUGH_PREFERENCES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughPreferencesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughPreferencesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughPreferencesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughPreferencesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughPreferencesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult passthrough_preference_flags_meta_result = ValidateXrPassthroughPreferenceFlagsMETA(value->flags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == passthrough_preference_flags_meta_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughPreferencesMETA-flags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPassthroughPreferenceFlagsMETA \"flags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != passthrough_preference_flags_meta_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughPreferencesMETA invalid member XrPassthroughPreferenceFlagsMETA \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughPreferencesMETA-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemVirtualKeyboardPropertiesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemVirtualKeyboardPropertiesMETA",
                             value->type, "VUID-XrSystemVirtualKeyboardPropertiesMETA-type-type", XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META, "XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemVirtualKeyboardPropertiesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemVirtualKeyboardPropertiesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemVirtualKeyboardPropertiesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemVirtualKeyboardPropertiesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemVirtualKeyboardPropertiesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardCreateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardCreateInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardCreateInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardCreateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardCreateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardCreateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardCreateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardCreateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardSpaceCreateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardSpaceCreateInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardSpaceCreateInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardSpaceCreateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardSpaceCreateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardSpaceCreateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardSpaceCreateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardSpaceCreateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrVirtualKeyboardLocationTypeMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrVirtualKeyboardSpaceCreateInfoMETA", "locationType", objects_info, value->locationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrVirtualKeyboardSpaceCreateInfoMETA contains invalid XrVirtualKeyboardLocationTypeMETA \"locationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationType));
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardSpaceCreateInfoMETA-locationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardSpaceCreateInfoMETA-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardLocationInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardLocationInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardLocationInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardLocationInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardLocationInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardLocationInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardLocationInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardLocationInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrVirtualKeyboardLocationTypeMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrVirtualKeyboardLocationInfoMETA", "locationType", objects_info, value->locationType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrVirtualKeyboardLocationInfoMETA contains invalid XrVirtualKeyboardLocationTypeMETA \"locationType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationType));
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardLocationInfoMETA-locationType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardLocationInfoMETA-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardModelVisibilitySetInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardModelVisibilitySetInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardModelVisibilitySetInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelVisibilitySetInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardModelVisibilitySetInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardModelVisibilitySetInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelVisibilitySetInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardModelVisibilitySetInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardAnimationStateMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardAnimationStateMETA",
                             value->type, "VUID-XrVirtualKeyboardAnimationStateMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META, "XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardAnimationStateMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardAnimationStateMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardAnimationStateMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardAnimationStateMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardAnimationStateMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardModelAnimationStatesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardModelAnimationStatesMETA",
                             value->type, "VUID-XrVirtualKeyboardModelAnimationStatesMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META, "XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelAnimationStatesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardModelAnimationStatesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardModelAnimationStatesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelAnimationStatesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardModelAnimationStatesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->stateCapacityInput is non-zero
    if (0 != value->stateCapacityInput && nullptr == value->states) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelAnimationStatesMETA-states-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrVirtualKeyboardModelAnimationStatesMETA member stateCapacityInput is NULL, but value->stateCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->states) {
        for (uint32_t value_states_inc = 0; value_states_inc < value->stateCapacityInput; ++value_states_inc) {
            // Validate that the structure XrVirtualKeyboardAnimationStateMETA is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->states[value_states_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardModelAnimationStatesMETA-states-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrVirtualKeyboardModelAnimationStatesMETA member states is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardTextureDataMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardTextureDataMETA",
                             value->type, "VUID-XrVirtualKeyboardTextureDataMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META, "XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextureDataMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardTextureDataMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardTextureDataMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextureDataMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardTextureDataMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->bufferCapacityInput is non-zero
    if (0 != value->bufferCapacityInput && nullptr == value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextureDataMETA-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrVirtualKeyboardTextureDataMETA member bufferCapacityInput is NULL, but value->bufferCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVirtualKeyboardTextureDataMETA-buffer-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardInputInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardInputInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardInputInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardInputInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardInputInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardInputInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardInputInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardInputInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrVirtualKeyboardInputSourceMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrVirtualKeyboardInputInfoMETA", "inputSource", objects_info, value->inputSource)) {
        std::ostringstream oss_enum;
        oss_enum << "XrVirtualKeyboardInputInfoMETA contains invalid XrVirtualKeyboardInputSourceMETA \"inputSource\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->inputSource));
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardInputInfoMETA-inputSource-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->inputSpace);
        if (handle_result == VALIDATE_XR_HANDLE_INVALID) {
            // Not a valid handle
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"inputSpace\" ";
            oss << HandleToHexString(value->inputSpace);
            CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardInputInfoMETA-inputSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    ValidateXrFlagsResult virtual_keyboard_input_state_flags_meta_result = ValidateXrVirtualKeyboardInputStateFlagsMETA(value->inputState);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == virtual_keyboard_input_state_flags_meta_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrVirtualKeyboardInputInfoMETA invalid member XrVirtualKeyboardInputStateFlagsMETA \"inputState\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->inputState));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardInputInfoMETA-inputState-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVirtualKeyboardTextContextChangeInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVirtualKeyboardTextContextChangeInfoMETA",
                             value->type, "VUID-XrVirtualKeyboardTextContextChangeInfoMETA-type-type", XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META, "XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextContextChangeInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVirtualKeyboardTextContextChangeInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVirtualKeyboardTextContextChangeInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextContextChangeInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVirtualKeyboardTextContextChangeInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->textContext) {
        CoreValidLogMessage(instance_info, "VUID-XrVirtualKeyboardTextContextChangeInfoMETA-textContext-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrVirtualKeyboardTextContextChangeInfoMETA contains invalid NULL for char \"textContext\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrVirtualKeyboardTextContextChangeInfoMETA-textContext-parameter" null-termination
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardCommitTextMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVirtualKeyboardCommitTextMETA",
                             value->type, "VUID-XrEventDataVirtualKeyboardCommitTextMETA-type-type", XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META, "XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardCommitTextMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVirtualKeyboardCommitTextMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVirtualKeyboardCommitTextMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardCommitTextMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVirtualKeyboardCommitTextMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&value->keyboard);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
            oss << HandleToHexString(value->keyboard);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardCommitTextMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    if (XR_MAX_VIRTUAL_KEYBOARD_COMMIT_TEXT_SIZE_META < std::strlen(value->text)) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardCommitTextMETA-text-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrEventDataVirtualKeyboardCommitTextMETA member text length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardBackspaceMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVirtualKeyboardBackspaceMETA",
                             value->type, "VUID-XrEventDataVirtualKeyboardBackspaceMETA-type-type", XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META, "XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardBackspaceMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVirtualKeyboardBackspaceMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVirtualKeyboardBackspaceMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardBackspaceMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVirtualKeyboardBackspaceMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&value->keyboard);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
            oss << HandleToHexString(value->keyboard);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardBackspaceMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardEnterMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVirtualKeyboardEnterMETA",
                             value->type, "VUID-XrEventDataVirtualKeyboardEnterMETA-type-type", XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META, "XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardEnterMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVirtualKeyboardEnterMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVirtualKeyboardEnterMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardEnterMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVirtualKeyboardEnterMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&value->keyboard);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
            oss << HandleToHexString(value->keyboard);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardEnterMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardShownMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVirtualKeyboardShownMETA",
                             value->type, "VUID-XrEventDataVirtualKeyboardShownMETA-type-type", XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META, "XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardShownMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVirtualKeyboardShownMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVirtualKeyboardShownMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardShownMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVirtualKeyboardShownMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&value->keyboard);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
            oss << HandleToHexString(value->keyboard);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardShownMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataVirtualKeyboardHiddenMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataVirtualKeyboardHiddenMETA",
                             value->type, "VUID-XrEventDataVirtualKeyboardHiddenMETA-type-type", XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META, "XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardHiddenMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataVirtualKeyboardHiddenMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataVirtualKeyboardHiddenMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardHiddenMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataVirtualKeyboardHiddenMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&value->keyboard);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
            oss << HandleToHexString(value->keyboard);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataVirtualKeyboardHiddenMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraIntrinsicsOCULUS* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraExtrinsicsOCULUS* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult external_camera_status_flags_oculus_result = ValidateXrExternalCameraStatusFlagsOCULUS(value->cameraStatusFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == external_camera_status_flags_oculus_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrExternalCameraExtrinsicsOCULUS invalid member XrExternalCameraStatusFlagsOCULUS \"cameraStatusFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->cameraStatusFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraExtrinsicsOCULUS-cameraStatusFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrExternalCameraAttachedToDeviceOCULUS value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrExternalCameraExtrinsicsOCULUS", "attachedToDevice", objects_info, value->attachedToDevice)) {
        std::ostringstream oss_enum;
        oss_enum << "XrExternalCameraExtrinsicsOCULUS contains invalid XrExternalCameraAttachedToDeviceOCULUS \"attachedToDevice\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->attachedToDevice));
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraExtrinsicsOCULUS-attachedToDevice-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExternalCameraOCULUS* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EXTERNAL_CAMERA_OCULUS) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrExternalCameraOCULUS",
                             value->type, "VUID-XrExternalCameraOCULUS-type-type", XR_TYPE_EXTERNAL_CAMERA_OCULUS, "XR_TYPE_EXTERNAL_CAMERA_OCULUS");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraOCULUS-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrExternalCameraOCULUS struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrExternalCameraOCULUS : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraOCULUS-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrExternalCameraOCULUS struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_EXTERNAL_CAMERA_NAME_SIZE_OCULUS < std::strlen(value->name)) {
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraOCULUS-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrExternalCameraOCULUS member name length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrExternalCameraIntrinsicsOCULUS is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->intrinsics);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraOCULUS-intrinsics-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrExternalCameraOCULUS member intrinsics is invalid");
        return xr_result;
    }
    // Validate that the structure XrExternalCameraExtrinsicsOCULUS is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->extrinsics);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrExternalCameraOCULUS-extrinsics-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrExternalCameraOCULUS member extrinsics is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#if defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrVulkanSwapchainCreateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrVulkanSwapchainCreateInfoMETA",
                             value->type, "VUID-XrVulkanSwapchainCreateInfoMETA-type-type", XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META, "XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainCreateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrVulkanSwapchainCreateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrVulkanSwapchainCreateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrVulkanSwapchainCreateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrVulkanSwapchainCreateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPerformanceMetricsStateMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PERFORMANCE_METRICS_STATE_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPerformanceMetricsStateMETA",
                             value->type, "VUID-XrPerformanceMetricsStateMETA-type-type", XR_TYPE_PERFORMANCE_METRICS_STATE_META, "XR_TYPE_PERFORMANCE_METRICS_STATE_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsStateMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPerformanceMetricsStateMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPerformanceMetricsStateMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsStateMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPerformanceMetricsStateMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPerformanceMetricsCounterMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PERFORMANCE_METRICS_COUNTER_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPerformanceMetricsCounterMETA",
                             value->type, "VUID-XrPerformanceMetricsCounterMETA-type-type", XR_TYPE_PERFORMANCE_METRICS_COUNTER_META, "XR_TYPE_PERFORMANCE_METRICS_COUNTER_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsCounterMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPerformanceMetricsCounterMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPerformanceMetricsCounterMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsCounterMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPerformanceMetricsCounterMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult performance_metrics_counter_flags_meta_result = ValidateXrPerformanceMetricsCounterFlagsMETA(value->counterFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == performance_metrics_counter_flags_meta_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPerformanceMetricsCounterMETA invalid member XrPerformanceMetricsCounterFlagsMETA \"counterFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->counterFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsCounterMETA-counterFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPerformanceMetricsCounterUnitMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPerformanceMetricsCounterMETA", "counterUnit", objects_info, value->counterUnit)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPerformanceMetricsCounterMETA contains invalid XrPerformanceMetricsCounterUnitMETA \"counterUnit\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->counterUnit));
        CoreValidLogMessage(instance_info, "VUID-XrPerformanceMetricsCounterMETA-counterUnit-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceListSaveInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_LIST_SAVE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceListSaveInfoFB",
                             value->type, "VUID-XrSpaceListSaveInfoFB-type-type", XR_TYPE_SPACE_LIST_SAVE_INFO_FB, "XR_TYPE_SPACE_LIST_SAVE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceListSaveInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceListSaveInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceListSaveInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->spaceCount && nullptr != value->spaces) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-spaceCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceListSaveInfoFB member spaceCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->spaces && 0 != value->spaceCount) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-spaces-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrSpaceListSaveInfoFB contains invalid NULL for XrSpace \"spaces\" is which not "
                            "optional since \"spaceCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->spaces) {
        for (uint32_t value_spaces_inc = 0; value_spaces_inc < value->spaceCount; ++value_spaces_inc) {
            {
                // writeValidateInlineHandleValidation
                ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->spaces[value_spaces_inc]);
                if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                    // Not a valid handle or NULL (which is not valid in this case)
                    std::ostringstream oss;
                    oss << "Invalid XrSpace handle \"spaces\" ";
                    oss << HandleToHexString(value->spaces[value_spaces_inc]);
                    CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-spaces-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                        objects_info, oss.str());
                    return XR_ERROR_HANDLE_INVALID;
                }
            }
        }
    }
    // Make sure the enum type XrSpaceStorageLocationFB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrSpaceListSaveInfoFB", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrSpaceListSaveInfoFB contains invalid XrSpaceStorageLocationFB \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrSpaceListSaveInfoFB-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataSpaceListSaveCompleteFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataSpaceListSaveCompleteFB",
                             value->type, "VUID-XrEventDataSpaceListSaveCompleteFB-type-type", XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB, "XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceListSaveCompleteFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataSpaceListSaveCompleteFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataSpaceListSaveCompleteFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceListSaveCompleteFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataSpaceListSaveCompleteFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrResult value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataSpaceListSaveCompleteFB", "result", objects_info, value->result)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataSpaceListSaveCompleteFB contains invalid XrResult \"result\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->result));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataSpaceListSaveCompleteFB-result-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceUserCreateInfoFB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_USER_CREATE_INFO_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceUserCreateInfoFB",
                             value->type, "VUID-XrSpaceUserCreateInfoFB-type-type", XR_TYPE_SPACE_USER_CREATE_INFO_FB, "XR_TYPE_SPACE_USER_CREATE_INFO_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUserCreateInfoFB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceUserCreateInfoFB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceUserCreateInfoFB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceUserCreateInfoFB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceUserCreateInfoFB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemHeadsetIdPropertiesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemHeadsetIdPropertiesMETA",
                             value->type, "VUID-XrSystemHeadsetIdPropertiesMETA-type-type", XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META, "XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemHeadsetIdPropertiesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemHeadsetIdPropertiesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemHeadsetIdPropertiesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemHeadsetIdPropertiesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemHeadsetIdPropertiesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRecommendedLayerResolutionMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRecommendedLayerResolutionMETA",
                             value->type, "VUID-XrRecommendedLayerResolutionMETA-type-type", XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META, "XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRecommendedLayerResolutionMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRecommendedLayerResolutionMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRecommendedLayerResolutionMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrRecommendedLayerResolutionGetInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrRecommendedLayerResolutionGetInfoMETA",
                             value->type, "VUID-XrRecommendedLayerResolutionGetInfoMETA-type-type", XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META, "XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrRecommendedLayerResolutionGetInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrRecommendedLayerResolutionGetInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrRecommendedLayerResolutionGetInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional pointer/array variable that needs to not be NULL
    if (nullptr == value->layer) {
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrRecommendedLayerResolutionGetInfoMETA contains invalid NULL for XrCompositionLayerBaseHeader \"layer\" which is not "
                            "optional and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerProjection and it is valid
    {
        const XrCompositionLayerProjection* new_compositionlayerprojection_value = reinterpret_cast<const XrCompositionLayerProjection*>(value->layer);
        if (new_compositionlayerprojection_value->type == XR_TYPE_COMPOSITION_LAYER_PROJECTION) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayerprojection_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerQuad and it is valid
    {
        const XrCompositionLayerQuad* new_compositionlayerquad_value = reinterpret_cast<const XrCompositionLayerQuad*>(value->layer);
        if (new_compositionlayerquad_value->type == XR_TYPE_COMPOSITION_LAYER_QUAD) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayerquad_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCubeKHR and it is valid
    {
        const XrCompositionLayerCubeKHR* new_compositionlayercubekhr_value = reinterpret_cast<const XrCompositionLayerCubeKHR*>(value->layer);
        if (new_compositionlayercubekhr_value->type == XR_TYPE_COMPOSITION_LAYER_CUBE_KHR) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayercubekhr_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerCylinderKHR and it is valid
    {
        const XrCompositionLayerCylinderKHR* new_compositionlayercylinderkhr_value = reinterpret_cast<const XrCompositionLayerCylinderKHR*>(value->layer);
        if (new_compositionlayercylinderkhr_value->type == XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayercylinderkhr_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirectKHR and it is valid
    {
        const XrCompositionLayerEquirectKHR* new_compositionlayerequirectkhr_value = reinterpret_cast<const XrCompositionLayerEquirectKHR*>(value->layer);
        if (new_compositionlayerequirectkhr_value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayerequirectkhr_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerEquirect2KHR and it is valid
    {
        const XrCompositionLayerEquirect2KHR* new_compositionlayerequirect2khr_value = reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(value->layer);
        if (new_compositionlayerequirect2khr_value->type == XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayerequirect2khr_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate if XrCompositionLayerBaseHeader is a child structure of type XrCompositionLayerPassthroughHTC and it is valid
    {
        const XrCompositionLayerPassthroughHTC* new_compositionlayerpassthroughhtc_value = reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(value->layer);
        if (new_compositionlayerpassthroughhtc_value->type == XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
            xr_result = ValidateXrStruct(instance_info, command_name,
                                                            objects_info, check_members, new_compositionlayerpassthroughhtc_value);
            if (XR_SUCCESS != xr_result) {
                std::string error_message = "Structure XrRecommendedLayerResolutionGetInfoMETA member layer";
                error_message += " is invalid";
                CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    error_message);
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Validate that the base-structure XrCompositionLayerBaseHeader is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, value->layer);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrRecommendedLayerResolutionGetInfoMETA-layer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrRecommendedLayerResolutionGetInfoMETA member layer is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutDataMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->bufferSize && nullptr != value->buffer) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutDataMETA-bufferSize-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPassthroughColorLutDataMETA member bufferSize is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->buffer && 0 != value->bufferSize) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutDataMETA-buffer-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrPassthroughColorLutDataMETA contains invalid NULL for uint8_t \"buffer\" is which not "
                            "optional since \"bufferSize\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrPassthroughColorLutDataMETA-buffer-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutCreateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorLutCreateInfoMETA",
                             value->type, "VUID-XrPassthroughColorLutCreateInfoMETA-type-type", XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META, "XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutCreateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorLutCreateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorLutCreateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutCreateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorLutCreateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrPassthroughColorLutChannelsMETA value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPassthroughColorLutCreateInfoMETA", "channels", objects_info, value->channels)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughColorLutCreateInfoMETA contains invalid XrPassthroughColorLutChannelsMETA \"channels\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->channels));
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutCreateInfoMETA-channels-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Validate that the structure XrPassthroughColorLutDataMETA is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->data);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutCreateInfoMETA-data-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPassthroughColorLutCreateInfoMETA member data is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorLutUpdateInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorLutUpdateInfoMETA",
                             value->type, "VUID-XrPassthroughColorLutUpdateInfoMETA-type-type", XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META, "XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutUpdateInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorLutUpdateInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorLutUpdateInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutUpdateInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorLutUpdateInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Validate that the structure XrPassthroughColorLutDataMETA is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->data);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorLutUpdateInfoMETA-data-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPassthroughColorLutUpdateInfoMETA member data is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapLutMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorMapLutMETA",
                             value->type, "VUID-XrPassthroughColorMapLutMETA-type-type", XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META, "XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapLutMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorMapLutMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorMapLutMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapLutMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorMapLutMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughColorLutMETAHandle(&value->colorLut);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughColorLutMETA handle \"colorLut\" ";
            oss << HandleToHexString(value->colorLut);
            CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapLutMETA-colorLut-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorMapInterpolatedLutMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorMapInterpolatedLutMETA",
                             value->type, "VUID-XrPassthroughColorMapInterpolatedLutMETA-type-type", XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META, "XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapInterpolatedLutMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorMapInterpolatedLutMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorMapInterpolatedLutMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapInterpolatedLutMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorMapInterpolatedLutMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughColorLutMETAHandle(&value->sourceColorLut);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughColorLutMETA handle \"sourceColorLut\" ";
            oss << HandleToHexString(value->sourceColorLut);
            CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapInterpolatedLutMETA-sourceColorLut-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughColorLutMETAHandle(&value->targetColorLut);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughColorLutMETA handle \"targetColorLut\" ";
            oss << HandleToHexString(value->targetColorLut);
            CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorMapInterpolatedLutMETA-targetColorLut-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPassthroughColorLutPropertiesMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemPassthroughColorLutPropertiesMETA",
                             value->type, "VUID-XrSystemPassthroughColorLutPropertiesMETA-type-type", XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META, "XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughColorLutPropertiesMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemPassthroughColorLutPropertiesMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemPassthroughColorLutPropertiesMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemPassthroughColorLutPropertiesMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemPassthroughColorLutPropertiesMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceTriangleMeshGetInfoMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceTriangleMeshGetInfoMETA",
                             value->type, "VUID-XrSpaceTriangleMeshGetInfoMETA-type-type", XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META, "XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshGetInfoMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceTriangleMeshGetInfoMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceTriangleMeshGetInfoMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshGetInfoMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceTriangleMeshGetInfoMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpaceTriangleMeshMETA* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPACE_TRIANGLE_MESH_META) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpaceTriangleMeshMETA",
                             value->type, "VUID-XrSpaceTriangleMeshMETA-type-type", XR_TYPE_SPACE_TRIANGLE_MESH_META, "XR_TYPE_SPACE_TRIANGLE_MESH_META");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshMETA-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpaceTriangleMeshMETA struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpaceTriangleMeshMETA : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshMETA-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpaceTriangleMeshMETA struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshMETA-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceTriangleMeshMETA member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSpaceTriangleMeshMETA-vertices-parameter" type
    // Optional array must be non-NULL when value->indexCapacityInput is non-zero
    if (0 != value->indexCapacityInput && nullptr == value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrSpaceTriangleMeshMETA-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpaceTriangleMeshMETA member indexCapacityInput is NULL, but value->indexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrSpaceTriangleMeshMETA-indices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemFaceTrackingProperties2FB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemFaceTrackingProperties2FB",
                             value->type, "VUID-XrSystemFaceTrackingProperties2FB-type-type", XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB, "XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemFaceTrackingProperties2FB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemFaceTrackingProperties2FB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemFaceTrackingProperties2FB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemFaceTrackingProperties2FB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemFaceTrackingProperties2FB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceTrackerCreateInfo2FB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceTrackerCreateInfo2FB",
                             value->type, "VUID-XrFaceTrackerCreateInfo2FB-type-type", XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB, "XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfo2FB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceTrackerCreateInfo2FB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceTrackerCreateInfo2FB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfo2FB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceTrackerCreateInfo2FB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFaceExpressionSet2FB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFaceTrackerCreateInfo2FB", "faceExpressionSet", objects_info, value->faceExpressionSet)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFaceTrackerCreateInfo2FB contains invalid XrFaceExpressionSet2FB \"faceExpressionSet\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->faceExpressionSet));
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfo2FB-faceExpressionSet-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Optional array must be non-NULL when value->requestedDataSourceCount is non-zero
    if (0 != value->requestedDataSourceCount && nullptr == value->requestedDataSources) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceTrackerCreateInfo2FB-requestedDataSources-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceTrackerCreateInfo2FB member requestedDataSourceCount is NULL, but value->requestedDataSourceCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
            // NOTE: Can't validate "VUID-XrFaceTrackerCreateInfo2FB-requestedDataSources-parameter" output enum buffer
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionInfo2FB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_EXPRESSION_INFO2_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceExpressionInfo2FB",
                             value->type, "VUID-XrFaceExpressionInfo2FB-type-type", XR_TYPE_FACE_EXPRESSION_INFO2_FB, "XR_TYPE_FACE_EXPRESSION_INFO2_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionInfo2FB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceExpressionInfo2FB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceExpressionInfo2FB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionInfo2FB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceExpressionInfo2FB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFaceExpressionWeights2FB* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFaceExpressionWeights2FB",
                             value->type, "VUID-XrFaceExpressionWeights2FB-type-type", XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB, "XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFaceExpressionWeights2FB struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFaceExpressionWeights2FB : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFaceExpressionWeights2FB struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->weightCount && nullptr != value->weights) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-weightCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceExpressionWeights2FB member weightCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->weights && 0 != value->weightCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-weights-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFaceExpressionWeights2FB contains invalid NULL for float \"weights\" is which not "
                            "optional since \"weightCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrFaceExpressionWeights2FB-weights-parameter" type
    // Non-optional array length must be non-zero
    if (0 >= value->confidenceCount && nullptr != value->confidences) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-confidenceCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFaceExpressionWeights2FB member confidenceCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->confidences && 0 != value->confidenceCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-confidences-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFaceExpressionWeights2FB contains invalid NULL for float \"confidences\" is which not "
                            "optional since \"confidenceCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrFaceExpressionWeights2FB-confidences-parameter" type
    // Make sure the enum type XrFaceTrackingDataSource2FB value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFaceExpressionWeights2FB", "dataSource", objects_info, value->dataSource)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFaceExpressionWeights2FB contains invalid XrFaceTrackingDataSource2FB \"dataSource\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dataSource));
        CoreValidLogMessage(instance_info, "VUID-XrFaceExpressionWeights2FB-dataSource-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughCreateInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughCreateInfoHTC",
                             value->type, "VUID-XrPassthroughCreateInfoHTC-type-type", XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC, "XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughCreateInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughCreateInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughCreateInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrPassthroughFormHTC value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPassthroughCreateInfoHTC", "form", objects_info, value->form)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPassthroughCreateInfoHTC contains invalid XrPassthroughFormHTC \"form\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->form));
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughCreateInfoHTC-form-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughColorHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_COLOR_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughColorHTC",
                             value->type, "VUID-XrPassthroughColorHTC-type-type", XR_TYPE_PASSTHROUGH_COLOR_HTC, "XR_TYPE_PASSTHROUGH_COLOR_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughColorHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughColorHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughColorHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughColorHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPassthroughMeshTransformInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPassthroughMeshTransformInfoHTC",
                             value->type, "VUID-XrPassthroughMeshTransformInfoHTC-type-type", XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC, "XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPassthroughMeshTransformInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPassthroughMeshTransformInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPassthroughMeshTransformInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->vertexCount && nullptr != value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-vertexCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPassthroughMeshTransformInfoHTC member vertexCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->vertices && 0 != value->vertexCount) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrPassthroughMeshTransformInfoHTC contains invalid NULL for XrVector3f \"vertices\" is which not "
                            "optional since \"vertexCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrPassthroughMeshTransformInfoHTC-vertices-parameter" type
    // Non-optional array length must be non-zero
    if (0 >= value->indexCount && nullptr != value->indices) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-indexCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPassthroughMeshTransformInfoHTC member indexCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->indices && 0 != value->indexCount) {
        CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-indices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrPassthroughMeshTransformInfoHTC contains invalid NULL for uint32_t \"indices\" is which not "
                            "optional since \"indexCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrPassthroughMeshTransformInfoHTC-indices-parameter" type
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrPassthroughMeshTransformInfoHTC-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrCompositionLayerPassthroughHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrCompositionLayerPassthroughHTC",
                             value->type, "VUID-XrCompositionLayerPassthroughHTC-type-type", XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC, "XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrCompositionLayerPassthroughHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrCompositionLayerPassthroughHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrCompositionLayerPassthroughHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult composition_layer_flags_result = ValidateXrCompositionLayerFlags(value->layerFlags);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == composition_layer_flags_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-layerFlags-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrCompositionLayerFlags \"layerFlags\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != composition_layer_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrCompositionLayerPassthroughHTC invalid member XrCompositionLayerFlags \"layerFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->layerFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-layerFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrPassthroughHTCHandle(&value->passthrough);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrPassthroughHTC handle \"passthrough\" ";
            oss << HandleToHexString(value->passthrough);
            CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-passthrough-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Validate that the structure XrPassthroughColorHTC is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->color);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrCompositionLayerPassthroughHTC-color-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrCompositionLayerPassthroughHTC member color is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationApplyInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_APPLY_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationApplyInfoHTC",
                             value->type, "VUID-XrFoveationApplyInfoHTC-type-type", XR_TYPE_FOVEATION_APPLY_INFO_HTC, "XR_TYPE_FOVEATION_APPLY_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    valid_ext_structs.push_back(XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC);
    valid_ext_structs.push_back(XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC);
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationApplyInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationApplyInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationApplyInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFoveationModeHTC value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFoveationApplyInfoHTC", "mode", objects_info, value->mode)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationApplyInfoHTC contains invalid XrFoveationModeHTC \"mode\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->mode));
        CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-mode-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->subImageCount && nullptr != value->subImages) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-subImageCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFoveationApplyInfoHTC member subImageCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->subImages && 0 != value->subImageCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-subImages-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFoveationApplyInfoHTC contains invalid NULL for XrSwapchainSubImage \"subImages\" is which not "
                            "optional since \"subImageCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->subImages) {
        for (uint32_t value_subimages_inc = 0; value_subimages_inc < value->subImageCount; ++value_subimages_inc) {
            // Validate that the structure XrSwapchainSubImage is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->subImages[value_subimages_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrFoveationApplyInfoHTC-subImages-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrFoveationApplyInfoHTC member subImages is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationConfigurationHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrFoveationLevelHTC value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrFoveationConfigurationHTC", "level", objects_info, value->level)) {
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationConfigurationHTC contains invalid XrFoveationLevelHTC \"level\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->level));
        CoreValidLogMessage(instance_info, "VUID-XrFoveationConfigurationHTC-level-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationDynamicModeInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationDynamicModeInfoHTC",
                             value->type, "VUID-XrFoveationDynamicModeInfoHTC-type-type", XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC, "XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationDynamicModeInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationDynamicModeInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationDynamicModeInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationDynamicModeInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationDynamicModeInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult foveation_dynamic_flags_htc_result = ValidateXrFoveationDynamicFlagsHTC(value->dynamicFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == foveation_dynamic_flags_htc_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrFoveationDynamicModeInfoHTC invalid member XrFoveationDynamicFlagsHTC \"dynamicFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dynamicFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrFoveationDynamicModeInfoHTC-dynamicFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrFoveationCustomModeInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrFoveationCustomModeInfoHTC",
                             value->type, "VUID-XrFoveationCustomModeInfoHTC-type-type", XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC, "XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationCustomModeInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrFoveationCustomModeInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrFoveationCustomModeInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrFoveationCustomModeInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrFoveationCustomModeInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->configCount && nullptr != value->configs) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationCustomModeInfoHTC-configCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrFoveationCustomModeInfoHTC member configCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->configs && 0 != value->configCount) {
        CoreValidLogMessage(instance_info, "VUID-XrFoveationCustomModeInfoHTC-configs-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrFoveationCustomModeInfoHTC contains invalid NULL for XrFoveationConfigurationHTC \"configs\" is which not "
                            "optional since \"configCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->configs) {
        for (uint32_t value_configs_inc = 0; value_configs_inc < value->configCount; ++value_configs_inc) {
            // Validate that the structure XrFoveationConfigurationHTC is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->configs[value_configs_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrFoveationCustomModeInfoHTC-configs-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrFoveationCustomModeInfoHTC member configs is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemAnchorPropertiesHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemAnchorPropertiesHTC",
                             value->type, "VUID-XrSystemAnchorPropertiesHTC-type-type", XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC, "XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemAnchorPropertiesHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemAnchorPropertiesHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemAnchorPropertiesHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemAnchorPropertiesHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemAnchorPropertiesHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorNameHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    if (XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC < std::strlen(value->name)) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorNameHTC-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpatialAnchorNameHTC member name length is too long.");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSpatialAnchorCreateInfoHTC* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSpatialAnchorCreateInfoHTC",
                             value->type, "VUID-XrSpatialAnchorCreateInfoHTC-type-type", XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC, "XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoHTC-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSpatialAnchorCreateInfoHTC struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSpatialAnchorCreateInfoHTC : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoHTC-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSpatialAnchorCreateInfoHTC struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->space);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"space\" ";
            oss << HandleToHexString(value->space);
            CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoHTC-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Validate that the structure XrSpatialAnchorNameHTC is valid
    xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                    check_members, &value->name);
    if (XR_SUCCESS != xr_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSpatialAnchorCreateInfoHTC-name-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrSpatialAnchorCreateInfoHTC member name is invalid");
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSetPriorityEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&value->actionSet);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrActionSet handle \"actionSet\" ";
            oss << HandleToHexString(value->actionSet);
            CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPriorityEXT-actionSet-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrActiveActionSetPrioritiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrActiveActionSetPrioritiesEXT",
                             value->type, "VUID-XrActiveActionSetPrioritiesEXT-type-type", XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT, "XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPrioritiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrActiveActionSetPrioritiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrActiveActionSetPrioritiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPrioritiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrActiveActionSetPrioritiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->actionSetPriorityCount && nullptr != value->actionSetPriorities) {
        CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPrioritiesEXT-actionSetPriorityCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrActiveActionSetPrioritiesEXT member actionSetPriorityCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->actionSetPriorities && 0 != value->actionSetPriorityCount) {
        CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPrioritiesEXT-actionSetPriorities-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrActiveActionSetPrioritiesEXT contains invalid NULL for XrActiveActionSetPriorityEXT \"actionSetPriorities\" is which not "
                            "optional since \"actionSetPriorityCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->actionSetPriorities) {
        for (uint32_t value_actionsetpriorities_inc = 0; value_actionsetpriorities_inc < value->actionSetPriorityCount; ++value_actionsetpriorities_inc) {
            // Validate that the structure XrActiveActionSetPriorityEXT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->actionSetPriorities[value_actionsetpriorities_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrActiveActionSetPrioritiesEXT-actionSetPriorities-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrActiveActionSetPrioritiesEXT member actionSetPriorities is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemForceFeedbackCurlPropertiesMNDX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemForceFeedbackCurlPropertiesMNDX",
                             value->type, "VUID-XrSystemForceFeedbackCurlPropertiesMNDX-type-type", XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX, "XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemForceFeedbackCurlPropertiesMNDX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemForceFeedbackCurlPropertiesMNDX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemForceFeedbackCurlPropertiesMNDX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemForceFeedbackCurlPropertiesMNDX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemForceFeedbackCurlPropertiesMNDX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrForceFeedbackCurlApplyLocationMNDX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrForceFeedbackCurlLocationMNDX value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrForceFeedbackCurlApplyLocationMNDX", "location", objects_info, value->location)) {
        std::ostringstream oss_enum;
        oss_enum << "XrForceFeedbackCurlApplyLocationMNDX contains invalid XrForceFeedbackCurlLocationMNDX \"location\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->location));
        CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationMNDX-location-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrForceFeedbackCurlApplyLocationsMNDX* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrForceFeedbackCurlApplyLocationsMNDX",
                             value->type, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-type-type", XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX, "XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrForceFeedbackCurlApplyLocationsMNDX struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrForceFeedbackCurlApplyLocationsMNDX : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrForceFeedbackCurlApplyLocationsMNDX struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Non-optional array length must be non-zero
    if (0 >= value->locationCount && nullptr != value->locations) {
        CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-locationCount-arraylength",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrForceFeedbackCurlApplyLocationsMNDX member locationCount is non-optional and must be greater than 0");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->locations && 0 != value->locationCount) {
        CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-locations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrForceFeedbackCurlApplyLocationsMNDX contains invalid NULL for XrForceFeedbackCurlApplyLocationMNDX \"locations\" is which not "
                            "optional since \"locationCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->locations) {
        for (uint32_t value_locations_inc = 0; value_locations_inc < value->locationCount; ++value_locations_inc) {
            // Validate that the structure XrForceFeedbackCurlApplyLocationMNDX is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->locations[value_locations_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrForceFeedbackCurlApplyLocationsMNDX-locations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrForceFeedbackCurlApplyLocationsMNDX member locations is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingDataSourceInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingDataSourceInfoEXT",
                             value->type, "VUID-XrHandTrackingDataSourceInfoEXT-type-type", XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT, "XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingDataSourceInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingDataSourceInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingDataSourceInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->requestedDataSourceCount is non-zero
    if (0 != value->requestedDataSourceCount && nullptr == value->requestedDataSources) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceInfoEXT-requestedDataSources-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrHandTrackingDataSourceInfoEXT member requestedDataSourceCount is NULL, but value->requestedDataSourceCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Pointer/array variable with a length variable.  Make sure that
    // if length variable is non-zero that the pointer is not NULL
    if (nullptr == value->requestedDataSources && 0 != value->requestedDataSourceCount) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceInfoEXT-requestedDataSources-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name, objects_info,
                            "XrHandTrackingDataSourceInfoEXT contains invalid NULL for XrHandTrackingDataSourceEXT \"requestedDataSources\" is which not "
                            "optional since \"requestedDataSourceCount\" is set and must be non-NULL");
        return XR_ERROR_VALIDATION_FAILURE;
    }
            // NOTE: Can't validate "VUID-XrHandTrackingDataSourceInfoEXT-requestedDataSources-parameter" output enum buffer
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrHandTrackingDataSourceStateEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrHandTrackingDataSourceStateEXT",
                             value->type, "VUID-XrHandTrackingDataSourceStateEXT-type-type", XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT, "XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceStateEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrHandTrackingDataSourceStateEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrHandTrackingDataSourceStateEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceStateEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrHandTrackingDataSourceStateEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHandTrackingDataSourceEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrHandTrackingDataSourceStateEXT", "dataSource", objects_info, value->dataSource)) {
        std::ostringstream oss_enum;
        oss_enum << "XrHandTrackingDataSourceStateEXT contains invalid XrHandTrackingDataSourceEXT \"dataSource\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->dataSource));
        CoreValidLogMessage(instance_info, "VUID-XrHandTrackingDataSourceStateEXT-dataSource-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemPlaneDetectionPropertiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemPlaneDetectionPropertiesEXT",
                             value->type, "VUID-XrSystemPlaneDetectionPropertiesEXT-type-type", XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT, "XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPlaneDetectionPropertiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemPlaneDetectionPropertiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemPlaneDetectionPropertiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemPlaneDetectionPropertiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemPlaneDetectionPropertiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult plane_detection_capability_flags_ext_result = ValidateXrPlaneDetectionCapabilityFlagsEXT(value->supportedFeatures);
    // Flags must be non-zero in this case.
    if (VALIDATE_XR_FLAGS_ZERO == plane_detection_capability_flags_ext_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemPlaneDetectionPropertiesEXT-supportedFeatures-requiredbitmask",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "XrPlaneDetectionCapabilityFlagsEXT \"supportedFeatures\" flag must be non-zero");
        return XR_ERROR_VALIDATION_FAILURE;
    } else if (VALIDATE_XR_FLAGS_SUCCESS != plane_detection_capability_flags_ext_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrSystemPlaneDetectionPropertiesEXT invalid member XrPlaneDetectionCapabilityFlagsEXT \"supportedFeatures\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->supportedFeatures));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrSystemPlaneDetectionPropertiesEXT-supportedFeatures-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorCreateInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorCreateInfoEXT",
                             value->type, "VUID-XrPlaneDetectorCreateInfoEXT-type-type", XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT, "XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorCreateInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorCreateInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorCreateInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorCreateInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorCreateInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult plane_detector_flags_ext_result = ValidateXrPlaneDetectorFlagsEXT(value->flags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == plane_detector_flags_ext_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPlaneDetectorCreateInfoEXT invalid member XrPlaneDetectorFlagsEXT \"flags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->flags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorCreateInfoEXT-flags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrExtent3DfEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorBeginInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorBeginInfoEXT",
                             value->type, "VUID-XrPlaneDetectorBeginInfoEXT-type-type", XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT, "XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorBeginInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorBeginInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorBeginInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Optional array must be non-NULL when value->orientationCount is non-zero
    if (0 != value->orientationCount && nullptr == value->orientations) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-orientations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPlaneDetectorBeginInfoEXT member orientationCount is NULL, but value->orientationCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->orientations) {
        for (uint32_t value_orientations_inc = 0; value_orientations_inc < value->orientationCount; ++value_orientations_inc) {
            // Make sure the enum type XrPlaneDetectorOrientationEXT value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrPlaneDetectorBeginInfoEXT", "orientations", objects_info, value->orientations[value_orientations_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrPlaneDetectorBeginInfoEXT contains invalid XrPlaneDetectorOrientationEXT \"orientations\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->orientations[value_orientations_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-orientations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Optional array must be non-NULL when value->semanticTypeCount is non-zero
    if (0 != value->semanticTypeCount && nullptr == value->semanticTypes) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-semanticTypes-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPlaneDetectorBeginInfoEXT member semanticTypeCount is NULL, but value->semanticTypeCount is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->semanticTypes) {
        for (uint32_t value_semantictypes_inc = 0; value_semantictypes_inc < value->semanticTypeCount; ++value_semantictypes_inc) {
            // Make sure the enum type XrPlaneDetectorSemanticTypeEXT value is valid
            if (!ValidateXrEnum(instance_info, command_name, "XrPlaneDetectorBeginInfoEXT", "semanticTypes", objects_info, value->semanticTypes[value_semantictypes_inc])) {
                std::ostringstream oss_enum;
                oss_enum << "XrPlaneDetectorBeginInfoEXT contains invalid XrPlaneDetectorSemanticTypeEXT \"semanticTypes\" enum value ";
                oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->semanticTypes[value_semantictypes_inc]));
                CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorBeginInfoEXT-semanticTypes-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info, oss_enum.str());
                return XR_ERROR_VALIDATION_FAILURE;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorGetInfoEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorGetInfoEXT",
                             value->type, "VUID-XrPlaneDetectorGetInfoEXT-type-type", XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT, "XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorGetInfoEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorGetInfoEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorGetInfoEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorGetInfoEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorGetInfoEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&value->baseSpace);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSpace handle \"baseSpace\" ";
            oss << HandleToHexString(value->baseSpace);
            CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorGetInfoEXT-baseSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorLocationEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_LOCATION_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorLocationEXT",
                             value->type, "VUID-XrPlaneDetectorLocationEXT-type-type", XR_TYPE_PLANE_DETECTOR_LOCATION_EXT, "XR_TYPE_PLANE_DETECTOR_LOCATION_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorLocationEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorLocationEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorLocationEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    ValidateXrFlagsResult space_location_flags_result = ValidateXrSpaceLocationFlags(value->locationFlags);
    // Valid flags available, so it must be invalid to fail.
    if (VALIDATE_XR_FLAGS_INVALID == space_location_flags_result) {
        // Otherwise, flags must be valid.
        std::ostringstream oss_enum;
        oss_enum << "XrPlaneDetectorLocationEXT invalid member XrSpaceLocationFlags \"locationFlags\" flag value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->locationFlags));
        oss_enum <<" contains illegal bit";
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationEXT-locationFlags-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPlaneDetectorOrientationEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPlaneDetectorLocationEXT", "orientation", objects_info, value->orientation)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPlaneDetectorLocationEXT contains invalid XrPlaneDetectorOrientationEXT \"orientation\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->orientation));
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationEXT-orientation-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Make sure the enum type XrPlaneDetectorSemanticTypeEXT value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrPlaneDetectorLocationEXT", "semanticType", objects_info, value->semanticType)) {
        std::ostringstream oss_enum;
        oss_enum << "XrPlaneDetectorLocationEXT contains invalid XrPlaneDetectorSemanticTypeEXT \"semanticType\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->semanticType));
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationEXT-semanticType-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorLocationsEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorLocationsEXT",
                             value->type, "VUID-XrPlaneDetectorLocationsEXT-type-type", XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT, "XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationsEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorLocationsEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorLocationsEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationsEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorLocationsEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->planeLocationCapacityInput is non-zero
    if (0 != value->planeLocationCapacityInput && nullptr == value->planeLocations) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationsEXT-planeLocations-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPlaneDetectorLocationsEXT member planeLocationCapacityInput is NULL, but value->planeLocationCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    if (value->planeLocations) {
        for (uint32_t value_planelocations_inc = 0; value_planelocations_inc < value->planeLocationCapacityInput; ++value_planelocations_inc) {
            // Validate that the structure XrPlaneDetectorLocationEXT is valid
            xr_result = ValidateXrStruct(instance_info, command_name, objects_info,
                                                            check_members, &value->planeLocations[value_planelocations_inc]);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorLocationsEXT-planeLocations-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                    objects_info,
                                    "Structure XrPlaneDetectorLocationsEXT member planeLocations is invalid");
                return xr_result;
            }
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrPlaneDetectorPolygonBufferEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrPlaneDetectorPolygonBufferEXT",
                             value->type, "VUID-XrPlaneDetectorPolygonBufferEXT-type-type", XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT, "XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorPolygonBufferEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrPlaneDetectorPolygonBufferEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrPlaneDetectorPolygonBufferEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorPolygonBufferEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrPlaneDetectorPolygonBufferEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Optional array must be non-NULL when value->vertexCapacityInput is non-zero
    if (0 != value->vertexCapacityInput && nullptr == value->vertices) {
        CoreValidLogMessage(instance_info, "VUID-XrPlaneDetectorPolygonBufferEXT-vertices-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
                            "Structure XrPlaneDetectorPolygonBufferEXT member vertexCapacityInput is NULL, but value->vertexCapacityInput is greater than 0");
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // NOTE: Can't validate "VUID-XrPlaneDetectorPolygonBufferEXT-vertices-parameter" type
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataUserPresenceChangedEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataUserPresenceChangedEXT",
                             value->type, "VUID-XrEventDataUserPresenceChangedEXT-type-type", XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT, "XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataUserPresenceChangedEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataUserPresenceChangedEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataUserPresenceChangedEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataUserPresenceChangedEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataUserPresenceChangedEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    {
        // writeValidateInlineHandleValidation
        ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&value->session);
        if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
            // Not a valid handle or NULL (which is not valid in this case)
            std::ostringstream oss;
            oss << "Invalid XrSession handle \"session\" ";
            oss << HandleToHexString(value->session);
            CoreValidLogMessage(instance_info, "VUID-XrEventDataUserPresenceChangedEXT-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                                objects_info, oss.str());
            return XR_ERROR_HANDLE_INVALID;
        }
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrSystemUserPresencePropertiesEXT* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrSystemUserPresencePropertiesEXT",
                             value->type, "VUID-XrSystemUserPresencePropertiesEXT-type-type", XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT, "XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrSystemUserPresencePropertiesEXT-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrSystemUserPresencePropertiesEXT struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrSystemUserPresencePropertiesEXT : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrSystemUserPresencePropertiesEXT-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrSystemUserPresencePropertiesEXT struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataHeadsetFitChangedML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataHeadsetFitChangedML",
                             value->type, "VUID-XrEventDataHeadsetFitChangedML-type-type", XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML, "XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataHeadsetFitChangedML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataHeadsetFitChangedML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataHeadsetFitChangedML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataHeadsetFitChangedML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataHeadsetFitChangedML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrHeadsetFitStatusML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataHeadsetFitChangedML", "status", objects_info, value->status)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataHeadsetFitChangedML contains invalid XrHeadsetFitStatusML \"status\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->status));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataHeadsetFitChangedML-status-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrEventDataEyeCalibrationChangedML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrEventDataEyeCalibrationChangedML",
                             value->type, "VUID-XrEventDataEyeCalibrationChangedML-type-type", XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML, "XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrEventDataEyeCalibrationChangedML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrEventDataEyeCalibrationChangedML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrEventDataEyeCalibrationChangedML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrEventDataEyeCalibrationChangedML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrEventDataEyeCalibrationChangedML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Make sure the enum type XrEyeCalibrationStatusML value is valid
    if (!ValidateXrEnum(instance_info, command_name, "XrEventDataEyeCalibrationChangedML", "status", objects_info, value->status)) {
        std::ostringstream oss_enum;
        oss_enum << "XrEventDataEyeCalibrationChangedML contains invalid XrEyeCalibrationStatusML \"status\" enum value ";
        oss_enum << Uint32ToHexString(static_cast<uint32_t>(value->status));
        CoreValidLogMessage(instance_info, "VUID-XrEventDataEyeCalibrationChangedML-status-parameter",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, oss_enum.str());
        return XR_ERROR_VALIDATION_FAILURE;
    }
    // Everything checked out properly
    return xr_result;
}

XrResult ValidateXrStruct(GenValidUsageXrInstanceInfo *instance_info, const std::string &command_name,
                          std::vector<GenValidUsageXrObjectInfo>& objects_info, bool check_members,
                          const XrUserCalibrationEnableEventsInfoML* value) {
    XrResult xr_result = XR_SUCCESS;
    (void)xr_result;
    (void)instance_info;
    (void)command_name;
    (void)objects_info;
    (void)check_members;
    (void)value;
    // Make sure the structure type is correct
    if (value->type != XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML) {
        InvalidStructureType(instance_info, command_name, objects_info, "XrUserCalibrationEnableEventsInfoML",
                             value->type, "VUID-XrUserCalibrationEnableEventsInfoML-type-type", XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML, "XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    std::vector<XrStructureType> valid_ext_structs;
    std::vector<XrStructureType> duplicate_ext_structs;
    std::vector<XrStructureType> encountered_structs;
    NextChainResult next_result = ValidateNextChain(instance_info, command_name, objects_info,
                                                     value->next, valid_ext_structs,
                                                     encountered_structs,
                                                     duplicate_ext_structs);
    // No valid extension structs for this 'next'.  Therefore, must be NULL
    // or only contain a list of valid extension structures.
    if (NEXT_CHAIN_RESULT_ERROR == next_result) {
        CoreValidLogMessage(instance_info, "VUID-XrUserCalibrationEnableEventsInfoML-next-next",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info, "Invalid structure(s) in \"next\" chain for XrUserCalibrationEnableEventsInfoML struct \"next\"");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    } else if (NEXT_CHAIN_RESULT_DUPLICATE_STRUCT == next_result) {
        std::string error_message = "Multiple structures of the same type(s) in \"next\" chain for ";
        error_message += "XrUserCalibrationEnableEventsInfoML : ";
        error_message += StructTypesToString(instance_info, duplicate_ext_structs);
        CoreValidLogMessage(instance_info, "VUID-XrUserCalibrationEnableEventsInfoML-next-unique",
                            VALID_USAGE_DEBUG_SEVERITY_ERROR, command_name,
                            objects_info,
        "Multiple structures of the same type(s) in \"next\" chain for XrUserCalibrationEnableEventsInfoML struct");
        xr_result = XR_ERROR_VALIDATION_FAILURE;
    }
    // If we are not to check the rest of the members, just return here.
    if (!check_members || XR_SUCCESS != xr_result) {
        return xr_result;
    }
    // Everything checked out properly
    return xr_result;
}


NextChainResult ValidateNextChain(GenValidUsageXrInstanceInfo *instance_info,
                                  const std::string &command_name,
                                  std::vector<GenValidUsageXrObjectInfo>& objects_info,
                                  const void* next,
                                  std::vector<XrStructureType>& valid_ext_structs,
                                  std::vector<XrStructureType>& encountered_structs,
                                  std::vector<XrStructureType>& duplicate_structs) {
    NextChainResult return_result = NEXT_CHAIN_RESULT_VALID;
    // NULL is valid
    if (nullptr == next) {
        return return_result;
    }
    // Non-NULL is not valid if there is no valid extension structs
    if (nullptr != next && 0 == valid_ext_structs.size()) {
        return NEXT_CHAIN_RESULT_ERROR;
    }
    const XrBaseInStructure* next_header = reinterpret_cast<const XrBaseInStructure*>(next);
    auto valid_ext = std::find(valid_ext_structs.begin(), valid_ext_structs.end(), next_header->type);
    if (valid_ext == valid_ext_structs.end()) {
        // Not a valid extension structure type for this next chain.
        return NEXT_CHAIN_RESULT_ERROR;
    } else {
        // Check to see if we've already encountered this structure.
        auto already_encountered_ext = std::find(encountered_structs.begin(), encountered_structs.end(), next_header->type);
        if (already_encountered_ext != encountered_structs.end()) {
            // Make sure we only put in unique types into our duplicate list.
            auto already_duplicate = std::find(duplicate_structs.begin(), duplicate_structs.end(), next_header->type);
            if (already_duplicate == duplicate_structs.end()) {
                duplicate_structs.push_back(next_header->type);
            }
            return_result = NEXT_CHAIN_RESULT_DUPLICATE_STRUCT;
        }
    }
    switch (next_header->type) {
        case XR_TYPE_API_LAYER_PROPERTIES:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrApiLayerProperties*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EXTENSION_PROPERTIES:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrExtensionProperties*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INSTANCE_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInstanceCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_GET_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemGetInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_PROPERTIES:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemProperties*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_LOCATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewLocateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrView*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SESSION_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSessionCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SESSION_BEGIN_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSessionBeginInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_STATE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewState*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FRAME_END_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFrameEndInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAPTIC_VIBRATION:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHapticVibration*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_BUFFER:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataBuffer*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataInstanceLossPending*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSessionStateChanged*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_STATE_BOOLEAN:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionStateBoolean*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_STATE_FLOAT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionStateFloat*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_STATE_VECTOR2F:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionStateVector2f*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_STATE_POSE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionStatePose*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_SET_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionSetCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INSTANCE_PROPERTIES:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInstanceProperties*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FRAME_WAIT_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFrameWaitInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_PROJECTION:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerProjection*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_QUAD:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerQuad*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_REFERENCE_SPACE_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrReferenceSpaceCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_SPACE_CREATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionSpaceCreateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataReferenceSpaceChangePending*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_CONFIGURATION_VIEW:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewConfigurationView*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_LOCATION:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceLocation*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_VELOCITY:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceVelocity*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FRAME_STATE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFrameState*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_CONFIGURATION_PROPERTIES:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewConfigurationProperties*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FRAME_BEGIN_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFrameBeginInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerProjectionView*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_EVENTS_LOST:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataEventsLost*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInteractionProfileSuggestedBinding*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataInteractionProfileChanged*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INTERACTION_PROFILE_STATE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInteractionProfileState*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageAcquireInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageWaitInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageReleaseInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTION_STATE_GET_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionStateGetInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAPTIC_ACTION_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHapticActionInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSessionActionSetsAttachInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTIONS_SYNC_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActionsSyncInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBoundSourcesForActionEnumerateInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInputSourceLocalizedNameGetInfo*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_CUBE_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerCubeKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInstanceCreateInfoAndroidKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerDepthInfoKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVulkanSwapchainFormatListCreateInfoKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataPerfSettingsEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerCylinderKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerEquirectKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDebugUtilsObjectNameInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDebugUtilsMessengerCallbackDataEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDebugUtilsMessengerCreateInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DEBUG_UTILS_LABEL_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDebugUtilsLabelEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingOpenGLWin32KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingOpenGLXlibKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XLIB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingOpenGLXcbKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_XCB)
#if defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingOpenGLWaylandKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL) && defined(XR_USE_PLATFORM_WAYLAND)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
        case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageOpenGLKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL)
        case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsRequirementsOpenGLKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingOpenGLESAndroidKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        case XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageOpenGLESKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        case XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsRequirementsOpenGLESKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingVulkanKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageVulkanKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsRequirementsVulkanKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
        case XR_TYPE_GRAPHICS_BINDING_D3D11_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingD3D11KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
        case XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageD3D11KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D11)
        case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsRequirementsD3D11KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
        case XR_TYPE_GRAPHICS_BINDING_D3D12_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingD3D12KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
        case XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageD3D12KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
#if defined(XR_USE_GRAPHICS_API_D3D12)
        case XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsRequirementsD3D12KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
        case XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemEyeGazeInteractionPropertiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEyeGazeSampleTimeEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VISIBILITY_MASK_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVisibilityMaskKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVisibilityMaskChangedKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSessionCreateInfoOverlayEXTX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataMainSessionVisibilityChangedEXTX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerColorScaleBiasKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorSpaceCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerImageLayoutFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerAlphaBlendFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewConfigurationDepthRangeEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_EGL)
        case XR_TYPE_GRAPHICS_BINDING_EGL_MNDX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGraphicsBindingEGLMNDX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_EGL)
        case XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialGraphNodeSpaceCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialGraphStaticNodeBindingCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialGraphNodeBindingPropertiesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemHandTrackingPropertiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackerCreateInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandJointsLocateInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_JOINT_LOCATIONS_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandJointLocationsEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_JOINT_VELOCITIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandJointVelocitiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemHandTrackingMeshPropertiesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandMeshSpaceCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandMeshUpdateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_MESH_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandMeshMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_POSE_TYPE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandPoseTypeInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationSessionBeginInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationStateMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationFrameStateMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationFrameEndInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationLayerInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSecondaryViewConfigurationSwapchainCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrControllerModelKeyStateMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrControllerModelNodePropertiesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrControllerModelPropertiesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrControllerModelNodeStateMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_CONTROLLER_MODEL_STATE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrControllerModelStateMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewConfigurationViewFovEPIC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
        case XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHolographicWindowAttachmentMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_WIN32) && defined(XR_USE_PLATFORM_WIN32)
        case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerReprojectionInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerReprojectionPlaneOverrideMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_ANDROID_SURFACE_SWAPCHAIN_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrAndroidSurfaceSwapchainCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerSecureContentFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BODY_TRACKER_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBodyTrackerCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBodyJointsLocateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemBodyTrackingPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BODY_JOINT_LOCATIONS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBodyJointLocationsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BODY_SKELETON_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBodySkeletonFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInteractionProfileDpadBindingEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrInteractionProfileAnalogThresholdVALVE*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandJointsMotionRangeInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrLoaderInitInfoAndroidKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVulkanInstanceCreateInfoKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVulkanDeviceCreateInfoKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVulkanGraphicsDeviceGetInfoKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerEquirect2KHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneObserverCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrNewSceneComputeInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVisualMeshComputeLodInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_COMPONENTS_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneComponentsMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneComponentsGetInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneComponentLocationsMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneComponentsLocateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_OBJECTS_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneObjectsMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneComponentParentFilterInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneObjectTypesFilterInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_PLANES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrScenePlanesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrScenePlaneAlignmentFilterInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESHES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshBuffersGetInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESH_BUFFERS_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshBuffersMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshVertexBufferMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshIndicesUint32MSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMeshIndicesUint16MSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSerializedSceneFragmentDataGetInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneDeserializeInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataDisplayRefreshRateChangedFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIVE_TRACKER_PATHS_HTCX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViveTrackerPathsHTCX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataViveTrackerConnectedHTCX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemFacialTrackingPropertiesHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFacialTrackerCreateInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACIAL_EXPRESSIONS_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFacialExpressionsHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemColorSpacePropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_MESH_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingMeshFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_SCALE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingScaleFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_AIM_STATE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingAimStateFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingCapsulesStateFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemSpatialEntityPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceComponentStatusSetInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_COMPONENT_STATUS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceComponentStatusFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpatialAnchorCreateCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceSetStatusCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationProfileCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainCreateInfoFoveationFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainStateFoveationFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationLevelProfileCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrKeyboardSpaceCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_KEYBOARD_TRACKING_QUERY_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrKeyboardTrackingQueryFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemKeyboardTrackingPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrTriangleMeshCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemPassthroughPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughLayerCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerPassthroughFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGeometryInstanceCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGeometryInstanceTransformFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemPassthroughProperties2FB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_STYLE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughStyleFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorMapMonoToRgbaFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorMapMonoToMonoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughBrightnessContrastSaturationFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataPassthroughStateChangedFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RENDER_MODEL_PATH_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRenderModelPathInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RENDER_MODEL_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRenderModelPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RENDER_MODEL_BUFFER_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRenderModelBufferFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RENDER_MODEL_LOAD_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRenderModelLoadInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemRenderModelPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRenderModelCapabilitiesRequestFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BINDING_MODIFICATIONS_KHR:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBindingModificationsKHR*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrViewLocateFoveatedRenderingVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveatedViewConfigurationViewVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemFoveatedRenderingPropertiesVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerDepthTestVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemMarkerTrackingPropertiesVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataMarkerTrackingUpdateVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerSpaceCreateInfoVARJO*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FRAME_END_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFrameEndInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrGlobalDimmerFrameEndInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_PLATFORM_ML)
        case XR_TYPE_COORDINATE_SPACE_CREATE_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCoordinateSpaceCreateInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_ML)
        case XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemMarkerUnderstandingPropertiesML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorCreateInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorArucoInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorSizeInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorAprilTagInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorCustomProfileInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorSnapshotInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_DETECTOR_STATE_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerDetectorStateML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MARKER_SPACE_CREATE_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMarkerSpaceCreateInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_LOCALIZATION_MAP_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrLocalizationMapML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataLocalizationChangedML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrMapLocalizationRequestInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrLocalizationMapImportInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrLocalizationEnableEventsInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataHeadsetFitChangedML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataEyeCalibrationChangedML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrUserCalibrationEnableEventsInfoML*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorPersistenceInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MARKERS_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMarkersMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMarkerTypeFilterMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_MARKER_QR_CODES_MSFT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneMarkerQRCodesMSFT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_QUERY_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceQueryInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_QUERY_RESULTS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceQueryResultsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceStorageLocationFilterInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_UUID_FILTER_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceUuidFilterInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceComponentFilterInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceQueryResultsAvailableFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceQueryCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_SAVE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceSaveInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_ERASE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceEraseInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceSaveCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceEraseCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainImageFoveationVulkanFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        case XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_SPACE_SHARE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceShareInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceShareCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerSpaceWarpInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemSpaceWarpPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SEMANTIC_LABELS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSemanticLabelsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ROOM_LAYOUT_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRoomLayoutFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_BOUNDARY_2D_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrBoundary2DFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSemanticLabelsSupportInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDigitalLensControlALMALENCE*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSceneCaptureCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSceneCaptureRequestInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_CONTAINER_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceContainerFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationEyeTrackedProfileCreateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationEyeTrackedStateMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemFoveationEyeTrackedPropertiesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemFaceTrackingPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_TRACKER_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceTrackerCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_EXPRESSION_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceExpressionInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceExpressionWeightsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EYE_TRACKER_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEyeTrackerCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EYE_GAZES_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEyeGazesInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EYE_GAZES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEyeGazesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemEyeTrackingPropertiesFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughKeyboardHandsIntensityFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerSettingsFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAPTIC_PCM_VIBRATION_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHapticPcmVibrationFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrDevicePcmSampleRateStateFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerDepthTestFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrLocalDimmingFrameEndInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_PREFERENCES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughPreferencesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemVirtualKeyboardPropertiesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardCreateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardSpaceCreateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardLocationInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardModelVisibilitySetInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardAnimationStateMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardModelAnimationStatesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardTextureDataMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardInputInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVirtualKeyboardTextContextChangeInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVirtualKeyboardCommitTextMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVirtualKeyboardBackspaceMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVirtualKeyboardEnterMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVirtualKeyboardShownMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataVirtualKeyboardHiddenMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EXTERNAL_CAMERA_OCULUS:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrExternalCameraOCULUS*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrVulkanSwapchainCreateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
        case XR_TYPE_PERFORMANCE_METRICS_STATE_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPerformanceMetricsStateMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PERFORMANCE_METRICS_COUNTER_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPerformanceMetricsCounterMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_LIST_SAVE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceListSaveInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataSpaceListSaveCompleteFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_USER_CREATE_INFO_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceUserCreateInfoFB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemHeadsetIdPropertiesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRecommendedLayerResolutionMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrRecommendedLayerResolutionGetInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemPassthroughColorLutPropertiesMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorLutCreateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorLutUpdateInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorMapLutMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorMapInterpolatedLutMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceTriangleMeshGetInfoMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPACE_TRIANGLE_MESH_META:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpaceTriangleMeshMETA*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemFaceTrackingProperties2FB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceTrackerCreateInfo2FB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_EXPRESSION_INFO2_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceExpressionInfo2FB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFaceExpressionWeights2FB*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughCreateInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_COLOR_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughColorHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPassthroughMeshTransformInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrCompositionLayerPassthroughHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_APPLY_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationApplyInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_DYNAMIC_MODE_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationDynamicModeInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FOVEATION_CUSTOM_MODE_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrFoveationCustomModeInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemAnchorPropertiesHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSpatialAnchorCreateInfoHTC*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrActiveActionSetPrioritiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemForceFeedbackCurlPropertiesMNDX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrForceFeedbackCurlApplyLocationsMNDX*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingDataSourceInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrHandTrackingDataSourceStateEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorCreateInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorBeginInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorGetInfoEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorLocationsEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_LOCATION_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorLocationEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrPlaneDetectorPolygonBufferEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemPlaneDetectionPropertiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrEventDataUserPresenceChangedEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        case XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT:
            if (XR_SUCCESS != ValidateXrStruct(instance_info, command_name, objects_info, false,
                                               reinterpret_cast<const XrSystemUserPresencePropertiesEXT*>(next))) {
                return NEXT_CHAIN_RESULT_ERROR;
            }
            break;
        default:
            return NEXT_CHAIN_RESULT_ERROR;
    }
    NextChainResult next_result = ValidateNextChain(instance_info, command_name,
                                                    objects_info, next_header->next,
                                                    valid_ext_structs,
                                                    encountered_structs,
                                                    duplicate_structs);
    if (NEXT_CHAIN_RESULT_VALID == next_result && NEXT_CHAIN_RESULT_VALID != return_result) {
        return return_result;
    } else {
        return next_result;
    }
}


// ---- Core 1.0 commands
XrResult GenValidUsageInputsXrCreateInstance(
const XrInstanceCreateInfo* createInfo,
XrInstance* instance) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(nullptr, "VUID-xrCreateInstance-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateInstance", objects_info,
                                "Invalid NULL for XrInstanceCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrInstanceCreateInfo is valid
        xr_result = ValidateXrStruct(nullptr, "xrCreateInstance", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(nullptr, "VUID-xrCreateInstance-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateInstance",
                                objects_info,
                                "Command xrCreateInstance param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == instance) {
            CoreValidLogMessage(nullptr, "VUID-xrCreateInstance-instance-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateInstance", objects_info,
                                "Invalid NULL for XrInstance \"instance\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XrResult GenValidUsageInputsXrDestroyInstance(
XrInstance instance) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyInstance-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyInstance",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyInstance(
    XrInstance instance) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->DestroyInstance(instance);
        if (XR_SUCCEEDED(result)) {
            g_instance_info.erase(instance);
        }
        GenValidUsageCleanUpMaps(gen_instance_info);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrGetInstanceProperties(
XrInstance instance,
XrInstanceProperties* instanceProperties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetInstanceProperties-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInstanceProperties",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == instanceProperties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInstanceProperties-instanceProperties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInstanceProperties", objects_info,
                                "Invalid NULL for XrInstanceProperties \"instanceProperties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrInstanceProperties is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetInstanceProperties", objects_info,
                                                        false, instanceProperties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInstanceProperties-instanceProperties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInstanceProperties",
                                objects_info,
                                "Command xrGetInstanceProperties param instanceProperties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetInstanceProperties(
    XrInstance instance,
    XrInstanceProperties* instanceProperties) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetInstanceProperties(instance, instanceProperties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetInstanceProperties(
    XrInstance instance,
    XrInstanceProperties* instanceProperties) {
    XrResult test_result = GenValidUsageInputsXrGetInstanceProperties(instance, instanceProperties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetInstanceProperties(instance, instanceProperties);
}

XrResult GenValidUsageInputsXrPollEvent(
XrInstance instance,
XrEventDataBuffer* eventData) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrPollEvent-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPollEvent",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == eventData) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPollEvent-eventData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPollEvent", objects_info,
                                "Invalid NULL for XrEventDataBuffer \"eventData\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrEventDataBuffer is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrPollEvent", objects_info,
                                                        false, eventData);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPollEvent-eventData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPollEvent",
                                objects_info,
                                "Command xrPollEvent param eventData is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPollEvent(
    XrInstance instance,
    XrEventDataBuffer* eventData) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->PollEvent(instance, eventData);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPollEvent(
    XrInstance instance,
    XrEventDataBuffer* eventData) {
    XrResult test_result = GenValidUsageInputsXrPollEvent(instance, eventData);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPollEvent(instance, eventData);
}

XrResult GenValidUsageInputsXrResultToString(
XrInstance instance,
XrResult value,
char buffer[XR_MAX_RESULT_STRING_SIZE]) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrResultToString-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrResultToString",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrResult value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrResultToString", "xrResultToString", "value", objects_info, value)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrResult \"value\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(value));
            CoreValidLogMessage(gen_instance_info, "VUID-xrResultToString-value-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrResultToString",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        if (XR_MAX_RESULT_STRING_SIZE < std::strlen(buffer)) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrResultToString-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrResultToString",
                                objects_info,
                                "Command xrResultToString param buffer length is too long.");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrResultToString(
    XrInstance instance,
    XrResult value,
    char buffer[XR_MAX_RESULT_STRING_SIZE]) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->ResultToString(instance, value, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrResultToString(
    XrInstance instance,
    XrResult value,
    char buffer[XR_MAX_RESULT_STRING_SIZE]) {
    XrResult test_result = GenValidUsageInputsXrResultToString(instance, value, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrResultToString(instance, value, buffer);
}

XrResult GenValidUsageInputsXrStructureTypeToString(
XrInstance instance,
XrStructureType value,
char buffer[XR_MAX_STRUCTURE_NAME_SIZE]) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrStructureTypeToString-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStructureTypeToString",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrStructureType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrStructureTypeToString", "xrStructureTypeToString", "value", objects_info, value)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrStructureType \"value\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(value));
            CoreValidLogMessage(gen_instance_info, "VUID-xrStructureTypeToString-value-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStructureTypeToString",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        if (XR_MAX_STRUCTURE_NAME_SIZE < std::strlen(buffer)) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrStructureTypeToString-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStructureTypeToString",
                                objects_info,
                                "Command xrStructureTypeToString param buffer length is too long.");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrStructureTypeToString(
    XrInstance instance,
    XrStructureType value,
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE]) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->StructureTypeToString(instance, value, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrStructureTypeToString(
    XrInstance instance,
    XrStructureType value,
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE]) {
    XrResult test_result = GenValidUsageInputsXrStructureTypeToString(instance, value, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrStructureTypeToString(instance, value, buffer);
}

XrResult GenValidUsageInputsXrGetSystem(
XrInstance instance,
const XrSystemGetInfo* getInfo,
XrSystemId* systemId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetSystem-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystem",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSystem-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystem", objects_info,
                                "Invalid NULL for XrSystemGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSystemGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSystem", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSystem-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystem",
                                objects_info,
                                "Command xrGetSystem param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == systemId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSystem-systemId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystem", objects_info,
                                "Invalid NULL for XrSystemId \"systemId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSystem-systemId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSystem(
    XrInstance instance,
    const XrSystemGetInfo* getInfo,
    XrSystemId* systemId) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetSystem(instance, getInfo, systemId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSystem(
    XrInstance instance,
    const XrSystemGetInfo* getInfo,
    XrSystemId* systemId) {
    XrResult test_result = GenValidUsageInputsXrGetSystem(instance, getInfo, systemId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSystem(instance, getInfo, systemId);
}

XrResult GenValidUsageInputsXrGetSystemProperties(
XrInstance instance,
XrSystemId systemId,
XrSystemProperties* properties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetSystemProperties-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystemProperties",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == properties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSystemProperties-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystemProperties", objects_info,
                                "Invalid NULL for XrSystemProperties \"properties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSystemProperties is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSystemProperties", objects_info,
                                                        false, properties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSystemProperties-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSystemProperties",
                                objects_info,
                                "Command xrGetSystemProperties param properties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSystemProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrSystemProperties* properties) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetSystemProperties(instance, systemId, properties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSystemProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrSystemProperties* properties) {
    XrResult test_result = GenValidUsageInputsXrGetSystemProperties(instance, systemId, properties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSystemProperties(instance, systemId, properties);
}

XrResult GenValidUsageInputsXrEnumerateEnvironmentBlendModes(
XrInstance instance,
XrSystemId systemId,
XrViewConfigurationType viewConfigurationType,
uint32_t environmentBlendModeCapacityInput,
uint32_t* environmentBlendModeCountOutput,
XrEnvironmentBlendMode* environmentBlendModes) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateEnvironmentBlendModes-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateEnvironmentBlendModes",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrViewConfigurationType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrEnumerateEnvironmentBlendModes", "xrEnumerateEnvironmentBlendModes", "viewConfigurationType", objects_info, viewConfigurationType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(viewConfigurationType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateEnvironmentBlendModes-viewConfigurationType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateEnvironmentBlendModes",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Optional array must be non-NULL when environmentBlendModeCapacityInput is non-zero
        if (0 != environmentBlendModeCapacityInput && nullptr == environmentBlendModes) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateEnvironmentBlendModes-environmentBlendModes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateEnvironmentBlendModes",
                                objects_info,
                                "Command xrEnumerateEnvironmentBlendModes param environmentBlendModes is NULL, but environmentBlendModeCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == environmentBlendModeCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateEnvironmentBlendModes-environmentBlendModeCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateEnvironmentBlendModes", objects_info,
                                "Invalid NULL for uint32_t \"environmentBlendModeCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateEnvironmentBlendModes-environmentBlendModeCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateEnvironmentBlendModes-environmentBlendModes-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateEnvironmentBlendModes(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t environmentBlendModeCapacityInput,
    uint32_t* environmentBlendModeCountOutput,
    XrEnvironmentBlendMode* environmentBlendModes) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateEnvironmentBlendModes(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t environmentBlendModeCapacityInput,
    uint32_t* environmentBlendModeCountOutput,
    XrEnvironmentBlendMode* environmentBlendModes) {
    XrResult test_result = GenValidUsageInputsXrEnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
}

XrResult GenValidUsageInputsXrCreateSession(
XrInstance instance,
const XrSessionCreateInfo* createInfo,
XrSession* session) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSession-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSession",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSession-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSession", objects_info,
                                "Invalid NULL for XrSessionCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSessionCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSession", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSession-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSession",
                                objects_info,
                                "Command xrCreateSession param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == session) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSession-session-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSession", objects_info,
                                "Invalid NULL for XrSession \"session\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSession(
    XrInstance instance,
    const XrSessionCreateInfo* createInfo,
    XrSession* session) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->CreateSession(instance, createInfo, session);
        if (XR_SUCCESS == result && nullptr != session) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_INSTANCE;
            handle_info->direct_parent_handle = MakeHandleGeneric(instance);
            g_session_info.insert(*session, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrDestroySession(
XrSession session) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySession-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySession",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySession(session);

        // Clean up any labels associated with this session
        CoreValidationDeleteSessionLabels(session);

        if (XR_SUCCEEDED(result)) {
            g_session_info.erase(session);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySession(
    XrSession session) {
    XrResult test_result = GenValidUsageInputsXrDestroySession(session);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySession(session);
}

XrResult GenValidUsageInputsXrEnumerateReferenceSpaces(
XrSession session,
uint32_t spaceCapacityInput,
uint32_t* spaceCountOutput,
XrReferenceSpaceType* spaces) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateReferenceSpaces-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReferenceSpaces",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when spaceCapacityInput is non-zero
        if (0 != spaceCapacityInput && nullptr == spaces) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateReferenceSpaces-spaces-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReferenceSpaces",
                                objects_info,
                                "Command xrEnumerateReferenceSpaces param spaces is NULL, but spaceCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spaceCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateReferenceSpaces-spaceCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReferenceSpaces", objects_info,
                                "Invalid NULL for uint32_t \"spaceCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateReferenceSpaces-spaceCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateReferenceSpaces-spaces-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateReferenceSpaces(
    XrSession session,
    uint32_t spaceCapacityInput,
    uint32_t* spaceCountOutput,
    XrReferenceSpaceType* spaces) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateReferenceSpaces(
    XrSession session,
    uint32_t spaceCapacityInput,
    uint32_t* spaceCountOutput,
    XrReferenceSpaceType* spaces) {
    XrResult test_result = GenValidUsageInputsXrEnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
}

XrResult GenValidUsageInputsXrCreateReferenceSpace(
XrSession session,
const XrReferenceSpaceCreateInfo* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateReferenceSpace-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateReferenceSpace",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateReferenceSpace-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateReferenceSpace", objects_info,
                                "Invalid NULL for XrReferenceSpaceCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrReferenceSpaceCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateReferenceSpace", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateReferenceSpace-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateReferenceSpace",
                                objects_info,
                                "Command xrCreateReferenceSpace param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateReferenceSpace-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateReferenceSpace", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateReferenceSpace(
    XrSession session,
    const XrReferenceSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateReferenceSpace(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateReferenceSpace(
    XrSession session,
    const XrReferenceSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateReferenceSpace(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateReferenceSpace(session, createInfo, space);
}

XrResult GenValidUsageInputsXrGetReferenceSpaceBoundsRect(
XrSession session,
XrReferenceSpaceType referenceSpaceType,
XrExtent2Df* bounds) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetReferenceSpaceBoundsRect-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetReferenceSpaceBoundsRect",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrReferenceSpaceType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetReferenceSpaceBoundsRect", "xrGetReferenceSpaceBoundsRect", "referenceSpaceType", objects_info, referenceSpaceType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrReferenceSpaceType \"referenceSpaceType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(referenceSpaceType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetReferenceSpaceBoundsRect-referenceSpaceType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetReferenceSpaceBoundsRect",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bounds) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetReferenceSpaceBoundsRect-bounds-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetReferenceSpaceBoundsRect", objects_info,
                                "Invalid NULL for XrExtent2Df \"bounds\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetReferenceSpaceBoundsRect-bounds-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetReferenceSpaceBoundsRect(
    XrSession session,
    XrReferenceSpaceType referenceSpaceType,
    XrExtent2Df* bounds) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetReferenceSpaceBoundsRect(
    XrSession session,
    XrReferenceSpaceType referenceSpaceType,
    XrExtent2Df* bounds) {
    XrResult test_result = GenValidUsageInputsXrGetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
}

XrResult GenValidUsageInputsXrCreateActionSpace(
XrSession session,
const XrActionSpaceCreateInfo* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateActionSpace-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSpace",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSpace-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSpace", objects_info,
                                "Invalid NULL for XrActionSpaceCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionSpaceCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateActionSpace", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSpace-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSpace",
                                objects_info,
                                "Command xrCreateActionSpace param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSpace-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSpace", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateActionSpace(
    XrSession session,
    const XrActionSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateActionSpace(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateActionSpace(
    XrSession session,
    const XrActionSpaceCreateInfo* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateActionSpace(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateActionSpace(session, createInfo, space);
}

XrResult GenValidUsageInputsXrLocateSpace(
XrSpace space,
XrSpace baseSpace,
XrTime time,
XrSpaceLocation* location) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrLocateSpace-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSpace",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(baseSpace, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&baseSpace);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"baseSpace\" ";
                oss << HandleToHexString(baseSpace);
                CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSpace-baseSpace-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSpace",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(baseSpace), false)) {
            std::ostringstream oss_error;
            oss_error << "XrSpace " << HandleToHexString(space);
            oss_error <<  " and XrSpace ";
            oss_error << HandleToHexString(baseSpace);
            oss_error <<  " must share a parent";
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSpace-commonparent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSpace",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == location) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSpace-location-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSpace", objects_info,
                                "Invalid NULL for XrSpaceLocation \"location\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceLocation is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateSpace", objects_info,
                                                        false, location);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSpace-location-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSpace",
                                objects_info,
                                "Command xrLocateSpace param location is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLocateSpace(
    XrSpace space,
    XrSpace baseSpace,
    XrTime time,
    XrSpaceLocation* location) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LocateSpace(space, baseSpace, time, location);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLocateSpace(
    XrSpace space,
    XrSpace baseSpace,
    XrTime time,
    XrSpaceLocation* location) {
    XrResult test_result = GenValidUsageInputsXrLocateSpace(space, baseSpace, time, location);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLocateSpace(space, baseSpace, time, location);
}

XrResult GenValidUsageInputsXrDestroySpace(
XrSpace space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySpace-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySpace",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySpace(
    XrSpace space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySpace(space);
        if (XR_SUCCEEDED(result)) {
            g_space_info.erase(space);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySpace(
    XrSpace space) {
    XrResult test_result = GenValidUsageInputsXrDestroySpace(space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySpace(space);
}

XrResult GenValidUsageInputsXrEnumerateViewConfigurations(
XrInstance instance,
XrSystemId systemId,
uint32_t viewConfigurationTypeCapacityInput,
uint32_t* viewConfigurationTypeCountOutput,
XrViewConfigurationType* viewConfigurationTypes) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateViewConfigurations-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurations",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when viewConfigurationTypeCapacityInput is non-zero
        if (0 != viewConfigurationTypeCapacityInput && nullptr == viewConfigurationTypes) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurations-viewConfigurationTypes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurations",
                                objects_info,
                                "Command xrEnumerateViewConfigurations param viewConfigurationTypes is NULL, but viewConfigurationTypeCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == viewConfigurationTypeCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurations-viewConfigurationTypeCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurations", objects_info,
                                "Invalid NULL for uint32_t \"viewConfigurationTypeCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateViewConfigurations-viewConfigurationTypeCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateViewConfigurations-viewConfigurationTypes-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateViewConfigurations(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t viewConfigurationTypeCapacityInput,
    uint32_t* viewConfigurationTypeCountOutput,
    XrViewConfigurationType* viewConfigurationTypes) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateViewConfigurations(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t viewConfigurationTypeCapacityInput,
    uint32_t* viewConfigurationTypeCountOutput,
    XrViewConfigurationType* viewConfigurationTypes) {
    XrResult test_result = GenValidUsageInputsXrEnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
}

XrResult GenValidUsageInputsXrGetViewConfigurationProperties(
XrInstance instance,
XrSystemId systemId,
XrViewConfigurationType viewConfigurationType,
XrViewConfigurationProperties* configurationProperties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetViewConfigurationProperties-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetViewConfigurationProperties",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrViewConfigurationType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetViewConfigurationProperties", "xrGetViewConfigurationProperties", "viewConfigurationType", objects_info, viewConfigurationType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(viewConfigurationType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetViewConfigurationProperties-viewConfigurationType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetViewConfigurationProperties",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == configurationProperties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetViewConfigurationProperties-configurationProperties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetViewConfigurationProperties", objects_info,
                                "Invalid NULL for XrViewConfigurationProperties \"configurationProperties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrViewConfigurationProperties is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetViewConfigurationProperties", objects_info,
                                                        false, configurationProperties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetViewConfigurationProperties-configurationProperties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetViewConfigurationProperties",
                                objects_info,
                                "Command xrGetViewConfigurationProperties param configurationProperties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetViewConfigurationProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    XrViewConfigurationProperties* configurationProperties) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetViewConfigurationProperties(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    XrViewConfigurationProperties* configurationProperties) {
    XrResult test_result = GenValidUsageInputsXrGetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
}

XrResult GenValidUsageInputsXrEnumerateViewConfigurationViews(
XrInstance instance,
XrSystemId systemId,
XrViewConfigurationType viewConfigurationType,
uint32_t viewCapacityInput,
uint32_t* viewCountOutput,
XrViewConfigurationView* views) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateViewConfigurationViews-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurationViews",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrViewConfigurationType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrEnumerateViewConfigurationViews", "xrEnumerateViewConfigurationViews", "viewConfigurationType", objects_info, viewConfigurationType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(viewConfigurationType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurationViews-viewConfigurationType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurationViews",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Optional array must be non-NULL when viewCapacityInput is non-zero
        if (0 != viewCapacityInput && nullptr == views) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurationViews-views-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurationViews",
                                objects_info,
                                "Command xrEnumerateViewConfigurationViews param views is NULL, but viewCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == viewCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurationViews-viewCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurationViews", objects_info,
                                "Invalid NULL for uint32_t \"viewCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateViewConfigurationViews-viewCountOutput-parameter" type
        if (views) {
            for (uint32_t value_views_inc = 0; value_views_inc < viewCapacityInput; ++value_views_inc) {
                // Validate that the structure XrViewConfigurationView is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateViewConfigurationViews", objects_info,
                                                                true, &views[value_views_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViewConfigurationViews-views-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViewConfigurationViews",
                                        objects_info,
                                        "Command xrEnumerateViewConfigurationViews param views is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateViewConfigurationViews(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrViewConfigurationView* views) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateViewConfigurationViews(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrViewConfigurationView* views) {
    XrResult test_result = GenValidUsageInputsXrEnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
}

XrResult GenValidUsageInputsXrEnumerateSwapchainFormats(
XrSession session,
uint32_t formatCapacityInput,
uint32_t* formatCountOutput,
int64_t* formats) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateSwapchainFormats-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainFormats",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when formatCapacityInput is non-zero
        if (0 != formatCapacityInput && nullptr == formats) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainFormats-formats-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainFormats",
                                objects_info,
                                "Command xrEnumerateSwapchainFormats param formats is NULL, but formatCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == formatCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainFormats-formatCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainFormats", objects_info,
                                "Invalid NULL for uint32_t \"formatCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateSwapchainFormats-formatCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrEnumerateSwapchainFormats-formats-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateSwapchainFormats(
    XrSession session,
    uint32_t formatCapacityInput,
    uint32_t* formatCountOutput,
    int64_t* formats) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateSwapchainFormats(
    XrSession session,
    uint32_t formatCapacityInput,
    uint32_t* formatCountOutput,
    int64_t* formats) {
    XrResult test_result = GenValidUsageInputsXrEnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
}

XrResult GenValidUsageInputsXrCreateSwapchain(
XrSession session,
const XrSwapchainCreateInfo* createInfo,
XrSwapchain* swapchain) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSwapchain-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchain",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchain-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchain", objects_info,
                                "Invalid NULL for XrSwapchainCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSwapchainCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSwapchain", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchain-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchain",
                                objects_info,
                                "Command xrCreateSwapchain param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == swapchain) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchain-swapchain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchain", objects_info,
                                "Invalid NULL for XrSwapchain \"swapchain\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSwapchain(
    XrSession session,
    const XrSwapchainCreateInfo* createInfo,
    XrSwapchain* swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSwapchain(session, createInfo, swapchain);
        if (XR_SUCCESS == result && nullptr != swapchain) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_swapchain_info.insert(*swapchain, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSwapchain(
    XrSession session,
    const XrSwapchainCreateInfo* createInfo,
    XrSwapchain* swapchain) {
    XrResult test_result = GenValidUsageInputsXrCreateSwapchain(session, createInfo, swapchain);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSwapchain(session, createInfo, swapchain);
}

XrResult GenValidUsageInputsXrDestroySwapchain(
XrSwapchain swapchain) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySwapchain-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySwapchain",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySwapchain(
    XrSwapchain swapchain) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySwapchain(swapchain);
        if (XR_SUCCEEDED(result)) {
            g_swapchain_info.erase(swapchain);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySwapchain(
    XrSwapchain swapchain) {
    XrResult test_result = GenValidUsageInputsXrDestroySwapchain(swapchain);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySwapchain(swapchain);
}

XrResult GenValidUsageInputsXrEnumerateSwapchainImages(
XrSwapchain swapchain,
uint32_t imageCapacityInput,
uint32_t* imageCountOutput,
XrSwapchainImageBaseHeader* images) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateSwapchainImages-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when imageCapacityInput is non-zero
        if (0 != imageCapacityInput && nullptr == images) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                objects_info,
                                "Command xrEnumerateSwapchainImages param images is NULL, but imageCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == imageCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-imageCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages", objects_info,
                                "Invalid NULL for uint32_t \"imageCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateSwapchainImages-imageCountOutput-parameter" type
        if (images) {
            for (uint32_t value_images_inc = 0; value_images_inc < imageCapacityInput; ++value_images_inc) {
#if defined(XR_USE_GRAPHICS_API_OPENGL)
                // Validate if XrSwapchainImageBaseHeader is a child structure of type XrSwapchainImageOpenGLKHR and it is valid
                {
                    XrSwapchainImageOpenGLKHR* new_swapchainimageopenglkhr_value = reinterpret_cast<XrSwapchainImageOpenGLKHR*>(images);
                    if (new_swapchainimageopenglkhr_value[value_images_inc].type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR) {
                        if (nullptr != new_swapchainimageopenglkhr_value) {
                            xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages",
                                                                            objects_info, false, &new_swapchainimageopenglkhr_value[value_images_inc]);
                            if (XR_SUCCESS != xr_result) {
                                std::string error_message = "Command xrEnumerateSwapchainImages param images";
                                error_message += "[";
                                error_message += std::to_string(value_images_inc);
                                error_message += "]";
                                error_message += " is invalid";
                                CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                                    objects_info,
                                                    error_message);
                                return XR_ERROR_VALIDATION_FAILURE;
                                break;
                            } else {
                                continue;
                                }
                        }
                    }
                }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
                // Validate if XrSwapchainImageBaseHeader is a child structure of type XrSwapchainImageOpenGLESKHR and it is valid
                {
                    XrSwapchainImageOpenGLESKHR* new_swapchainimageopengleskhr_value = reinterpret_cast<XrSwapchainImageOpenGLESKHR*>(images);
                    if (new_swapchainimageopengleskhr_value[value_images_inc].type == XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_ES_KHR) {
                        if (nullptr != new_swapchainimageopengleskhr_value) {
                            xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages",
                                                                            objects_info, false, &new_swapchainimageopengleskhr_value[value_images_inc]);
                            if (XR_SUCCESS != xr_result) {
                                std::string error_message = "Command xrEnumerateSwapchainImages param images";
                                error_message += "[";
                                error_message += std::to_string(value_images_inc);
                                error_message += "]";
                                error_message += " is invalid";
                                CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                                    objects_info,
                                                    error_message);
                                return XR_ERROR_VALIDATION_FAILURE;
                                break;
                            } else {
                                continue;
                                }
                        }
                    }
                }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
                // Validate if XrSwapchainImageBaseHeader is a child structure of type XrSwapchainImageVulkanKHR and it is valid
                {
                    XrSwapchainImageVulkanKHR* new_swapchainimagevulkankhr_value = reinterpret_cast<XrSwapchainImageVulkanKHR*>(images);
                    if (new_swapchainimagevulkankhr_value[value_images_inc].type == XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR) {
                        if (nullptr != new_swapchainimagevulkankhr_value) {
                            xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages",
                                                                            objects_info, false, &new_swapchainimagevulkankhr_value[value_images_inc]);
                            if (XR_SUCCESS != xr_result) {
                                std::string error_message = "Command xrEnumerateSwapchainImages param images";
                                error_message += "[";
                                error_message += std::to_string(value_images_inc);
                                error_message += "]";
                                error_message += " is invalid";
                                CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                                    objects_info,
                                                    error_message);
                                return XR_ERROR_VALIDATION_FAILURE;
                                break;
                            } else {
                                continue;
                                }
                        }
                    }
                }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_D3D11)
                // Validate if XrSwapchainImageBaseHeader is a child structure of type XrSwapchainImageD3D11KHR and it is valid
                {
                    XrSwapchainImageD3D11KHR* new_swapchainimaged3d11khr_value = reinterpret_cast<XrSwapchainImageD3D11KHR*>(images);
                    if (new_swapchainimaged3d11khr_value[value_images_inc].type == XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR) {
                        if (nullptr != new_swapchainimaged3d11khr_value) {
                            xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages",
                                                                            objects_info, false, &new_swapchainimaged3d11khr_value[value_images_inc]);
                            if (XR_SUCCESS != xr_result) {
                                std::string error_message = "Command xrEnumerateSwapchainImages param images";
                                error_message += "[";
                                error_message += std::to_string(value_images_inc);
                                error_message += "]";
                                error_message += " is invalid";
                                CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                                    objects_info,
                                                    error_message);
                                return XR_ERROR_VALIDATION_FAILURE;
                                break;
                            } else {
                                continue;
                                }
                        }
                    }
                }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)
#if defined(XR_USE_GRAPHICS_API_D3D12)
                // Validate if XrSwapchainImageBaseHeader is a child structure of type XrSwapchainImageD3D12KHR and it is valid
                {
                    XrSwapchainImageD3D12KHR* new_swapchainimaged3d12khr_value = reinterpret_cast<XrSwapchainImageD3D12KHR*>(images);
                    if (new_swapchainimaged3d12khr_value[value_images_inc].type == XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR) {
                        if (nullptr != new_swapchainimaged3d12khr_value) {
                            xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages",
                                                                            objects_info, false, &new_swapchainimaged3d12khr_value[value_images_inc]);
                            if (XR_SUCCESS != xr_result) {
                                std::string error_message = "Command xrEnumerateSwapchainImages param images";
                                error_message += "[";
                                error_message += std::to_string(value_images_inc);
                                error_message += "]";
                                error_message += " is invalid";
                                CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                                    objects_info,
                                                    error_message);
                                return XR_ERROR_VALIDATION_FAILURE;
                                break;
                            } else {
                                continue;
                                }
                        }
                    }
                }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)
                // Validate that the base-structure XrSwapchainImageBaseHeader is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateSwapchainImages", objects_info,
                                                                true, &images[value_images_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSwapchainImages-images-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSwapchainImages",
                                        objects_info,
                                        "Command xrEnumerateSwapchainImages param images is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateSwapchainImages(
    XrSwapchain swapchain,
    uint32_t imageCapacityInput,
    uint32_t* imageCountOutput,
    XrSwapchainImageBaseHeader* images) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateSwapchainImages(
    XrSwapchain swapchain,
    uint32_t imageCapacityInput,
    uint32_t* imageCountOutput,
    XrSwapchainImageBaseHeader* images) {
    XrResult test_result = GenValidUsageInputsXrEnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
}

XrResult GenValidUsageInputsXrAcquireSwapchainImage(
XrSwapchain swapchain,
const XrSwapchainImageAcquireInfo* acquireInfo,
uint32_t* index) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrAcquireSwapchainImage-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAcquireSwapchainImage",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrSwapchainImageAcquireInfo is valid
        if (nullptr != acquireInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrAcquireSwapchainImage",
                                                            objects_info, false, acquireInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrAcquireSwapchainImage-acquireInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAcquireSwapchainImage",
                                    objects_info,
                                    "Command xrAcquireSwapchainImage param acquireInfo is invalid");
                return xr_result;
            }
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == index) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrAcquireSwapchainImage-index-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAcquireSwapchainImage", objects_info,
                                "Invalid NULL for uint32_t \"index\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrAcquireSwapchainImage-index-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrAcquireSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageAcquireInfo* acquireInfo,
    uint32_t* index) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->AcquireSwapchainImage(swapchain, acquireInfo, index);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrAcquireSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageAcquireInfo* acquireInfo,
    uint32_t* index) {
    XrResult test_result = GenValidUsageInputsXrAcquireSwapchainImage(swapchain, acquireInfo, index);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrAcquireSwapchainImage(swapchain, acquireInfo, index);
}

XrResult GenValidUsageInputsXrWaitSwapchainImage(
XrSwapchain swapchain,
const XrSwapchainImageWaitInfo* waitInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrWaitSwapchainImage-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitSwapchainImage",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == waitInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrWaitSwapchainImage-waitInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitSwapchainImage", objects_info,
                                "Invalid NULL for XrSwapchainImageWaitInfo \"waitInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSwapchainImageWaitInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrWaitSwapchainImage", objects_info,
                                                        true, waitInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrWaitSwapchainImage-waitInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitSwapchainImage",
                                objects_info,
                                "Command xrWaitSwapchainImage param waitInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrWaitSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageWaitInfo* waitInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->WaitSwapchainImage(swapchain, waitInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrWaitSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageWaitInfo* waitInfo) {
    XrResult test_result = GenValidUsageInputsXrWaitSwapchainImage(swapchain, waitInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrWaitSwapchainImage(swapchain, waitInfo);
}

XrResult GenValidUsageInputsXrReleaseSwapchainImage(
XrSwapchain swapchain,
const XrSwapchainImageReleaseInfo* releaseInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrReleaseSwapchainImage-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrReleaseSwapchainImage",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrSwapchainImageReleaseInfo is valid
        if (nullptr != releaseInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrReleaseSwapchainImage",
                                                            objects_info, false, releaseInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrReleaseSwapchainImage-releaseInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrReleaseSwapchainImage",
                                    objects_info,
                                    "Command xrReleaseSwapchainImage param releaseInfo is invalid");
                return xr_result;
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrReleaseSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageReleaseInfo* releaseInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ReleaseSwapchainImage(swapchain, releaseInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrReleaseSwapchainImage(
    XrSwapchain swapchain,
    const XrSwapchainImageReleaseInfo* releaseInfo) {
    XrResult test_result = GenValidUsageInputsXrReleaseSwapchainImage(swapchain, releaseInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrReleaseSwapchainImage(swapchain, releaseInfo);
}

XrResult GenValidUsageInputsXrBeginSession(
XrSession session,
const XrSessionBeginInfo* beginInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrBeginSession-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginSession",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == beginInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrBeginSession-beginInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginSession", objects_info,
                                "Invalid NULL for XrSessionBeginInfo \"beginInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSessionBeginInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrBeginSession", objects_info,
                                                        true, beginInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrBeginSession-beginInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginSession",
                                objects_info,
                                "Command xrBeginSession param beginInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrBeginSession(
    XrSession session,
    const XrSessionBeginInfo* beginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->BeginSession(session, beginInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrBeginSession(
    XrSession session,
    const XrSessionBeginInfo* beginInfo) {
    XrResult test_result = GenValidUsageInputsXrBeginSession(session, beginInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrBeginSession(session, beginInfo);
}

XrResult GenValidUsageInputsXrEndSession(
XrSession session) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEndSession-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEndSession",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEndSession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EndSession(session);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEndSession(
    XrSession session) {
    XrResult test_result = GenValidUsageInputsXrEndSession(session);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEndSession(session);
}

XrResult GenValidUsageInputsXrRequestExitSession(
XrSession session) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrRequestExitSession-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestExitSession",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrRequestExitSession(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->RequestExitSession(session);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrRequestExitSession(
    XrSession session) {
    XrResult test_result = GenValidUsageInputsXrRequestExitSession(session);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrRequestExitSession(session);
}

XrResult GenValidUsageInputsXrWaitFrame(
XrSession session,
const XrFrameWaitInfo* frameWaitInfo,
XrFrameState* frameState) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrWaitFrame-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitFrame",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrFrameWaitInfo is valid
        if (nullptr != frameWaitInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrWaitFrame",
                                                            objects_info, false, frameWaitInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrWaitFrame-frameWaitInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitFrame",
                                    objects_info,
                                    "Command xrWaitFrame param frameWaitInfo is invalid");
                return xr_result;
            }
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == frameState) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrWaitFrame-frameState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitFrame", objects_info,
                                "Invalid NULL for XrFrameState \"frameState\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFrameState is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrWaitFrame", objects_info,
                                                        false, frameState);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrWaitFrame-frameState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrWaitFrame",
                                objects_info,
                                "Command xrWaitFrame param frameState is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrWaitFrame(
    XrSession session,
    const XrFrameWaitInfo* frameWaitInfo,
    XrFrameState* frameState) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->WaitFrame(session, frameWaitInfo, frameState);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrWaitFrame(
    XrSession session,
    const XrFrameWaitInfo* frameWaitInfo,
    XrFrameState* frameState) {
    XrResult test_result = GenValidUsageInputsXrWaitFrame(session, frameWaitInfo, frameState);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrWaitFrame(session, frameWaitInfo, frameState);
}

XrResult GenValidUsageInputsXrBeginFrame(
XrSession session,
const XrFrameBeginInfo* frameBeginInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrBeginFrame-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginFrame",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrFrameBeginInfo is valid
        if (nullptr != frameBeginInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrBeginFrame",
                                                            objects_info, false, frameBeginInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrBeginFrame-frameBeginInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginFrame",
                                    objects_info,
                                    "Command xrBeginFrame param frameBeginInfo is invalid");
                return xr_result;
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrBeginFrame(
    XrSession session,
    const XrFrameBeginInfo* frameBeginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->BeginFrame(session, frameBeginInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrBeginFrame(
    XrSession session,
    const XrFrameBeginInfo* frameBeginInfo) {
    XrResult test_result = GenValidUsageInputsXrBeginFrame(session, frameBeginInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrBeginFrame(session, frameBeginInfo);
}

XrResult GenValidUsageInputsXrEndFrame(
XrSession session,
const XrFrameEndInfo* frameEndInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEndFrame-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEndFrame",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == frameEndInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEndFrame-frameEndInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEndFrame", objects_info,
                                "Invalid NULL for XrFrameEndInfo \"frameEndInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFrameEndInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrEndFrame", objects_info,
                                                        true, frameEndInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEndFrame-frameEndInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEndFrame",
                                objects_info,
                                "Command xrEndFrame param frameEndInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEndFrame(
    XrSession session,
    const XrFrameEndInfo* frameEndInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EndFrame(session, frameEndInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEndFrame(
    XrSession session,
    const XrFrameEndInfo* frameEndInfo) {
    XrResult test_result = GenValidUsageInputsXrEndFrame(session, frameEndInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEndFrame(session, frameEndInfo);
}

XrResult GenValidUsageInputsXrLocateViews(
XrSession session,
const XrViewLocateInfo* viewLocateInfo,
XrViewState* viewState,
uint32_t viewCapacityInput,
uint32_t* viewCountOutput,
XrView* views) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrLocateViews-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == viewLocateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-viewLocateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews", objects_info,
                                "Invalid NULL for XrViewLocateInfo \"viewLocateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrViewLocateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateViews", objects_info,
                                                        true, viewLocateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-viewLocateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews",
                                objects_info,
                                "Command xrLocateViews param viewLocateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == viewState) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-viewState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews", objects_info,
                                "Invalid NULL for XrViewState \"viewState\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrViewState is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateViews", objects_info,
                                                        false, viewState);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-viewState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews",
                                objects_info,
                                "Command xrLocateViews param viewState is invalid");
            return xr_result;
        }
        // Optional array must be non-NULL when viewCapacityInput is non-zero
        if (0 != viewCapacityInput && nullptr == views) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-views-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews",
                                objects_info,
                                "Command xrLocateViews param views is NULL, but viewCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == viewCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-viewCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews", objects_info,
                                "Invalid NULL for uint32_t \"viewCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrLocateViews-viewCountOutput-parameter" type
        if (views) {
            for (uint32_t value_views_inc = 0; value_views_inc < viewCapacityInput; ++value_views_inc) {
                // Validate that the structure XrView is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrLocateViews", objects_info,
                                                                true, &views[value_views_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrLocateViews-views-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateViews",
                                        objects_info,
                                        "Command xrLocateViews param views is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLocateViews(
    XrSession session,
    const XrViewLocateInfo* viewLocateInfo,
    XrViewState* viewState,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrView* views) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLocateViews(
    XrSession session,
    const XrViewLocateInfo* viewLocateInfo,
    XrViewState* viewState,
    uint32_t viewCapacityInput,
    uint32_t* viewCountOutput,
    XrView* views) {
    XrResult test_result = GenValidUsageInputsXrLocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
}

XrResult GenValidUsageInputsXrStringToPath(
XrInstance instance,
const char* pathString,
XrPath* path) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrStringToPath-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStringToPath",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == pathString) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrStringToPath-pathString-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStringToPath", objects_info,
                                "Invalid NULL for char \"pathString\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrStringToPath-pathString-parameter" null-termination
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == path) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrStringToPath-path-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStringToPath", objects_info,
                                "Invalid NULL for XrPath \"path\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrStringToPath-path-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrStringToPath(
    XrInstance instance,
    const char* pathString,
    XrPath* path) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->StringToPath(instance, pathString, path);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrStringToPath(
    XrInstance instance,
    const char* pathString,
    XrPath* path) {
    XrResult test_result = GenValidUsageInputsXrStringToPath(instance, pathString, path);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrStringToPath(instance, pathString, path);
}

XrResult GenValidUsageInputsXrPathToString(
XrInstance instance,
XrPath path,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrPathToString-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPathToString",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPathToString-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPathToString",
                                objects_info,
                                "Command xrPathToString param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPathToString-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPathToString", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrPathToString-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrPathToString-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPathToString(
    XrInstance instance,
    XrPath path,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->PathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPathToString(
    XrInstance instance,
    XrPath path,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrPathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
}

XrResult GenValidUsageInputsXrCreateActionSet(
XrInstance instance,
const XrActionSetCreateInfo* createInfo,
XrActionSet* actionSet) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrCreateActionSet-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSet",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSet-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSet", objects_info,
                                "Invalid NULL for XrActionSetCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionSetCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateActionSet", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSet-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSet",
                                objects_info,
                                "Command xrCreateActionSet param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == actionSet) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateActionSet-actionSet-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateActionSet", objects_info,
                                "Invalid NULL for XrActionSet \"actionSet\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateActionSet(
    XrInstance instance,
    const XrActionSetCreateInfo* createInfo,
    XrActionSet* actionSet) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->CreateActionSet(instance, createInfo, actionSet);
        if (XR_SUCCESS == result && nullptr != actionSet) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_INSTANCE;
            handle_info->direct_parent_handle = MakeHandleGeneric(instance);
            g_actionset_info.insert(*actionSet, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateActionSet(
    XrInstance instance,
    const XrActionSetCreateInfo* createInfo,
    XrActionSet* actionSet) {
    XrResult test_result = GenValidUsageInputsXrCreateActionSet(instance, createInfo, actionSet);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateActionSet(instance, createInfo, actionSet);
}

XrResult GenValidUsageInputsXrDestroyActionSet(
XrActionSet actionSet) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(actionSet, XR_OBJECT_TYPE_ACTION_SET);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&actionSet);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrActionSet handle \"actionSet\" ";
                oss << HandleToHexString(actionSet);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyActionSet-actionSet-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyActionSet",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_actionset_info.getWithInstanceInfo(actionSet);
        GenValidUsageXrHandleInfo *gen_actionset_info = info_with_instance.first;
        (void)gen_actionset_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyActionSet(
    XrActionSet actionSet) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_actionset_info.getWithInstanceInfo(actionSet);
        GenValidUsageXrHandleInfo *gen_actionset_info = info_with_instance.first;
        (void)gen_actionset_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyActionSet(actionSet);
        if (XR_SUCCEEDED(result)) {
            g_actionset_info.erase(actionSet);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyActionSet(
    XrActionSet actionSet) {
    XrResult test_result = GenValidUsageInputsXrDestroyActionSet(actionSet);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyActionSet(actionSet);
}

XrResult GenValidUsageInputsXrCreateAction(
XrActionSet actionSet,
const XrActionCreateInfo* createInfo,
XrAction* action) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(actionSet, XR_OBJECT_TYPE_ACTION_SET);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrActionSetHandle(&actionSet);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrActionSet handle \"actionSet\" ";
                oss << HandleToHexString(actionSet);
                CoreValidLogMessage(nullptr, "VUID-xrCreateAction-actionSet-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateAction",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_actionset_info.getWithInstanceInfo(actionSet);
        GenValidUsageXrHandleInfo *gen_actionset_info = info_with_instance.first;
        (void)gen_actionset_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateAction-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateAction", objects_info,
                                "Invalid NULL for XrActionCreateInfo \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateAction", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateAction-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateAction",
                                objects_info,
                                "Command xrCreateAction param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == action) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateAction-action-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateAction", objects_info,
                                "Invalid NULL for XrAction \"action\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateAction(
    XrActionSet actionSet,
    const XrActionCreateInfo* createInfo,
    XrAction* action) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_actionset_info.getWithInstanceInfo(actionSet);
        GenValidUsageXrHandleInfo *gen_actionset_info = info_with_instance.first;
        (void)gen_actionset_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateAction(actionSet, createInfo, action);
        if (XR_SUCCESS == result && nullptr != action) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_ACTION_SET;
            handle_info->direct_parent_handle = MakeHandleGeneric(actionSet);
            g_action_info.insert(*action, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateAction(
    XrActionSet actionSet,
    const XrActionCreateInfo* createInfo,
    XrAction* action) {
    XrResult test_result = GenValidUsageInputsXrCreateAction(actionSet, createInfo, action);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateAction(actionSet, createInfo, action);
}

XrResult GenValidUsageInputsXrDestroyAction(
XrAction action) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(action, XR_OBJECT_TYPE_ACTION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrActionHandle(&action);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrAction handle \"action\" ";
                oss << HandleToHexString(action);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyAction-action-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyAction",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_action_info.getWithInstanceInfo(action);
        GenValidUsageXrHandleInfo *gen_action_info = info_with_instance.first;
        (void)gen_action_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyAction(
    XrAction action) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_action_info.getWithInstanceInfo(action);
        GenValidUsageXrHandleInfo *gen_action_info = info_with_instance.first;
        (void)gen_action_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyAction(action);
        if (XR_SUCCEEDED(result)) {
            g_action_info.erase(action);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyAction(
    XrAction action) {
    XrResult test_result = GenValidUsageInputsXrDestroyAction(action);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyAction(action);
}

XrResult GenValidUsageInputsXrSuggestInteractionProfileBindings(
XrInstance instance,
const XrInteractionProfileSuggestedBinding* suggestedBindings) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrSuggestInteractionProfileBindings-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestInteractionProfileBindings",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == suggestedBindings) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSuggestInteractionProfileBindings-suggestedBindings-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestInteractionProfileBindings", objects_info,
                                "Invalid NULL for XrInteractionProfileSuggestedBinding \"suggestedBindings\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrInteractionProfileSuggestedBinding is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSuggestInteractionProfileBindings", objects_info,
                                                        true, suggestedBindings);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSuggestInteractionProfileBindings-suggestedBindings-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestInteractionProfileBindings",
                                objects_info,
                                "Command xrSuggestInteractionProfileBindings param suggestedBindings is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSuggestInteractionProfileBindings(
    XrInstance instance,
    const XrInteractionProfileSuggestedBinding* suggestedBindings) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->SuggestInteractionProfileBindings(instance, suggestedBindings);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSuggestInteractionProfileBindings(
    XrInstance instance,
    const XrInteractionProfileSuggestedBinding* suggestedBindings) {
    XrResult test_result = GenValidUsageInputsXrSuggestInteractionProfileBindings(instance, suggestedBindings);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSuggestInteractionProfileBindings(instance, suggestedBindings);
}

XrResult GenValidUsageInputsXrAttachSessionActionSets(
XrSession session,
const XrSessionActionSetsAttachInfo* attachInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrAttachSessionActionSets-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAttachSessionActionSets",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == attachInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrAttachSessionActionSets-attachInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAttachSessionActionSets", objects_info,
                                "Invalid NULL for XrSessionActionSetsAttachInfo \"attachInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSessionActionSetsAttachInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrAttachSessionActionSets", objects_info,
                                                        true, attachInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrAttachSessionActionSets-attachInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrAttachSessionActionSets",
                                objects_info,
                                "Command xrAttachSessionActionSets param attachInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrAttachSessionActionSets(
    XrSession session,
    const XrSessionActionSetsAttachInfo* attachInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->AttachSessionActionSets(session, attachInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrAttachSessionActionSets(
    XrSession session,
    const XrSessionActionSetsAttachInfo* attachInfo) {
    XrResult test_result = GenValidUsageInputsXrAttachSessionActionSets(session, attachInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrAttachSessionActionSets(session, attachInfo);
}

XrResult GenValidUsageInputsXrGetCurrentInteractionProfile(
XrSession session,
XrPath topLevelUserPath,
XrInteractionProfileState* interactionProfile) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetCurrentInteractionProfile-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetCurrentInteractionProfile",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == interactionProfile) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetCurrentInteractionProfile-interactionProfile-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetCurrentInteractionProfile", objects_info,
                                "Invalid NULL for XrInteractionProfileState \"interactionProfile\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrInteractionProfileState is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetCurrentInteractionProfile", objects_info,
                                                        false, interactionProfile);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetCurrentInteractionProfile-interactionProfile-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetCurrentInteractionProfile",
                                objects_info,
                                "Command xrGetCurrentInteractionProfile param interactionProfile is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetCurrentInteractionProfile(
    XrSession session,
    XrPath topLevelUserPath,
    XrInteractionProfileState* interactionProfile) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetCurrentInteractionProfile(
    XrSession session,
    XrPath topLevelUserPath,
    XrInteractionProfileState* interactionProfile) {
    XrResult test_result = GenValidUsageInputsXrGetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
}

XrResult GenValidUsageInputsXrGetActionStateBoolean(
XrSession session,
const XrActionStateGetInfo* getInfo,
XrActionStateBoolean* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetActionStateBoolean-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateBoolean",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateBoolean-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateBoolean", objects_info,
                                "Invalid NULL for XrActionStateGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateBoolean", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateBoolean-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateBoolean",
                                objects_info,
                                "Command xrGetActionStateBoolean param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateBoolean-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateBoolean", objects_info,
                                "Invalid NULL for XrActionStateBoolean \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateBoolean is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateBoolean", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateBoolean-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateBoolean",
                                objects_info,
                                "Command xrGetActionStateBoolean param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetActionStateBoolean(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateBoolean* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetActionStateBoolean(session, getInfo, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetActionStateBoolean(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateBoolean* state) {
    XrResult test_result = GenValidUsageInputsXrGetActionStateBoolean(session, getInfo, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetActionStateBoolean(session, getInfo, state);
}

XrResult GenValidUsageInputsXrGetActionStateFloat(
XrSession session,
const XrActionStateGetInfo* getInfo,
XrActionStateFloat* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetActionStateFloat-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateFloat",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateFloat-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateFloat", objects_info,
                                "Invalid NULL for XrActionStateGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateFloat", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateFloat-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateFloat",
                                objects_info,
                                "Command xrGetActionStateFloat param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateFloat-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateFloat", objects_info,
                                "Invalid NULL for XrActionStateFloat \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateFloat is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateFloat", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateFloat-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateFloat",
                                objects_info,
                                "Command xrGetActionStateFloat param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetActionStateFloat(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateFloat* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetActionStateFloat(session, getInfo, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetActionStateFloat(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateFloat* state) {
    XrResult test_result = GenValidUsageInputsXrGetActionStateFloat(session, getInfo, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetActionStateFloat(session, getInfo, state);
}

XrResult GenValidUsageInputsXrGetActionStateVector2f(
XrSession session,
const XrActionStateGetInfo* getInfo,
XrActionStateVector2f* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetActionStateVector2f-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateVector2f",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateVector2f-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateVector2f", objects_info,
                                "Invalid NULL for XrActionStateGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateVector2f", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateVector2f-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateVector2f",
                                objects_info,
                                "Command xrGetActionStateVector2f param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateVector2f-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateVector2f", objects_info,
                                "Invalid NULL for XrActionStateVector2f \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateVector2f is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStateVector2f", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStateVector2f-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStateVector2f",
                                objects_info,
                                "Command xrGetActionStateVector2f param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetActionStateVector2f(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateVector2f* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetActionStateVector2f(session, getInfo, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetActionStateVector2f(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStateVector2f* state) {
    XrResult test_result = GenValidUsageInputsXrGetActionStateVector2f(session, getInfo, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetActionStateVector2f(session, getInfo, state);
}

XrResult GenValidUsageInputsXrGetActionStatePose(
XrSession session,
const XrActionStateGetInfo* getInfo,
XrActionStatePose* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetActionStatePose-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStatePose",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStatePose-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStatePose", objects_info,
                                "Invalid NULL for XrActionStateGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStateGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStatePose", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStatePose-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStatePose",
                                objects_info,
                                "Command xrGetActionStatePose param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStatePose-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStatePose", objects_info,
                                "Invalid NULL for XrActionStatePose \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionStatePose is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetActionStatePose", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetActionStatePose-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetActionStatePose",
                                objects_info,
                                "Command xrGetActionStatePose param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetActionStatePose(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStatePose* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetActionStatePose(session, getInfo, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetActionStatePose(
    XrSession session,
    const XrActionStateGetInfo* getInfo,
    XrActionStatePose* state) {
    XrResult test_result = GenValidUsageInputsXrGetActionStatePose(session, getInfo, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetActionStatePose(session, getInfo, state);
}

XrResult GenValidUsageInputsXrSyncActions(
XrSession session,
const XrActionsSyncInfo* syncInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSyncActions-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSyncActions",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == syncInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSyncActions-syncInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSyncActions", objects_info,
                                "Invalid NULL for XrActionsSyncInfo \"syncInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrActionsSyncInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSyncActions", objects_info,
                                                        true, syncInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSyncActions-syncInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSyncActions",
                                objects_info,
                                "Command xrSyncActions param syncInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSyncActions(
    XrSession session,
    const XrActionsSyncInfo* syncInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SyncActions(session, syncInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSyncActions(
    XrSession session,
    const XrActionsSyncInfo* syncInfo) {
    XrResult test_result = GenValidUsageInputsXrSyncActions(session, syncInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSyncActions(session, syncInfo);
}

XrResult GenValidUsageInputsXrEnumerateBoundSourcesForAction(
XrSession session,
const XrBoundSourcesForActionEnumerateInfo* enumerateInfo,
uint32_t sourceCapacityInput,
uint32_t* sourceCountOutput,
XrPath* sources) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateBoundSourcesForAction-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateBoundSourcesForAction",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == enumerateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateBoundSourcesForAction-enumerateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateBoundSourcesForAction", objects_info,
                                "Invalid NULL for XrBoundSourcesForActionEnumerateInfo \"enumerateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBoundSourcesForActionEnumerateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateBoundSourcesForAction", objects_info,
                                                        true, enumerateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateBoundSourcesForAction-enumerateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateBoundSourcesForAction",
                                objects_info,
                                "Command xrEnumerateBoundSourcesForAction param enumerateInfo is invalid");
            return xr_result;
        }
        // Optional array must be non-NULL when sourceCapacityInput is non-zero
        if (0 != sourceCapacityInput && nullptr == sources) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateBoundSourcesForAction-sources-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateBoundSourcesForAction",
                                objects_info,
                                "Command xrEnumerateBoundSourcesForAction param sources is NULL, but sourceCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == sourceCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateBoundSourcesForAction-sourceCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateBoundSourcesForAction", objects_info,
                                "Invalid NULL for uint32_t \"sourceCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateBoundSourcesForAction-sourceCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrEnumerateBoundSourcesForAction-sources-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateBoundSourcesForAction(
    XrSession session,
    const XrBoundSourcesForActionEnumerateInfo* enumerateInfo,
    uint32_t sourceCapacityInput,
    uint32_t* sourceCountOutput,
    XrPath* sources) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateBoundSourcesForAction(
    XrSession session,
    const XrBoundSourcesForActionEnumerateInfo* enumerateInfo,
    uint32_t sourceCapacityInput,
    uint32_t* sourceCountOutput,
    XrPath* sources) {
    XrResult test_result = GenValidUsageInputsXrEnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
}

XrResult GenValidUsageInputsXrGetInputSourceLocalizedName(
XrSession session,
const XrInputSourceLocalizedNameGetInfo* getInfo,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetInputSourceLocalizedName-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInputSourceLocalizedName",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInputSourceLocalizedName-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInputSourceLocalizedName", objects_info,
                                "Invalid NULL for XrInputSourceLocalizedNameGetInfo \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrInputSourceLocalizedNameGetInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetInputSourceLocalizedName", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInputSourceLocalizedName-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInputSourceLocalizedName",
                                objects_info,
                                "Command xrGetInputSourceLocalizedName param getInfo is invalid");
            return xr_result;
        }
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInputSourceLocalizedName-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInputSourceLocalizedName",
                                objects_info,
                                "Command xrGetInputSourceLocalizedName param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetInputSourceLocalizedName-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInputSourceLocalizedName", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetInputSourceLocalizedName-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetInputSourceLocalizedName-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetInputSourceLocalizedName(
    XrSession session,
    const XrInputSourceLocalizedNameGetInfo* getInfo,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetInputSourceLocalizedName(
    XrSession session,
    const XrInputSourceLocalizedNameGetInfo* getInfo,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
}

XrResult GenValidUsageInputsXrApplyHapticFeedback(
XrSession session,
const XrHapticActionInfo* hapticActionInfo,
const XrHapticBaseHeader* hapticFeedback) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrApplyHapticFeedback-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == hapticActionInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback", objects_info,
                                "Invalid NULL for XrHapticActionInfo \"hapticActionInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHapticActionInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrApplyHapticFeedback", objects_info,
                                                        true, hapticActionInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                objects_info,
                                "Command xrApplyHapticFeedback param hapticActionInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == hapticFeedback) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticFeedback-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback", objects_info,
                                "Invalid NULL for XrHapticBaseHeader \"hapticFeedback\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate if XrHapticBaseHeader is a child structure of type XrHapticVibration and it is valid
        {
            const XrHapticVibration* new_hapticvibration_value = reinterpret_cast<const XrHapticVibration*>(hapticFeedback);
            if (new_hapticvibration_value->type == XR_TYPE_HAPTIC_VIBRATION) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrApplyHapticFeedback",
                                                                objects_info,false, new_hapticvibration_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrApplyHapticFeedback param hapticFeedback";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticFeedback-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
        // Validate if XrHapticBaseHeader is a child structure of type XrHapticAmplitudeEnvelopeVibrationFB and it is valid
        {
            const XrHapticAmplitudeEnvelopeVibrationFB* new_hapticamplitudeenvelopevibrationfb_value = reinterpret_cast<const XrHapticAmplitudeEnvelopeVibrationFB*>(hapticFeedback);
            if (new_hapticamplitudeenvelopevibrationfb_value->type == XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrApplyHapticFeedback",
                                                                objects_info,false, new_hapticamplitudeenvelopevibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrApplyHapticFeedback param hapticFeedback";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticFeedback-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
        // Validate if XrHapticBaseHeader is a child structure of type XrHapticPcmVibrationFB and it is valid
        {
            const XrHapticPcmVibrationFB* new_hapticpcmvibrationfb_value = reinterpret_cast<const XrHapticPcmVibrationFB*>(hapticFeedback);
            if (new_hapticpcmvibrationfb_value->type == XR_TYPE_HAPTIC_PCM_VIBRATION_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrApplyHapticFeedback",
                                                                objects_info,false, new_hapticpcmvibrationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrApplyHapticFeedback param hapticFeedback";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticFeedback-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
        // Validate that the base-structure XrHapticBaseHeader is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrApplyHapticFeedback", objects_info,
                                                        true, hapticFeedback);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyHapticFeedback-hapticFeedback-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyHapticFeedback",
                                objects_info,
                                "Command xrApplyHapticFeedback param hapticFeedback is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrApplyHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    const XrHapticBaseHeader* hapticFeedback) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrApplyHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    const XrHapticBaseHeader* hapticFeedback) {
    XrResult test_result = GenValidUsageInputsXrApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
}

XrResult GenValidUsageInputsXrStopHapticFeedback(
XrSession session,
const XrHapticActionInfo* hapticActionInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrStopHapticFeedback-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStopHapticFeedback",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == hapticActionInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrStopHapticFeedback-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStopHapticFeedback", objects_info,
                                "Invalid NULL for XrHapticActionInfo \"hapticActionInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHapticActionInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrStopHapticFeedback", objects_info,
                                                        true, hapticActionInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrStopHapticFeedback-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrStopHapticFeedback",
                                objects_info,
                                "Command xrStopHapticFeedback param hapticActionInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrStopHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->StopHapticFeedback(session, hapticActionInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrStopHapticFeedback(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo) {
    XrResult test_result = GenValidUsageInputsXrStopHapticFeedback(session, hapticActionInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrStopHapticFeedback(session, hapticActionInfo);
}


// ---- Core ERSION.1.0 commands

// ---- XR_KHR_android_thread_settings extension commands
#if defined(XR_USE_PLATFORM_ANDROID)

XrResult GenValidUsageInputsXrSetAndroidApplicationThreadKHR(
XrSession session,
XrAndroidThreadTypeKHR threadType,
uint32_t threadId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetAndroidApplicationThreadKHR-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetAndroidApplicationThreadKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrAndroidThreadTypeKHR value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrSetAndroidApplicationThreadKHR", "xrSetAndroidApplicationThreadKHR", "threadType", objects_info, threadType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrAndroidThreadTypeKHR \"threadType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(threadType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetAndroidApplicationThreadKHR-threadType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetAndroidApplicationThreadKHR",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetAndroidApplicationThreadKHR(
    XrSession session,
    XrAndroidThreadTypeKHR threadType,
    uint32_t threadId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetAndroidApplicationThreadKHR(session, threadType, threadId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetAndroidApplicationThreadKHR(
    XrSession session,
    XrAndroidThreadTypeKHR threadType,
    uint32_t threadId) {
    XrResult test_result = GenValidUsageInputsXrSetAndroidApplicationThreadKHR(session, threadType, threadId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetAndroidApplicationThreadKHR(session, threadType, threadId);
}

#endif // defined(XR_USE_PLATFORM_ANDROID)


// ---- XR_KHR_android_surface_swapchain extension commands
#if defined(XR_USE_PLATFORM_ANDROID)

XrResult GenValidUsageInputsXrCreateSwapchainAndroidSurfaceKHR(
XrSession session,
const XrSwapchainCreateInfo* info,
XrSwapchain* swapchain,
jobject* surface) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSwapchainAndroidSurfaceKHR-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchainAndroidSurfaceKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchainAndroidSurfaceKHR-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchainAndroidSurfaceKHR", objects_info,
                                "Invalid NULL for XrSwapchainCreateInfo \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSwapchainCreateInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSwapchainAndroidSurfaceKHR", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchainAndroidSurfaceKHR-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchainAndroidSurfaceKHR",
                                objects_info,
                                "Command xrCreateSwapchainAndroidSurfaceKHR param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == swapchain) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchainAndroidSurfaceKHR-swapchain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchainAndroidSurfaceKHR", objects_info,
                                "Invalid NULL for XrSwapchain \"swapchain\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == surface) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSwapchainAndroidSurfaceKHR-surface-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSwapchainAndroidSurfaceKHR", objects_info,
                                "Invalid NULL for jobject \"surface\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateSwapchainAndroidSurfaceKHR-surface-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSwapchainAndroidSurfaceKHR(
    XrSession session,
    const XrSwapchainCreateInfo* info,
    XrSwapchain* swapchain,
    jobject* surface) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSwapchainAndroidSurfaceKHR(
    XrSession session,
    const XrSwapchainCreateInfo* info,
    XrSwapchain* swapchain,
    jobject* surface) {
    XrResult test_result = GenValidUsageInputsXrCreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
}

#endif // defined(XR_USE_PLATFORM_ANDROID)


// ---- XR_KHR_opengl_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL)

XrResult GenValidUsageInputsXrGetOpenGLGraphicsRequirementsKHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsOpenGLKHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetOpenGLGraphicsRequirementsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLGraphicsRequirementsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetOpenGLGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLGraphicsRequirementsKHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsOpenGLKHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsOpenGLKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetOpenGLGraphicsRequirementsKHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetOpenGLGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLGraphicsRequirementsKHR",
                                objects_info,
                                "Command xrGetOpenGLGraphicsRequirementsKHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetOpenGLGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetOpenGLGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL)


// ---- XR_KHR_opengl_es_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)

XrResult GenValidUsageInputsXrGetOpenGLESGraphicsRequirementsKHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetOpenGLESGraphicsRequirementsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLESGraphicsRequirementsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetOpenGLESGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLESGraphicsRequirementsKHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsOpenGLESKHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsOpenGLESKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetOpenGLESGraphicsRequirementsKHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetOpenGLESGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetOpenGLESGraphicsRequirementsKHR",
                                objects_info,
                                "Command xrGetOpenGLESGraphicsRequirementsKHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetOpenGLESGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetOpenGLESGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)


// ---- XR_KHR_vulkan_enable extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanInstanceExtensionsKHR(
XrInstance instance,
XrSystemId systemId,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanInstanceExtensionsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanInstanceExtensionsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanInstanceExtensionsKHR-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanInstanceExtensionsKHR",
                                objects_info,
                                "Command xrGetVulkanInstanceExtensionsKHR param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanInstanceExtensionsKHR-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanInstanceExtensionsKHR", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVulkanInstanceExtensionsKHR-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetVulkanInstanceExtensionsKHR-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanInstanceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanInstanceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanDeviceExtensionsKHR(
XrInstance instance,
XrSystemId systemId,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanDeviceExtensionsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanDeviceExtensionsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanDeviceExtensionsKHR-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanDeviceExtensionsKHR",
                                objects_info,
                                "Command xrGetVulkanDeviceExtensionsKHR param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanDeviceExtensionsKHR-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanDeviceExtensionsKHR", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVulkanDeviceExtensionsKHR-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetVulkanDeviceExtensionsKHR-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanDeviceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanDeviceExtensionsKHR(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanGraphicsDeviceKHR(
XrInstance instance,
XrSystemId systemId,
VkInstance vkInstance,
VkPhysicalDevice* vkPhysicalDevice) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanGraphicsDeviceKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDeviceKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vkPhysicalDevice) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsDeviceKHR-vkPhysicalDevice-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDeviceKHR", objects_info,
                                "Invalid NULL for VkPhysicalDevice \"vkPhysicalDevice\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVulkanGraphicsDeviceKHR-vkPhysicalDevice-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanGraphicsDeviceKHR(
    XrInstance instance,
    XrSystemId systemId,
    VkInstance vkInstance,
    VkPhysicalDevice* vkPhysicalDevice) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanGraphicsDeviceKHR(
    XrInstance instance,
    XrSystemId systemId,
    VkInstance vkInstance,
    VkPhysicalDevice* vkPhysicalDevice) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanGraphicsRequirementsKHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanGraphicsRequirementsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirementsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirementsKHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsVulkanKHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsVulkanKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVulkanGraphicsRequirementsKHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirementsKHR",
                                objects_info,
                                "Command xrGetVulkanGraphicsRequirementsKHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanGraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)


// ---- XR_KHR_D3D11_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D11)

XrResult GenValidUsageInputsXrGetD3D11GraphicsRequirementsKHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsD3D11KHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetD3D11GraphicsRequirementsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D11GraphicsRequirementsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetD3D11GraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D11GraphicsRequirementsKHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsD3D11KHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsD3D11KHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetD3D11GraphicsRequirementsKHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetD3D11GraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D11GraphicsRequirementsKHR",
                                objects_info,
                                "Command xrGetD3D11GraphicsRequirementsKHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetD3D11GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D11KHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetD3D11GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D11KHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_D3D11)


// ---- XR_KHR_D3D12_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D12)

XrResult GenValidUsageInputsXrGetD3D12GraphicsRequirementsKHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsD3D12KHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetD3D12GraphicsRequirementsKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D12GraphicsRequirementsKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetD3D12GraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D12GraphicsRequirementsKHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsD3D12KHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsD3D12KHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetD3D12GraphicsRequirementsKHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetD3D12GraphicsRequirementsKHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetD3D12GraphicsRequirementsKHR",
                                objects_info,
                                "Command xrGetD3D12GraphicsRequirementsKHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetD3D12GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D12KHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetD3D12GraphicsRequirementsKHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsD3D12KHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_D3D12)


// ---- XR_KHR_visibility_mask extension commands
XrResult GenValidUsageInputsXrGetVisibilityMaskKHR(
XrSession session,
XrViewConfigurationType viewConfigurationType,
uint32_t viewIndex,
XrVisibilityMaskTypeKHR visibilityMaskType,
XrVisibilityMaskKHR* visibilityMask) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetVisibilityMaskKHR-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVisibilityMaskKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrViewConfigurationType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetVisibilityMaskKHR", "xrGetVisibilityMaskKHR", "viewConfigurationType", objects_info, viewConfigurationType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(viewConfigurationType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVisibilityMaskKHR-viewConfigurationType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVisibilityMaskKHR",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrVisibilityMaskTypeKHR value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetVisibilityMaskKHR", "xrGetVisibilityMaskKHR", "visibilityMaskType", objects_info, visibilityMaskType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrVisibilityMaskTypeKHR \"visibilityMaskType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(visibilityMaskType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVisibilityMaskKHR-visibilityMaskType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVisibilityMaskKHR",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == visibilityMask) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVisibilityMaskKHR-visibilityMask-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVisibilityMaskKHR", objects_info,
                                "Invalid NULL for XrVisibilityMaskKHR \"visibilityMask\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVisibilityMaskKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVisibilityMaskKHR", objects_info,
                                                        false, visibilityMask);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVisibilityMaskKHR-visibilityMask-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVisibilityMaskKHR",
                                objects_info,
                                "Command xrGetVisibilityMaskKHR param visibilityMask is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVisibilityMaskKHR(
    XrSession session,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewIndex,
    XrVisibilityMaskTypeKHR visibilityMaskType,
    XrVisibilityMaskKHR* visibilityMask) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVisibilityMaskKHR(
    XrSession session,
    XrViewConfigurationType viewConfigurationType,
    uint32_t viewIndex,
    XrVisibilityMaskTypeKHR visibilityMaskType,
    XrVisibilityMaskKHR* visibilityMask) {
    XrResult test_result = GenValidUsageInputsXrGetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
}


// ---- XR_KHR_win32_convert_performance_counter_time extension commands
#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrConvertWin32PerformanceCounterToTimeKHR(
XrInstance instance,
const LARGE_INTEGER* performanceCounter,
XrTime* time) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrConvertWin32PerformanceCounterToTimeKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertWin32PerformanceCounterToTimeKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == performanceCounter) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertWin32PerformanceCounterToTimeKHR-performanceCounter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertWin32PerformanceCounterToTimeKHR", objects_info,
                                "Invalid NULL for LARGE_INTEGER \"performanceCounter\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertWin32PerformanceCounterToTimeKHR-performanceCounter-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == time) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertWin32PerformanceCounterToTimeKHR-time-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertWin32PerformanceCounterToTimeKHR", objects_info,
                                "Invalid NULL for XrTime \"time\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertWin32PerformanceCounterToTimeKHR-time-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrConvertWin32PerformanceCounterToTimeKHR(
    XrInstance instance,
    const LARGE_INTEGER* performanceCounter,
    XrTime* time) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->ConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrConvertWin32PerformanceCounterToTimeKHR(
    XrInstance instance,
    const LARGE_INTEGER* performanceCounter,
    XrTime* time) {
    XrResult test_result = GenValidUsageInputsXrConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
}

#endif // defined(XR_USE_PLATFORM_WIN32)

#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrConvertTimeToWin32PerformanceCounterKHR(
XrInstance instance,
XrTime time,
LARGE_INTEGER* performanceCounter) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrConvertTimeToWin32PerformanceCounterKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimeToWin32PerformanceCounterKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == performanceCounter) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertTimeToWin32PerformanceCounterKHR-performanceCounter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimeToWin32PerformanceCounterKHR", objects_info,
                                "Invalid NULL for LARGE_INTEGER \"performanceCounter\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertTimeToWin32PerformanceCounterKHR-performanceCounter-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrConvertTimeToWin32PerformanceCounterKHR(
    XrInstance instance,
    XrTime time,
    LARGE_INTEGER* performanceCounter) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->ConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrConvertTimeToWin32PerformanceCounterKHR(
    XrInstance instance,
    XrTime time,
    LARGE_INTEGER* performanceCounter) {
    XrResult test_result = GenValidUsageInputsXrConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
}

#endif // defined(XR_USE_PLATFORM_WIN32)


// ---- XR_KHR_convert_timespec_time extension commands
#if defined(XR_USE_TIMESPEC)

XrResult GenValidUsageInputsXrConvertTimespecTimeToTimeKHR(
XrInstance instance,
const struct timespec* timespecTime,
XrTime* time) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrConvertTimespecTimeToTimeKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimespecTimeToTimeKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == timespecTime) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertTimespecTimeToTimeKHR-timespecTime-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimespecTimeToTimeKHR", objects_info,
                                "Invalid NULL for timespec \"timespecTime\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertTimespecTimeToTimeKHR-timespecTime-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == time) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertTimespecTimeToTimeKHR-time-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimespecTimeToTimeKHR", objects_info,
                                "Invalid NULL for XrTime \"time\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertTimespecTimeToTimeKHR-time-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrConvertTimespecTimeToTimeKHR(
    XrInstance instance,
    const struct timespec* timespecTime,
    XrTime* time) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->ConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrConvertTimespecTimeToTimeKHR(
    XrInstance instance,
    const struct timespec* timespecTime,
    XrTime* time) {
    XrResult test_result = GenValidUsageInputsXrConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
}

#endif // defined(XR_USE_TIMESPEC)

#if defined(XR_USE_TIMESPEC)

XrResult GenValidUsageInputsXrConvertTimeToTimespecTimeKHR(
XrInstance instance,
XrTime time,
struct timespec* timespecTime) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrConvertTimeToTimespecTimeKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimeToTimespecTimeKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == timespecTime) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrConvertTimeToTimespecTimeKHR-timespecTime-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrConvertTimeToTimespecTimeKHR", objects_info,
                                "Invalid NULL for timespec \"timespecTime\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrConvertTimeToTimespecTimeKHR-timespecTime-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrConvertTimeToTimespecTimeKHR(
    XrInstance instance,
    XrTime time,
    struct timespec* timespecTime) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->ConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrConvertTimeToTimespecTimeKHR(
    XrInstance instance,
    XrTime time,
    struct timespec* timespecTime) {
    XrResult test_result = GenValidUsageInputsXrConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
}

#endif // defined(XR_USE_TIMESPEC)


// ---- XR_KHR_loader_init extension commands

// ---- XR_KHR_vulkan_enable2 extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrCreateVulkanInstanceKHR(
XrInstance instance,
const XrVulkanInstanceCreateInfoKHR* createInfo,
VkInstance* vulkanInstance,
VkResult* vulkanResult) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrCreateVulkanInstanceKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanInstanceKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanInstanceKHR-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanInstanceKHR", objects_info,
                                "Invalid NULL for XrVulkanInstanceCreateInfoKHR \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVulkanInstanceCreateInfoKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateVulkanInstanceKHR", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanInstanceKHR-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanInstanceKHR",
                                objects_info,
                                "Command xrCreateVulkanInstanceKHR param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vulkanInstance) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanInstanceKHR-vulkanInstance-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanInstanceKHR", objects_info,
                                "Invalid NULL for VkInstance \"vulkanInstance\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateVulkanInstanceKHR-vulkanInstance-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vulkanResult) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanInstanceKHR-vulkanResult-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanInstanceKHR", objects_info,
                                "Invalid NULL for VkResult \"vulkanResult\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateVulkanInstanceKHR-vulkanResult-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateVulkanInstanceKHR(
    XrInstance instance,
    const XrVulkanInstanceCreateInfoKHR* createInfo,
    VkInstance* vulkanInstance,
    VkResult* vulkanResult) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->CreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateVulkanInstanceKHR(
    XrInstance instance,
    const XrVulkanInstanceCreateInfoKHR* createInfo,
    VkInstance* vulkanInstance,
    VkResult* vulkanResult) {
    XrResult test_result = GenValidUsageInputsXrCreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrCreateVulkanDeviceKHR(
XrInstance instance,
const XrVulkanDeviceCreateInfoKHR* createInfo,
VkDevice* vulkanDevice,
VkResult* vulkanResult) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrCreateVulkanDeviceKHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanDeviceKHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanDeviceKHR-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanDeviceKHR", objects_info,
                                "Invalid NULL for XrVulkanDeviceCreateInfoKHR \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVulkanDeviceCreateInfoKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateVulkanDeviceKHR", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanDeviceKHR-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanDeviceKHR",
                                objects_info,
                                "Command xrCreateVulkanDeviceKHR param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vulkanDevice) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanDeviceKHR-vulkanDevice-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanDeviceKHR", objects_info,
                                "Invalid NULL for VkDevice \"vulkanDevice\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateVulkanDeviceKHR-vulkanDevice-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vulkanResult) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVulkanDeviceKHR-vulkanResult-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVulkanDeviceKHR", objects_info,
                                "Invalid NULL for VkResult \"vulkanResult\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateVulkanDeviceKHR-vulkanResult-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateVulkanDeviceKHR(
    XrInstance instance,
    const XrVulkanDeviceCreateInfoKHR* createInfo,
    VkDevice* vulkanDevice,
    VkResult* vulkanResult) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->CreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateVulkanDeviceKHR(
    XrInstance instance,
    const XrVulkanDeviceCreateInfoKHR* createInfo,
    VkDevice* vulkanDevice,
    VkResult* vulkanResult) {
    XrResult test_result = GenValidUsageInputsXrCreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanGraphicsDevice2KHR(
XrInstance instance,
const XrVulkanGraphicsDeviceGetInfoKHR* getInfo,
VkPhysicalDevice* vulkanPhysicalDevice) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanGraphicsDevice2KHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDevice2KHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsDevice2KHR-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDevice2KHR", objects_info,
                                "Invalid NULL for XrVulkanGraphicsDeviceGetInfoKHR \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVulkanGraphicsDeviceGetInfoKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVulkanGraphicsDevice2KHR", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsDevice2KHR-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDevice2KHR",
                                objects_info,
                                "Command xrGetVulkanGraphicsDevice2KHR param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == vulkanPhysicalDevice) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsDevice2KHR-vulkanPhysicalDevice-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsDevice2KHR", objects_info,
                                "Invalid NULL for VkPhysicalDevice \"vulkanPhysicalDevice\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVulkanGraphicsDevice2KHR-vulkanPhysicalDevice-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanGraphicsDevice2KHR(
    XrInstance instance,
    const XrVulkanGraphicsDeviceGetInfoKHR* getInfo,
    VkPhysicalDevice* vulkanPhysicalDevice) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanGraphicsDevice2KHR(
    XrInstance instance,
    const XrVulkanGraphicsDeviceGetInfoKHR* getInfo,
    VkPhysicalDevice* vulkanPhysicalDevice) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

#if defined(XR_USE_GRAPHICS_API_VULKAN)

XrResult GenValidUsageInputsXrGetVulkanGraphicsRequirements2KHR(
XrInstance instance,
XrSystemId systemId,
XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetVulkanGraphicsRequirements2KHR-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirements2KHR",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == graphicsRequirements) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsRequirements2KHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirements2KHR", objects_info,
                                "Invalid NULL for XrGraphicsRequirementsVulkanKHR \"graphicsRequirements\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGraphicsRequirementsVulkanKHR is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVulkanGraphicsRequirements2KHR", objects_info,
                                                        false, graphicsRequirements);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVulkanGraphicsRequirements2KHR-graphicsRequirements-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVulkanGraphicsRequirements2KHR",
                                objects_info,
                                "Command xrGetVulkanGraphicsRequirements2KHR param graphicsRequirements is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVulkanGraphicsRequirements2KHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetVulkanGraphicsRequirements2KHR(instance, systemId, graphicsRequirements);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVulkanGraphicsRequirements2KHR(
    XrInstance instance,
    XrSystemId systemId,
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements) {
    XrResult test_result = GenValidUsageInputsXrGetVulkanGraphicsRequirements2KHR(instance, systemId, graphicsRequirements);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVulkanGraphicsRequirements2KHR(instance, systemId, graphicsRequirements);
}

#endif // defined(XR_USE_GRAPHICS_API_VULKAN)


// ---- XR_EXT_performance_settings extension commands
XrResult GenValidUsageInputsXrPerfSettingsSetPerformanceLevelEXT(
XrSession session,
XrPerfSettingsDomainEXT domain,
XrPerfSettingsLevelEXT level) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrPerfSettingsSetPerformanceLevelEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPerfSettingsSetPerformanceLevelEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrPerfSettingsDomainEXT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrPerfSettingsSetPerformanceLevelEXT", "xrPerfSettingsSetPerformanceLevelEXT", "domain", objects_info, domain)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrPerfSettingsDomainEXT \"domain\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(domain));
            CoreValidLogMessage(gen_instance_info, "VUID-xrPerfSettingsSetPerformanceLevelEXT-domain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPerfSettingsSetPerformanceLevelEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrPerfSettingsLevelEXT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrPerfSettingsSetPerformanceLevelEXT", "xrPerfSettingsSetPerformanceLevelEXT", "level", objects_info, level)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrPerfSettingsLevelEXT \"level\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(level));
            CoreValidLogMessage(gen_instance_info, "VUID-xrPerfSettingsSetPerformanceLevelEXT-level-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPerfSettingsSetPerformanceLevelEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPerfSettingsSetPerformanceLevelEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsLevelEXT level) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PerfSettingsSetPerformanceLevelEXT(session, domain, level);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPerfSettingsSetPerformanceLevelEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsLevelEXT level) {
    XrResult test_result = GenValidUsageInputsXrPerfSettingsSetPerformanceLevelEXT(session, domain, level);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPerfSettingsSetPerformanceLevelEXT(session, domain, level);
}


// ---- XR_EXT_thermal_query extension commands
XrResult GenValidUsageInputsXrThermalGetTemperatureTrendEXT(
XrSession session,
XrPerfSettingsDomainEXT domain,
XrPerfSettingsNotificationLevelEXT* notificationLevel,
float* tempHeadroom,
float* tempSlope) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrThermalGetTemperatureTrendEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrPerfSettingsDomainEXT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrThermalGetTemperatureTrendEXT", "xrThermalGetTemperatureTrendEXT", "domain", objects_info, domain)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrPerfSettingsDomainEXT \"domain\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(domain));
            CoreValidLogMessage(gen_instance_info, "VUID-xrThermalGetTemperatureTrendEXT-domain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == notificationLevel) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrThermalGetTemperatureTrendEXT-notificationLevel-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT", objects_info,
                                "Invalid NULL for XrPerfSettingsNotificationLevelEXT \"notificationLevel\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrPerfSettingsNotificationLevelEXT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrThermalGetTemperatureTrendEXT", "xrThermalGetTemperatureTrendEXT", "notificationLevel", objects_info, *notificationLevel)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrPerfSettingsNotificationLevelEXT \"notificationLevel\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(*notificationLevel));
            CoreValidLogMessage(gen_instance_info, "VUID-xrThermalGetTemperatureTrendEXT-notificationLevel-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == tempHeadroom) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrThermalGetTemperatureTrendEXT-tempHeadroom-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT", objects_info,
                                "Invalid NULL for float \"tempHeadroom\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrThermalGetTemperatureTrendEXT-tempHeadroom-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == tempSlope) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrThermalGetTemperatureTrendEXT-tempSlope-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrThermalGetTemperatureTrendEXT", objects_info,
                                "Invalid NULL for float \"tempSlope\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrThermalGetTemperatureTrendEXT-tempSlope-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrThermalGetTemperatureTrendEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsNotificationLevelEXT* notificationLevel,
    float* tempHeadroom,
    float* tempSlope) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrThermalGetTemperatureTrendEXT(
    XrSession session,
    XrPerfSettingsDomainEXT domain,
    XrPerfSettingsNotificationLevelEXT* notificationLevel,
    float* tempHeadroom,
    float* tempSlope) {
    XrResult test_result = GenValidUsageInputsXrThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
}


// ---- XR_EXT_debug_utils extension commands
XrResult GenValidUsageInputsXrSetDebugUtilsObjectNameEXT(
XrInstance instance,
const XrDebugUtilsObjectNameInfoEXT* nameInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrSetDebugUtilsObjectNameEXT-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDebugUtilsObjectNameEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == nameInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetDebugUtilsObjectNameEXT-nameInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDebugUtilsObjectNameEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsObjectNameInfoEXT \"nameInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDebugUtilsObjectNameInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSetDebugUtilsObjectNameEXT", objects_info,
                                                        true, nameInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetDebugUtilsObjectNameEXT-nameInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDebugUtilsObjectNameEXT",
                                objects_info,
                                "Command xrSetDebugUtilsObjectNameEXT param nameInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetDebugUtilsObjectNameEXT(
    XrInstance instance,
    const XrDebugUtilsObjectNameInfoEXT* nameInfo) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->SetDebugUtilsObjectNameEXT(instance, nameInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrCreateDebugUtilsMessengerEXT(
XrInstance instance,
const XrDebugUtilsMessengerCreateInfoEXT* createInfo,
XrDebugUtilsMessengerEXT* messenger) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrCreateDebugUtilsMessengerEXT-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateDebugUtilsMessengerEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateDebugUtilsMessengerEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateDebugUtilsMessengerEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsMessengerCreateInfoEXT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDebugUtilsMessengerCreateInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateDebugUtilsMessengerEXT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateDebugUtilsMessengerEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateDebugUtilsMessengerEXT",
                                objects_info,
                                "Command xrCreateDebugUtilsMessengerEXT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == messenger) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateDebugUtilsMessengerEXT-messenger-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateDebugUtilsMessengerEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsMessengerEXT \"messenger\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateDebugUtilsMessengerEXT(
    XrInstance instance,
    const XrDebugUtilsMessengerCreateInfoEXT* createInfo,
    XrDebugUtilsMessengerEXT* messenger) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->CreateDebugUtilsMessengerEXT(instance, createInfo, messenger);
        if (XR_SUCCESS == result && nullptr != messenger) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_INSTANCE;
            handle_info->direct_parent_handle = MakeHandleGeneric(instance);
            g_debugutilsmessengerext_info.insert(*messenger, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrDestroyDebugUtilsMessengerEXT(
XrDebugUtilsMessengerEXT messenger) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(messenger, XR_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrDebugUtilsMessengerEXTHandle(&messenger);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrDebugUtilsMessengerEXT handle \"messenger\" ";
                oss << HandleToHexString(messenger);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyDebugUtilsMessengerEXT-messenger-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyDebugUtilsMessengerEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_debugutilsmessengerext_info.getWithInstanceInfo(messenger);
        GenValidUsageXrHandleInfo *gen_debugutilsmessengerext_info = info_with_instance.first;
        (void)gen_debugutilsmessengerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyDebugUtilsMessengerEXT(
    XrDebugUtilsMessengerEXT messenger) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_debugutilsmessengerext_info.getWithInstanceInfo(messenger);
        GenValidUsageXrHandleInfo *gen_debugutilsmessengerext_info = info_with_instance.first;
        (void)gen_debugutilsmessengerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyDebugUtilsMessengerEXT(messenger);
        if (XR_SUCCEEDED(result)) {
            g_debugutilsmessengerext_info.erase(messenger);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrSubmitDebugUtilsMessageEXT(
XrInstance instance,
XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
XrDebugUtilsMessageTypeFlagsEXT messageTypes,
const XrDebugUtilsMessengerCallbackDataEXT* callbackData) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrSubmitDebugUtilsMessageEXT-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        ValidateXrFlagsResult debug_utils_message_severity_flags_ext_result = ValidateXrDebugUtilsMessageSeverityFlagsEXT(messageSeverity);
        // Flags must be non-zero in this case.
        if (VALIDATE_XR_FLAGS_ZERO == debug_utils_message_severity_flags_ext_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-messageSeverity-requiredbitmask",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                objects_info, "XrDebugUtilsMessageSeverityFlagsEXT \"messageSeverity\" flag must be non-zero");
            return XR_ERROR_VALIDATION_FAILURE;
        } else if (VALIDATE_XR_FLAGS_SUCCESS != debug_utils_message_severity_flags_ext_result) {
            // Otherwise, flags must be valid.
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrDebugUtilsMessageSeverityFlagsEXT \"messageSeverity\" flag value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(messageSeverity));
            oss_enum <<" contains illegal bit";
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-messageSeverity-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        ValidateXrFlagsResult debug_utils_message_type_flags_ext_result = ValidateXrDebugUtilsMessageTypeFlagsEXT(messageTypes);
        // Flags must be non-zero in this case.
        if (VALIDATE_XR_FLAGS_ZERO == debug_utils_message_type_flags_ext_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-messageTypes-requiredbitmask",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                objects_info, "XrDebugUtilsMessageTypeFlagsEXT \"messageTypes\" flag must be non-zero");
            return XR_ERROR_VALIDATION_FAILURE;
        } else if (VALIDATE_XR_FLAGS_SUCCESS != debug_utils_message_type_flags_ext_result) {
            // Otherwise, flags must be valid.
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrDebugUtilsMessageTypeFlagsEXT \"messageTypes\" flag value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(messageTypes));
            oss_enum <<" contains illegal bit";
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-messageTypes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == callbackData) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-callbackData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsMessengerCallbackDataEXT \"callbackData\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDebugUtilsMessengerCallbackDataEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSubmitDebugUtilsMessageEXT", objects_info,
                                                        true, callbackData);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSubmitDebugUtilsMessageEXT-callbackData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSubmitDebugUtilsMessageEXT",
                                objects_info,
                                "Command xrSubmitDebugUtilsMessageEXT param callbackData is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSubmitDebugUtilsMessageEXT(
    XrInstance instance,
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
    const XrDebugUtilsMessengerCallbackDataEXT* callbackData) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSubmitDebugUtilsMessageEXT(
    XrInstance instance,
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity,
    XrDebugUtilsMessageTypeFlagsEXT messageTypes,
    const XrDebugUtilsMessengerCallbackDataEXT* callbackData) {
    XrResult test_result = GenValidUsageInputsXrSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
}

XrResult GenValidUsageInputsXrSessionBeginDebugUtilsLabelRegionEXT(
XrSession session,
const XrDebugUtilsLabelEXT* labelInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSessionBeginDebugUtilsLabelRegionEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionBeginDebugUtilsLabelRegionEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == labelInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSessionBeginDebugUtilsLabelRegionEXT-labelInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionBeginDebugUtilsLabelRegionEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsLabelEXT \"labelInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDebugUtilsLabelEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSessionBeginDebugUtilsLabelRegionEXT", objects_info,
                                                        true, labelInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSessionBeginDebugUtilsLabelRegionEXT-labelInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionBeginDebugUtilsLabelRegionEXT",
                                objects_info,
                                "Command xrSessionBeginDebugUtilsLabelRegionEXT param labelInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSessionBeginDebugUtilsLabelRegionEXT(
    XrSession session,
    const XrDebugUtilsLabelEXT* labelInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SessionBeginDebugUtilsLabelRegionEXT(session, labelInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrSessionEndDebugUtilsLabelRegionEXT(
XrSession session) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSessionEndDebugUtilsLabelRegionEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionEndDebugUtilsLabelRegionEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSessionEndDebugUtilsLabelRegionEXT(
    XrSession session) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SessionEndDebugUtilsLabelRegionEXT(session);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XrResult GenValidUsageInputsXrSessionInsertDebugUtilsLabelEXT(
XrSession session,
const XrDebugUtilsLabelEXT* labelInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSessionInsertDebugUtilsLabelEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionInsertDebugUtilsLabelEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == labelInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSessionInsertDebugUtilsLabelEXT-labelInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionInsertDebugUtilsLabelEXT", objects_info,
                                "Invalid NULL for XrDebugUtilsLabelEXT \"labelInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDebugUtilsLabelEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSessionInsertDebugUtilsLabelEXT", objects_info,
                                                        true, labelInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSessionInsertDebugUtilsLabelEXT-labelInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSessionInsertDebugUtilsLabelEXT",
                                objects_info,
                                "Command xrSessionInsertDebugUtilsLabelEXT param labelInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSessionInsertDebugUtilsLabelEXT(
    XrSession session,
    const XrDebugUtilsLabelEXT* labelInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SessionInsertDebugUtilsLabelEXT(session, labelInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}


// ---- XR_MSFT_spatial_anchor extension commands
XrResult GenValidUsageInputsXrCreateSpatialAnchorMSFT(
XrSession session,
const XrSpatialAnchorCreateInfoMSFT* createInfo,
XrSpatialAnchorMSFT* anchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorCreateInfoMSFT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialAnchorMSFT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorMSFT",
                                objects_info,
                                "Command xrCreateSpatialAnchorMSFT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == anchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorMSFT-anchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorMSFT \"anchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorMSFT(
    XrSession session,
    const XrSpatialAnchorCreateInfoMSFT* createInfo,
    XrSpatialAnchorMSFT* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorMSFT(session, createInfo, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spatialanchormsft_info.insert(*anchor, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorMSFT(
    XrSession session,
    const XrSpatialAnchorCreateInfoMSFT* createInfo,
    XrSpatialAnchorMSFT* anchor) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorMSFT(session, createInfo, anchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorMSFT(session, createInfo, anchor);
}

XrResult GenValidUsageInputsXrCreateSpatialAnchorSpaceMSFT(
XrSession session,
const XrSpatialAnchorSpaceCreateInfoMSFT* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorSpaceMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorSpaceMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorSpaceMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorSpaceCreateInfoMSFT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorSpaceCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialAnchorSpaceMSFT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorSpaceMSFT",
                                objects_info,
                                "Command xrCreateSpatialAnchorSpaceMSFT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorSpaceMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorSpaceMSFT", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorSpaceMSFT(
    XrSession session,
    const XrSpatialAnchorSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorSpaceMSFT(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorSpaceMSFT(
    XrSession session,
    const XrSpatialAnchorSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorSpaceMSFT(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorSpaceMSFT(session, createInfo, space);
}

XrResult GenValidUsageInputsXrDestroySpatialAnchorMSFT(
XrSpatialAnchorMSFT anchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(anchor, XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorMSFTHandle(&anchor);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorMSFT handle \"anchor\" ";
                oss << HandleToHexString(anchor);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySpatialAnchorMSFT-anchor-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchormsft_info.getWithInstanceInfo(anchor);
        GenValidUsageXrHandleInfo *gen_spatialanchormsft_info = info_with_instance.first;
        (void)gen_spatialanchormsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySpatialAnchorMSFT(
    XrSpatialAnchorMSFT anchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchormsft_info.getWithInstanceInfo(anchor);
        GenValidUsageXrHandleInfo *gen_spatialanchormsft_info = info_with_instance.first;
        (void)gen_spatialanchormsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySpatialAnchorMSFT(anchor);
        if (XR_SUCCEEDED(result)) {
            g_spatialanchormsft_info.erase(anchor);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySpatialAnchorMSFT(
    XrSpatialAnchorMSFT anchor) {
    XrResult test_result = GenValidUsageInputsXrDestroySpatialAnchorMSFT(anchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySpatialAnchorMSFT(anchor);
}


// ---- XR_EXT_conformance_automation extension commands
XrResult GenValidUsageInputsXrSetInputDeviceActiveEXT(
XrSession session,
XrPath interactionProfile,
XrPath topLevelPath,
XrBool32 isActive) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetInputDeviceActiveEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceActiveEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetInputDeviceActiveEXT(
    XrSession session,
    XrPath interactionProfile,
    XrPath topLevelPath,
    XrBool32 isActive) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetInputDeviceActiveEXT(
    XrSession session,
    XrPath interactionProfile,
    XrPath topLevelPath,
    XrBool32 isActive) {
    XrResult test_result = GenValidUsageInputsXrSetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
}

XrResult GenValidUsageInputsXrSetInputDeviceStateBoolEXT(
XrSession session,
XrPath topLevelPath,
XrPath inputSourcePath,
XrBool32 state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetInputDeviceStateBoolEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceStateBoolEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetInputDeviceStateBoolEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrBool32 state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetInputDeviceStateBoolEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrBool32 state) {
    XrResult test_result = GenValidUsageInputsXrSetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
}

XrResult GenValidUsageInputsXrSetInputDeviceStateFloatEXT(
XrSession session,
XrPath topLevelPath,
XrPath inputSourcePath,
float state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetInputDeviceStateFloatEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceStateFloatEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetInputDeviceStateFloatEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    float state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetInputDeviceStateFloatEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    float state) {
    XrResult test_result = GenValidUsageInputsXrSetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
}

XrResult GenValidUsageInputsXrSetInputDeviceStateVector2fEXT(
XrSession session,
XrPath topLevelPath,
XrPath inputSourcePath,
XrVector2f state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetInputDeviceStateVector2fEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceStateVector2fEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetInputDeviceStateVector2fEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrVector2f state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetInputDeviceStateVector2fEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrVector2f state) {
    XrResult test_result = GenValidUsageInputsXrSetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
}

XrResult GenValidUsageInputsXrSetInputDeviceLocationEXT(
XrSession session,
XrPath topLevelPath,
XrPath inputSourcePath,
XrSpace space,
XrPosef pose) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetInputDeviceLocationEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceLocationEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrSetInputDeviceLocationEXT-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceLocationEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetInputDeviceLocationEXT-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetInputDeviceLocationEXT",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetInputDeviceLocationEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrSpace space,
    XrPosef pose) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetInputDeviceLocationEXT(
    XrSession session,
    XrPath topLevelPath,
    XrPath inputSourcePath,
    XrSpace space,
    XrPosef pose) {
    XrResult test_result = GenValidUsageInputsXrSetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
}


// ---- XR_MSFT_spatial_graph_bridge extension commands
XrResult GenValidUsageInputsXrCreateSpatialGraphNodeSpaceMSFT(
XrSession session,
const XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialGraphNodeSpaceMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialGraphNodeSpaceMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialGraphNodeSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialGraphNodeSpaceMSFT", objects_info,
                                "Invalid NULL for XrSpatialGraphNodeSpaceCreateInfoMSFT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialGraphNodeSpaceCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialGraphNodeSpaceMSFT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialGraphNodeSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialGraphNodeSpaceMSFT",
                                objects_info,
                                "Command xrCreateSpatialGraphNodeSpaceMSFT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialGraphNodeSpaceMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialGraphNodeSpaceMSFT", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialGraphNodeSpaceMSFT(
    XrSession session,
    const XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialGraphNodeSpaceMSFT(
    XrSession session,
    const XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
}

XrResult GenValidUsageInputsXrTryCreateSpatialGraphStaticNodeBindingMSFT(
XrSession session,
const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo,
XrSpatialGraphNodeBindingMSFT* nodeBinding) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrTryCreateSpatialGraphStaticNodeBindingMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryCreateSpatialGraphStaticNodeBindingMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTryCreateSpatialGraphStaticNodeBindingMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryCreateSpatialGraphStaticNodeBindingMSFT", objects_info,
                                "Invalid NULL for XrSpatialGraphStaticNodeBindingCreateInfoMSFT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialGraphStaticNodeBindingCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrTryCreateSpatialGraphStaticNodeBindingMSFT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTryCreateSpatialGraphStaticNodeBindingMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryCreateSpatialGraphStaticNodeBindingMSFT",
                                objects_info,
                                "Command xrTryCreateSpatialGraphStaticNodeBindingMSFT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == nodeBinding) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTryCreateSpatialGraphStaticNodeBindingMSFT-nodeBinding-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryCreateSpatialGraphStaticNodeBindingMSFT", objects_info,
                                "Invalid NULL for XrSpatialGraphNodeBindingMSFT \"nodeBinding\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTryCreateSpatialGraphStaticNodeBindingMSFT(
    XrSession session,
    const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo,
    XrSpatialGraphNodeBindingMSFT* nodeBinding) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
        if (XR_SUCCESS == result && nullptr != nodeBinding) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spatialgraphnodebindingmsft_info.insert(*nodeBinding, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTryCreateSpatialGraphStaticNodeBindingMSFT(
    XrSession session,
    const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo,
    XrSpatialGraphNodeBindingMSFT* nodeBinding) {
    XrResult test_result = GenValidUsageInputsXrTryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
}

XrResult GenValidUsageInputsXrDestroySpatialGraphNodeBindingMSFT(
XrSpatialGraphNodeBindingMSFT nodeBinding) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(nodeBinding, XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialGraphNodeBindingMSFTHandle(&nodeBinding);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialGraphNodeBindingMSFT handle \"nodeBinding\" ";
                oss << HandleToHexString(nodeBinding);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySpatialGraphNodeBindingMSFT-nodeBinding-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySpatialGraphNodeBindingMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialgraphnodebindingmsft_info.getWithInstanceInfo(nodeBinding);
        GenValidUsageXrHandleInfo *gen_spatialgraphnodebindingmsft_info = info_with_instance.first;
        (void)gen_spatialgraphnodebindingmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySpatialGraphNodeBindingMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialgraphnodebindingmsft_info.getWithInstanceInfo(nodeBinding);
        GenValidUsageXrHandleInfo *gen_spatialgraphnodebindingmsft_info = info_with_instance.first;
        (void)gen_spatialgraphnodebindingmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySpatialGraphNodeBindingMSFT(nodeBinding);
        if (XR_SUCCEEDED(result)) {
            g_spatialgraphnodebindingmsft_info.erase(nodeBinding);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySpatialGraphNodeBindingMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding) {
    XrResult test_result = GenValidUsageInputsXrDestroySpatialGraphNodeBindingMSFT(nodeBinding);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySpatialGraphNodeBindingMSFT(nodeBinding);
}

XrResult GenValidUsageInputsXrGetSpatialGraphNodeBindingPropertiesMSFT(
XrSpatialGraphNodeBindingMSFT nodeBinding,
const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo,
XrSpatialGraphNodeBindingPropertiesMSFT* properties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(nodeBinding, XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialGraphNodeBindingMSFTHandle(&nodeBinding);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialGraphNodeBindingMSFT handle \"nodeBinding\" ";
                oss << HandleToHexString(nodeBinding);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpatialGraphNodeBindingPropertiesMSFT-nodeBinding-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialGraphNodeBindingPropertiesMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialgraphnodebindingmsft_info.getWithInstanceInfo(nodeBinding);
        GenValidUsageXrHandleInfo *gen_spatialgraphnodebindingmsft_info = info_with_instance.first;
        (void)gen_spatialgraphnodebindingmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrSpatialGraphNodeBindingPropertiesGetInfoMSFT is valid
        if (nullptr != getInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpatialGraphNodeBindingPropertiesMSFT",
                                                            objects_info, false, getInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpatialGraphNodeBindingPropertiesMSFT-getInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialGraphNodeBindingPropertiesMSFT",
                                    objects_info,
                                    "Command xrGetSpatialGraphNodeBindingPropertiesMSFT param getInfo is invalid");
                return xr_result;
            }
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == properties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpatialGraphNodeBindingPropertiesMSFT-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialGraphNodeBindingPropertiesMSFT", objects_info,
                                "Invalid NULL for XrSpatialGraphNodeBindingPropertiesMSFT \"properties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialGraphNodeBindingPropertiesMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpatialGraphNodeBindingPropertiesMSFT", objects_info,
                                                        false, properties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpatialGraphNodeBindingPropertiesMSFT-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialGraphNodeBindingPropertiesMSFT",
                                objects_info,
                                "Command xrGetSpatialGraphNodeBindingPropertiesMSFT param properties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpatialGraphNodeBindingPropertiesMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding,
    const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo,
    XrSpatialGraphNodeBindingPropertiesMSFT* properties) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialgraphnodebindingmsft_info.getWithInstanceInfo(nodeBinding);
        GenValidUsageXrHandleInfo *gen_spatialgraphnodebindingmsft_info = info_with_instance.first;
        (void)gen_spatialgraphnodebindingmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpatialGraphNodeBindingPropertiesMSFT(
    XrSpatialGraphNodeBindingMSFT nodeBinding,
    const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo,
    XrSpatialGraphNodeBindingPropertiesMSFT* properties) {
    XrResult test_result = GenValidUsageInputsXrGetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
}


// ---- XR_EXT_hand_tracking extension commands
XrResult GenValidUsageInputsXrCreateHandTrackerEXT(
XrSession session,
const XrHandTrackerCreateInfoEXT* createInfo,
XrHandTrackerEXT* handTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateHandTrackerEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandTrackerEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandTrackerEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandTrackerEXT", objects_info,
                                "Invalid NULL for XrHandTrackerCreateInfoEXT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandTrackerCreateInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateHandTrackerEXT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandTrackerEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandTrackerEXT",
                                objects_info,
                                "Command xrCreateHandTrackerEXT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == handTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandTrackerEXT-handTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandTrackerEXT", objects_info,
                                "Invalid NULL for XrHandTrackerEXT \"handTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateHandTrackerEXT(
    XrSession session,
    const XrHandTrackerCreateInfoEXT* createInfo,
    XrHandTrackerEXT* handTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateHandTrackerEXT(session, createInfo, handTracker);
        if (XR_SUCCESS == result && nullptr != handTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_handtrackerext_info.insert(*handTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateHandTrackerEXT(
    XrSession session,
    const XrHandTrackerCreateInfoEXT* createInfo,
    XrHandTrackerEXT* handTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateHandTrackerEXT(session, createInfo, handTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateHandTrackerEXT(session, createInfo, handTracker);
}

XrResult GenValidUsageInputsXrDestroyHandTrackerEXT(
XrHandTrackerEXT handTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyHandTrackerEXT-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyHandTrackerEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyHandTrackerEXT(
    XrHandTrackerEXT handTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyHandTrackerEXT(handTracker);
        if (XR_SUCCEEDED(result)) {
            g_handtrackerext_info.erase(handTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyHandTrackerEXT(
    XrHandTrackerEXT handTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyHandTrackerEXT(handTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyHandTrackerEXT(handTracker);
}

XrResult GenValidUsageInputsXrLocateHandJointsEXT(
XrHandTrackerEXT handTracker,
const XrHandJointsLocateInfoEXT* locateInfo,
XrHandJointLocationsEXT* locations) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrLocateHandJointsEXT-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateHandJointsEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateHandJointsEXT-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateHandJointsEXT", objects_info,
                                "Invalid NULL for XrHandJointsLocateInfoEXT \"locateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandJointsLocateInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateHandJointsEXT", objects_info,
                                                        true, locateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateHandJointsEXT-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateHandJointsEXT",
                                objects_info,
                                "Command xrLocateHandJointsEXT param locateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locations) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateHandJointsEXT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateHandJointsEXT", objects_info,
                                "Invalid NULL for XrHandJointLocationsEXT \"locations\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandJointLocationsEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateHandJointsEXT", objects_info,
                                                        false, locations);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateHandJointsEXT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateHandJointsEXT",
                                objects_info,
                                "Command xrLocateHandJointsEXT param locations is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLocateHandJointsEXT(
    XrHandTrackerEXT handTracker,
    const XrHandJointsLocateInfoEXT* locateInfo,
    XrHandJointLocationsEXT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LocateHandJointsEXT(handTracker, locateInfo, locations);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLocateHandJointsEXT(
    XrHandTrackerEXT handTracker,
    const XrHandJointsLocateInfoEXT* locateInfo,
    XrHandJointLocationsEXT* locations) {
    XrResult test_result = GenValidUsageInputsXrLocateHandJointsEXT(handTracker, locateInfo, locations);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLocateHandJointsEXT(handTracker, locateInfo, locations);
}


// ---- XR_MSFT_hand_tracking_mesh extension commands
XrResult GenValidUsageInputsXrCreateHandMeshSpaceMSFT(
XrHandTrackerEXT handTracker,
const XrHandMeshSpaceCreateInfoMSFT* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrCreateHandMeshSpaceMSFT-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandMeshSpaceMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandMeshSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandMeshSpaceMSFT", objects_info,
                                "Invalid NULL for XrHandMeshSpaceCreateInfoMSFT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandMeshSpaceCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateHandMeshSpaceMSFT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandMeshSpaceMSFT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandMeshSpaceMSFT",
                                objects_info,
                                "Command xrCreateHandMeshSpaceMSFT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateHandMeshSpaceMSFT-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateHandMeshSpaceMSFT", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateHandMeshSpaceMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateHandMeshSpaceMSFT(handTracker, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_HAND_TRACKER_EXT;
            handle_info->direct_parent_handle = MakeHandleGeneric(handTracker);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateHandMeshSpaceMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshSpaceCreateInfoMSFT* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateHandMeshSpaceMSFT(handTracker, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateHandMeshSpaceMSFT(handTracker, createInfo, space);
}

XrResult GenValidUsageInputsXrUpdateHandMeshMSFT(
XrHandTrackerEXT handTracker,
const XrHandMeshUpdateInfoMSFT* updateInfo,
XrHandMeshMSFT* handMesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrUpdateHandMeshMSFT-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateHandMeshMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == updateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateHandMeshMSFT-updateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateHandMeshMSFT", objects_info,
                                "Invalid NULL for XrHandMeshUpdateInfoMSFT \"updateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandMeshUpdateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateHandMeshMSFT", objects_info,
                                                        true, updateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateHandMeshMSFT-updateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateHandMeshMSFT",
                                objects_info,
                                "Command xrUpdateHandMeshMSFT param updateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == handMesh) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateHandMeshMSFT-handMesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateHandMeshMSFT", objects_info,
                                "Invalid NULL for XrHandMeshMSFT \"handMesh\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandMeshMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateHandMeshMSFT", objects_info,
                                                        false, handMesh);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateHandMeshMSFT-handMesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateHandMeshMSFT",
                                objects_info,
                                "Command xrUpdateHandMeshMSFT param handMesh is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrUpdateHandMeshMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshUpdateInfoMSFT* updateInfo,
    XrHandMeshMSFT* handMesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->UpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrUpdateHandMeshMSFT(
    XrHandTrackerEXT handTracker,
    const XrHandMeshUpdateInfoMSFT* updateInfo,
    XrHandMeshMSFT* handMesh) {
    XrResult test_result = GenValidUsageInputsXrUpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrUpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
}


// ---- XR_MSFT_controller_model extension commands
XrResult GenValidUsageInputsXrGetControllerModelKeyMSFT(
XrSession session,
XrPath topLevelUserPath,
XrControllerModelKeyStateMSFT* controllerModelKeyState) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetControllerModelKeyMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelKeyMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == controllerModelKeyState) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelKeyMSFT-controllerModelKeyState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelKeyMSFT", objects_info,
                                "Invalid NULL for XrControllerModelKeyStateMSFT \"controllerModelKeyState\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrControllerModelKeyStateMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetControllerModelKeyMSFT", objects_info,
                                                        false, controllerModelKeyState);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelKeyMSFT-controllerModelKeyState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelKeyMSFT",
                                objects_info,
                                "Command xrGetControllerModelKeyMSFT param controllerModelKeyState is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetControllerModelKeyMSFT(
    XrSession session,
    XrPath topLevelUserPath,
    XrControllerModelKeyStateMSFT* controllerModelKeyState) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetControllerModelKeyMSFT(
    XrSession session,
    XrPath topLevelUserPath,
    XrControllerModelKeyStateMSFT* controllerModelKeyState) {
    XrResult test_result = GenValidUsageInputsXrGetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
}

XrResult GenValidUsageInputsXrLoadControllerModelMSFT(
XrSession session,
XrControllerModelKeyMSFT modelKey,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
uint8_t* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrLoadControllerModelMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadControllerModelMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadControllerModelMSFT-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadControllerModelMSFT",
                                objects_info,
                                "Command xrLoadControllerModelMSFT param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadControllerModelMSFT-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadControllerModelMSFT", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrLoadControllerModelMSFT-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrLoadControllerModelMSFT-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLoadControllerModelMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLoadControllerModelMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult test_result = GenValidUsageInputsXrLoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
}

XrResult GenValidUsageInputsXrGetControllerModelPropertiesMSFT(
XrSession session,
XrControllerModelKeyMSFT modelKey,
XrControllerModelPropertiesMSFT* properties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetControllerModelPropertiesMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelPropertiesMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == properties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelPropertiesMSFT-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelPropertiesMSFT", objects_info,
                                "Invalid NULL for XrControllerModelPropertiesMSFT \"properties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrControllerModelPropertiesMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetControllerModelPropertiesMSFT", objects_info,
                                                        false, properties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelPropertiesMSFT-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelPropertiesMSFT",
                                objects_info,
                                "Command xrGetControllerModelPropertiesMSFT param properties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetControllerModelPropertiesMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelPropertiesMSFT* properties) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetControllerModelPropertiesMSFT(session, modelKey, properties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetControllerModelPropertiesMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelPropertiesMSFT* properties) {
    XrResult test_result = GenValidUsageInputsXrGetControllerModelPropertiesMSFT(session, modelKey, properties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetControllerModelPropertiesMSFT(session, modelKey, properties);
}

XrResult GenValidUsageInputsXrGetControllerModelStateMSFT(
XrSession session,
XrControllerModelKeyMSFT modelKey,
XrControllerModelStateMSFT* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetControllerModelStateMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelStateMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelStateMSFT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelStateMSFT", objects_info,
                                "Invalid NULL for XrControllerModelStateMSFT \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrControllerModelStateMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetControllerModelStateMSFT", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetControllerModelStateMSFT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetControllerModelStateMSFT",
                                objects_info,
                                "Command xrGetControllerModelStateMSFT param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetControllerModelStateMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelStateMSFT* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetControllerModelStateMSFT(session, modelKey, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetControllerModelStateMSFT(
    XrSession session,
    XrControllerModelKeyMSFT modelKey,
    XrControllerModelStateMSFT* state) {
    XrResult test_result = GenValidUsageInputsXrGetControllerModelStateMSFT(session, modelKey, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetControllerModelStateMSFT(session, modelKey, state);
}


// ---- XR_MSFT_perception_anchor_interop extension commands
#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrCreateSpatialAnchorFromPerceptionAnchorMSFT(
XrSession session,
IUnknown* perceptionAnchor,
XrSpatialAnchorMSFT* anchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorFromPerceptionAnchorMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPerceptionAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == perceptionAnchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFromPerceptionAnchorMSFT-perceptionAnchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPerceptionAnchorMSFT", objects_info,
                                "Invalid NULL for IUnknown \"perceptionAnchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateSpatialAnchorFromPerceptionAnchorMSFT-perceptionAnchor-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == anchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFromPerceptionAnchorMSFT-anchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPerceptionAnchorMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorMSFT \"anchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorFromPerceptionAnchorMSFT(
    XrSession session,
    IUnknown* perceptionAnchor,
    XrSpatialAnchorMSFT* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spatialanchormsft_info.insert(*anchor, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorFromPerceptionAnchorMSFT(
    XrSession session,
    IUnknown* perceptionAnchor,
    XrSpatialAnchorMSFT* anchor) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
}

#endif // defined(XR_USE_PLATFORM_WIN32)

#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(
XrSession session,
XrSpatialAnchorMSFT anchor,
IUnknown** perceptionAnchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrTryGetPerceptionAnchorFromSpatialAnchorMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(anchor, XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorMSFTHandle(&anchor);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorMSFT handle \"anchor\" ";
                oss << HandleToHexString(anchor);
                CoreValidLogMessage(gen_instance_info, "VUID-xrTryGetPerceptionAnchorFromSpatialAnchorMSFT-anchor-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT,  MakeHandleGeneric(anchor), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpatialAnchorMSFT ";
            oss_error << HandleToHexString(anchor);
            CoreValidLogMessage(gen_instance_info, "VUID-xrTryGetPerceptionAnchorFromSpatialAnchorMSFT-anchor-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == perceptionAnchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTryGetPerceptionAnchorFromSpatialAnchorMSFT-perceptionAnchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT", objects_info,
                                "Invalid NULL for IUnknown \"perceptionAnchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrTryGetPerceptionAnchorFromSpatialAnchorMSFT-perceptionAnchor-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(
    XrSession session,
    XrSpatialAnchorMSFT anchor,
    IUnknown** perceptionAnchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(
    XrSession session,
    XrSpatialAnchorMSFT anchor,
    IUnknown** perceptionAnchor) {
    XrResult test_result = GenValidUsageInputsXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
}

#endif // defined(XR_USE_PLATFORM_WIN32)


// ---- XR_MSFT_composition_layer_reprojection extension commands
XrResult GenValidUsageInputsXrEnumerateReprojectionModesMSFT(
XrInstance instance,
XrSystemId systemId,
XrViewConfigurationType viewConfigurationType,
uint32_t modeCapacityInput,
uint32_t* modeCountOutput,
XrReprojectionModeMSFT* modes) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateReprojectionModesMSFT-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReprojectionModesMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrViewConfigurationType value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrEnumerateReprojectionModesMSFT", "xrEnumerateReprojectionModesMSFT", "viewConfigurationType", objects_info, viewConfigurationType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrViewConfigurationType \"viewConfigurationType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(viewConfigurationType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateReprojectionModesMSFT-viewConfigurationType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReprojectionModesMSFT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Optional array must be non-NULL when modeCapacityInput is non-zero
        if (0 != modeCapacityInput && nullptr == modes) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateReprojectionModesMSFT-modes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReprojectionModesMSFT",
                                objects_info,
                                "Command xrEnumerateReprojectionModesMSFT param modes is NULL, but modeCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == modeCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateReprojectionModesMSFT-modeCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateReprojectionModesMSFT", objects_info,
                                "Invalid NULL for uint32_t \"modeCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateReprojectionModesMSFT-modeCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateReprojectionModesMSFT-modes-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateReprojectionModesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t modeCapacityInput,
    uint32_t* modeCountOutput,
    XrReprojectionModeMSFT* modes) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateReprojectionModesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    XrViewConfigurationType viewConfigurationType,
    uint32_t modeCapacityInput,
    uint32_t* modeCountOutput,
    XrReprojectionModeMSFT* modes) {
    XrResult test_result = GenValidUsageInputsXrEnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
}


// ---- XR_FB_swapchain_update_state extension commands
XrResult GenValidUsageInputsXrUpdateSwapchainFB(
XrSwapchain swapchain,
const XrSwapchainStateBaseHeaderFB* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrUpdateSwapchainFB-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB", objects_info,
                                "Invalid NULL for XrSwapchainStateBaseHeaderFB \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateFoveationFB and it is valid
        {
            const XrSwapchainStateFoveationFB* new_swapchainstatefoveationfb_value = reinterpret_cast<const XrSwapchainStateFoveationFB*>(state);
            if (new_swapchainstatefoveationfb_value->type == XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateSwapchainFB",
                                                                objects_info,false, new_swapchainstatefoveationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrUpdateSwapchainFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateAndroidSurfaceDimensionsFB and it is valid
        {
            const XrSwapchainStateAndroidSurfaceDimensionsFB* new_swapchainstateandroidsurfacedimensionsfb_value = reinterpret_cast<const XrSwapchainStateAndroidSurfaceDimensionsFB*>(state);
            if (new_swapchainstateandroidsurfacedimensionsfb_value->type == XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateSwapchainFB",
                                                                objects_info,false, new_swapchainstateandroidsurfacedimensionsfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrUpdateSwapchainFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateSamplerOpenGLESFB and it is valid
        {
            const XrSwapchainStateSamplerOpenGLESFB* new_swapchainstatesampleropenglesfb_value = reinterpret_cast<const XrSwapchainStateSamplerOpenGLESFB*>(state);
            if (new_swapchainstatesampleropenglesfb_value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateSwapchainFB",
                                                                objects_info,false, new_swapchainstatesampleropenglesfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrUpdateSwapchainFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateSamplerVulkanFB and it is valid
        {
            const XrSwapchainStateSamplerVulkanFB* new_swapchainstatesamplervulkanfb_value = reinterpret_cast<const XrSwapchainStateSamplerVulkanFB*>(state);
            if (new_swapchainstatesamplervulkanfb_value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateSwapchainFB",
                                                                objects_info,false, new_swapchainstatesamplervulkanfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrUpdateSwapchainFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        // Validate that the base-structure XrSwapchainStateBaseHeaderFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrUpdateSwapchainFB", objects_info,
                                                        true, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdateSwapchainFB-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdateSwapchainFB",
                                objects_info,
                                "Command xrUpdateSwapchainFB param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrUpdateSwapchainFB(
    XrSwapchain swapchain,
    const XrSwapchainStateBaseHeaderFB* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->UpdateSwapchainFB(swapchain, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrUpdateSwapchainFB(
    XrSwapchain swapchain,
    const XrSwapchainStateBaseHeaderFB* state) {
    XrResult test_result = GenValidUsageInputsXrUpdateSwapchainFB(swapchain, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrUpdateSwapchainFB(swapchain, state);
}

XrResult GenValidUsageInputsXrGetSwapchainStateFB(
XrSwapchain swapchain,
XrSwapchainStateBaseHeaderFB* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(swapchain, XR_OBJECT_TYPE_SWAPCHAIN);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSwapchainHandle(&swapchain);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSwapchain handle \"swapchain\" ";
                oss << HandleToHexString(swapchain);
                CoreValidLogMessage(nullptr, "VUID-xrGetSwapchainStateFB-swapchain-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB", objects_info,
                                "Invalid NULL for XrSwapchainStateBaseHeaderFB \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateFoveationFB and it is valid
        {
            XrSwapchainStateFoveationFB* new_swapchainstatefoveationfb_value = reinterpret_cast<XrSwapchainStateFoveationFB*>(state);
            if (new_swapchainstatefoveationfb_value->type == XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrGetSwapchainStateFB",
                                                                objects_info,false, new_swapchainstatefoveationfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrGetSwapchainStateFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#if defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateAndroidSurfaceDimensionsFB and it is valid
        {
            XrSwapchainStateAndroidSurfaceDimensionsFB* new_swapchainstateandroidsurfacedimensionsfb_value = reinterpret_cast<XrSwapchainStateAndroidSurfaceDimensionsFB*>(state);
            if (new_swapchainstateandroidsurfacedimensionsfb_value->type == XR_TYPE_SWAPCHAIN_STATE_ANDROID_SURFACE_DIMENSIONS_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrGetSwapchainStateFB",
                                                                objects_info,false, new_swapchainstateandroidsurfacedimensionsfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrGetSwapchainStateFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_PLATFORM_ANDROID) && defined(XR_USE_PLATFORM_ANDROID)
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateSamplerOpenGLESFB and it is valid
        {
            XrSwapchainStateSamplerOpenGLESFB* new_swapchainstatesampleropenglesfb_value = reinterpret_cast<XrSwapchainStateSamplerOpenGLESFB*>(state);
            if (new_swapchainstatesampleropenglesfb_value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_OPENGL_ES_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrGetSwapchainStateFB",
                                                                objects_info,false, new_swapchainstatesampleropenglesfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrGetSwapchainStateFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES) && defined(XR_USE_GRAPHICS_API_OPENGL_ES)
#if defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        // Validate if XrSwapchainStateBaseHeaderFB is a child structure of type XrSwapchainStateSamplerVulkanFB and it is valid
        {
            XrSwapchainStateSamplerVulkanFB* new_swapchainstatesamplervulkanfb_value = reinterpret_cast<XrSwapchainStateSamplerVulkanFB*>(state);
            if (new_swapchainstatesamplervulkanfb_value->type == XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrGetSwapchainStateFB",
                                                                objects_info,false, new_swapchainstatesamplervulkanfb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrGetSwapchainStateFB param state";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN) && defined(XR_USE_GRAPHICS_API_VULKAN)
        // Validate that the base-structure XrSwapchainStateBaseHeaderFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSwapchainStateFB", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSwapchainStateFB-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSwapchainStateFB",
                                objects_info,
                                "Command xrGetSwapchainStateFB param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSwapchainStateFB(
    XrSwapchain swapchain,
    XrSwapchainStateBaseHeaderFB* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_swapchain_info.getWithInstanceInfo(swapchain);
        GenValidUsageXrHandleInfo *gen_swapchain_info = info_with_instance.first;
        (void)gen_swapchain_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSwapchainStateFB(swapchain, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSwapchainStateFB(
    XrSwapchain swapchain,
    XrSwapchainStateBaseHeaderFB* state) {
    XrResult test_result = GenValidUsageInputsXrGetSwapchainStateFB(swapchain, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSwapchainStateFB(swapchain, state);
}


// ---- XR_FB_body_tracking extension commands
XrResult GenValidUsageInputsXrCreateBodyTrackerFB(
XrSession session,
const XrBodyTrackerCreateInfoFB* createInfo,
XrBodyTrackerFB* bodyTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateBodyTrackerFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateBodyTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateBodyTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateBodyTrackerFB", objects_info,
                                "Invalid NULL for XrBodyTrackerCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBodyTrackerCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateBodyTrackerFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateBodyTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateBodyTrackerFB",
                                objects_info,
                                "Command xrCreateBodyTrackerFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bodyTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateBodyTrackerFB-bodyTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateBodyTrackerFB", objects_info,
                                "Invalid NULL for XrBodyTrackerFB \"bodyTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateBodyTrackerFB(
    XrSession session,
    const XrBodyTrackerCreateInfoFB* createInfo,
    XrBodyTrackerFB* bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateBodyTrackerFB(session, createInfo, bodyTracker);
        if (XR_SUCCESS == result && nullptr != bodyTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_bodytrackerfb_info.insert(*bodyTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateBodyTrackerFB(
    XrSession session,
    const XrBodyTrackerCreateInfoFB* createInfo,
    XrBodyTrackerFB* bodyTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateBodyTrackerFB(session, createInfo, bodyTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateBodyTrackerFB(session, createInfo, bodyTracker);
}

XrResult GenValidUsageInputsXrDestroyBodyTrackerFB(
XrBodyTrackerFB bodyTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(bodyTracker, XR_OBJECT_TYPE_BODY_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrBodyTrackerFBHandle(&bodyTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrBodyTrackerFB handle \"bodyTracker\" ";
                oss << HandleToHexString(bodyTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyBodyTrackerFB-bodyTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyBodyTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyBodyTrackerFB(
    XrBodyTrackerFB bodyTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyBodyTrackerFB(bodyTracker);
        if (XR_SUCCEEDED(result)) {
            g_bodytrackerfb_info.erase(bodyTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyBodyTrackerFB(
    XrBodyTrackerFB bodyTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyBodyTrackerFB(bodyTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyBodyTrackerFB(bodyTracker);
}

XrResult GenValidUsageInputsXrLocateBodyJointsFB(
XrBodyTrackerFB bodyTracker,
const XrBodyJointsLocateInfoFB* locateInfo,
XrBodyJointLocationsFB* locations) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(bodyTracker, XR_OBJECT_TYPE_BODY_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrBodyTrackerFBHandle(&bodyTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrBodyTrackerFB handle \"bodyTracker\" ";
                oss << HandleToHexString(bodyTracker);
                CoreValidLogMessage(nullptr, "VUID-xrLocateBodyJointsFB-bodyTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateBodyJointsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateBodyJointsFB-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateBodyJointsFB", objects_info,
                                "Invalid NULL for XrBodyJointsLocateInfoFB \"locateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBodyJointsLocateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateBodyJointsFB", objects_info,
                                                        true, locateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateBodyJointsFB-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateBodyJointsFB",
                                objects_info,
                                "Command xrLocateBodyJointsFB param locateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locations) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateBodyJointsFB-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateBodyJointsFB", objects_info,
                                "Invalid NULL for XrBodyJointLocationsFB \"locations\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBodyJointLocationsFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateBodyJointsFB", objects_info,
                                                        false, locations);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateBodyJointsFB-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateBodyJointsFB",
                                objects_info,
                                "Command xrLocateBodyJointsFB param locations is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLocateBodyJointsFB(
    XrBodyTrackerFB bodyTracker,
    const XrBodyJointsLocateInfoFB* locateInfo,
    XrBodyJointLocationsFB* locations) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LocateBodyJointsFB(bodyTracker, locateInfo, locations);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLocateBodyJointsFB(
    XrBodyTrackerFB bodyTracker,
    const XrBodyJointsLocateInfoFB* locateInfo,
    XrBodyJointLocationsFB* locations) {
    XrResult test_result = GenValidUsageInputsXrLocateBodyJointsFB(bodyTracker, locateInfo, locations);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLocateBodyJointsFB(bodyTracker, locateInfo, locations);
}

XrResult GenValidUsageInputsXrGetBodySkeletonFB(
XrBodyTrackerFB bodyTracker,
XrBodySkeletonFB* skeleton) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(bodyTracker, XR_OBJECT_TYPE_BODY_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrBodyTrackerFBHandle(&bodyTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrBodyTrackerFB handle \"bodyTracker\" ";
                oss << HandleToHexString(bodyTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetBodySkeletonFB-bodyTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetBodySkeletonFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == skeleton) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetBodySkeletonFB-skeleton-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetBodySkeletonFB", objects_info,
                                "Invalid NULL for XrBodySkeletonFB \"skeleton\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBodySkeletonFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetBodySkeletonFB", objects_info,
                                                        false, skeleton);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetBodySkeletonFB-skeleton-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetBodySkeletonFB",
                                objects_info,
                                "Command xrGetBodySkeletonFB param skeleton is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetBodySkeletonFB(
    XrBodyTrackerFB bodyTracker,
    XrBodySkeletonFB* skeleton) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_bodytrackerfb_info.getWithInstanceInfo(bodyTracker);
        GenValidUsageXrHandleInfo *gen_bodytrackerfb_info = info_with_instance.first;
        (void)gen_bodytrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetBodySkeletonFB(bodyTracker, skeleton);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetBodySkeletonFB(
    XrBodyTrackerFB bodyTracker,
    XrBodySkeletonFB* skeleton) {
    XrResult test_result = GenValidUsageInputsXrGetBodySkeletonFB(bodyTracker, skeleton);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetBodySkeletonFB(bodyTracker, skeleton);
}


// ---- XR_MSFT_scene_understanding extension commands
XrResult GenValidUsageInputsXrEnumerateSceneComputeFeaturesMSFT(
XrInstance instance,
XrSystemId systemId,
uint32_t featureCapacityInput,
uint32_t* featureCountOutput,
XrSceneComputeFeatureMSFT* features) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateSceneComputeFeaturesMSFT-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSceneComputeFeaturesMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when featureCapacityInput is non-zero
        if (0 != featureCapacityInput && nullptr == features) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSceneComputeFeaturesMSFT-features-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSceneComputeFeaturesMSFT",
                                objects_info,
                                "Command xrEnumerateSceneComputeFeaturesMSFT param features is NULL, but featureCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == featureCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSceneComputeFeaturesMSFT-featureCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSceneComputeFeaturesMSFT", objects_info,
                                "Invalid NULL for uint32_t \"featureCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateSceneComputeFeaturesMSFT-featureCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateSceneComputeFeaturesMSFT-features-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateSceneComputeFeaturesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t featureCapacityInput,
    uint32_t* featureCountOutput,
    XrSceneComputeFeatureMSFT* features) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateSceneComputeFeaturesMSFT(
    XrInstance instance,
    XrSystemId systemId,
    uint32_t featureCapacityInput,
    uint32_t* featureCountOutput,
    XrSceneComputeFeatureMSFT* features) {
    XrResult test_result = GenValidUsageInputsXrEnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
}

XrResult GenValidUsageInputsXrCreateSceneObserverMSFT(
XrSession session,
const XrSceneObserverCreateInfoMSFT* createInfo,
XrSceneObserverMSFT* sceneObserver) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSceneObserverMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneObserverMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrSceneObserverCreateInfoMSFT is valid
        if (nullptr != createInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSceneObserverMSFT",
                                                            objects_info, false, createInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSceneObserverMSFT-createInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneObserverMSFT",
                                    objects_info,
                                    "Command xrCreateSceneObserverMSFT param createInfo is invalid");
                return xr_result;
            }
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == sceneObserver) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSceneObserverMSFT-sceneObserver-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneObserverMSFT", objects_info,
                                "Invalid NULL for XrSceneObserverMSFT \"sceneObserver\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSceneObserverMSFT(
    XrSession session,
    const XrSceneObserverCreateInfoMSFT* createInfo,
    XrSceneObserverMSFT* sceneObserver) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSceneObserverMSFT(session, createInfo, sceneObserver);
        if (XR_SUCCESS == result && nullptr != sceneObserver) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_sceneobservermsft_info.insert(*sceneObserver, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSceneObserverMSFT(
    XrSession session,
    const XrSceneObserverCreateInfoMSFT* createInfo,
    XrSceneObserverMSFT* sceneObserver) {
    XrResult test_result = GenValidUsageInputsXrCreateSceneObserverMSFT(session, createInfo, sceneObserver);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSceneObserverMSFT(session, createInfo, sceneObserver);
}

XrResult GenValidUsageInputsXrDestroySceneObserverMSFT(
XrSceneObserverMSFT sceneObserver) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(sceneObserver, XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneObserverMSFTHandle(&sceneObserver);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneObserverMSFT handle \"sceneObserver\" ";
                oss << HandleToHexString(sceneObserver);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySceneObserverMSFT-sceneObserver-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySceneObserverMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySceneObserverMSFT(
    XrSceneObserverMSFT sceneObserver) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySceneObserverMSFT(sceneObserver);
        if (XR_SUCCEEDED(result)) {
            g_sceneobservermsft_info.erase(sceneObserver);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySceneObserverMSFT(
    XrSceneObserverMSFT sceneObserver) {
    XrResult test_result = GenValidUsageInputsXrDestroySceneObserverMSFT(sceneObserver);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySceneObserverMSFT(sceneObserver);
}

XrResult GenValidUsageInputsXrCreateSceneMSFT(
XrSceneObserverMSFT sceneObserver,
const XrSceneCreateInfoMSFT* createInfo,
XrSceneMSFT* scene) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(sceneObserver, XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneObserverMSFTHandle(&sceneObserver);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneObserverMSFT handle \"sceneObserver\" ";
                oss << HandleToHexString(sceneObserver);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSceneMSFT-sceneObserver-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the structure XrSceneCreateInfoMSFT is valid
        if (nullptr != createInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSceneMSFT",
                                                            objects_info, false, createInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSceneMSFT-createInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneMSFT",
                                    objects_info,
                                    "Command xrCreateSceneMSFT param createInfo is invalid");
                return xr_result;
            }
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == scene) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSceneMSFT-scene-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSceneMSFT", objects_info,
                                "Invalid NULL for XrSceneMSFT \"scene\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneCreateInfoMSFT* createInfo,
    XrSceneMSFT* scene) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSceneMSFT(sceneObserver, createInfo, scene);
        if (XR_SUCCESS == result && nullptr != scene) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT;
            handle_info->direct_parent_handle = MakeHandleGeneric(sceneObserver);
            g_scenemsft_info.insert(*scene, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneCreateInfoMSFT* createInfo,
    XrSceneMSFT* scene) {
    XrResult test_result = GenValidUsageInputsXrCreateSceneMSFT(sceneObserver, createInfo, scene);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSceneMSFT(sceneObserver, createInfo, scene);
}

XrResult GenValidUsageInputsXrDestroySceneMSFT(
XrSceneMSFT scene) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySceneMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySceneMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySceneMSFT(
    XrSceneMSFT scene) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySceneMSFT(scene);
        if (XR_SUCCEEDED(result)) {
            g_scenemsft_info.erase(scene);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySceneMSFT(
    XrSceneMSFT scene) {
    XrResult test_result = GenValidUsageInputsXrDestroySceneMSFT(scene);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySceneMSFT(scene);
}

XrResult GenValidUsageInputsXrComputeNewSceneMSFT(
XrSceneObserverMSFT sceneObserver,
const XrNewSceneComputeInfoMSFT* computeInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(sceneObserver, XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneObserverMSFTHandle(&sceneObserver);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneObserverMSFT handle \"sceneObserver\" ";
                oss << HandleToHexString(sceneObserver);
                CoreValidLogMessage(nullptr, "VUID-xrComputeNewSceneMSFT-sceneObserver-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrComputeNewSceneMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == computeInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrComputeNewSceneMSFT-computeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrComputeNewSceneMSFT", objects_info,
                                "Invalid NULL for XrNewSceneComputeInfoMSFT \"computeInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrNewSceneComputeInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrComputeNewSceneMSFT", objects_info,
                                                        true, computeInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrComputeNewSceneMSFT-computeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrComputeNewSceneMSFT",
                                objects_info,
                                "Command xrComputeNewSceneMSFT param computeInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrComputeNewSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrNewSceneComputeInfoMSFT* computeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ComputeNewSceneMSFT(sceneObserver, computeInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrComputeNewSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrNewSceneComputeInfoMSFT* computeInfo) {
    XrResult test_result = GenValidUsageInputsXrComputeNewSceneMSFT(sceneObserver, computeInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrComputeNewSceneMSFT(sceneObserver, computeInfo);
}

XrResult GenValidUsageInputsXrGetSceneComputeStateMSFT(
XrSceneObserverMSFT sceneObserver,
XrSceneComputeStateMSFT* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(sceneObserver, XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneObserverMSFTHandle(&sceneObserver);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneObserverMSFT handle \"sceneObserver\" ";
                oss << HandleToHexString(sceneObserver);
                CoreValidLogMessage(nullptr, "VUID-xrGetSceneComputeStateMSFT-sceneObserver-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComputeStateMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComputeStateMSFT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComputeStateMSFT", objects_info,
                                "Invalid NULL for XrSceneComputeStateMSFT \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrSceneComputeStateMSFT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetSceneComputeStateMSFT", "xrGetSceneComputeStateMSFT", "state", objects_info, *state)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrSceneComputeStateMSFT \"state\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(*state));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComputeStateMSFT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComputeStateMSFT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSceneComputeStateMSFT(
    XrSceneObserverMSFT sceneObserver,
    XrSceneComputeStateMSFT* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSceneComputeStateMSFT(sceneObserver, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSceneComputeStateMSFT(
    XrSceneObserverMSFT sceneObserver,
    XrSceneComputeStateMSFT* state) {
    XrResult test_result = GenValidUsageInputsXrGetSceneComputeStateMSFT(sceneObserver, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSceneComputeStateMSFT(sceneObserver, state);
}

XrResult GenValidUsageInputsXrGetSceneComponentsMSFT(
XrSceneMSFT scene,
const XrSceneComponentsGetInfoMSFT* getInfo,
XrSceneComponentsMSFT* components) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrGetSceneComponentsMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComponentsMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComponentsMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComponentsMSFT", objects_info,
                                "Invalid NULL for XrSceneComponentsGetInfoMSFT \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneComponentsGetInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSceneComponentsMSFT", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComponentsMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComponentsMSFT",
                                objects_info,
                                "Command xrGetSceneComponentsMSFT param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == components) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComponentsMSFT-components-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComponentsMSFT", objects_info,
                                "Invalid NULL for XrSceneComponentsMSFT \"components\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneComponentsMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSceneComponentsMSFT", objects_info,
                                                        false, components);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneComponentsMSFT-components-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneComponentsMSFT",
                                objects_info,
                                "Command xrGetSceneComponentsMSFT param components is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsGetInfoMSFT* getInfo,
    XrSceneComponentsMSFT* components) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSceneComponentsMSFT(scene, getInfo, components);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsGetInfoMSFT* getInfo,
    XrSceneComponentsMSFT* components) {
    XrResult test_result = GenValidUsageInputsXrGetSceneComponentsMSFT(scene, getInfo, components);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSceneComponentsMSFT(scene, getInfo, components);
}

XrResult GenValidUsageInputsXrLocateSceneComponentsMSFT(
XrSceneMSFT scene,
const XrSceneComponentsLocateInfoMSFT* locateInfo,
XrSceneComponentLocationsMSFT* locations) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrLocateSceneComponentsMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSceneComponentsMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSceneComponentsMSFT-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSceneComponentsMSFT", objects_info,
                                "Invalid NULL for XrSceneComponentsLocateInfoMSFT \"locateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneComponentsLocateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateSceneComponentsMSFT", objects_info,
                                                        true, locateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSceneComponentsMSFT-locateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSceneComponentsMSFT",
                                objects_info,
                                "Command xrLocateSceneComponentsMSFT param locateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locations) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSceneComponentsMSFT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSceneComponentsMSFT", objects_info,
                                "Invalid NULL for XrSceneComponentLocationsMSFT \"locations\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneComponentLocationsMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLocateSceneComponentsMSFT", objects_info,
                                                        false, locations);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLocateSceneComponentsMSFT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLocateSceneComponentsMSFT",
                                objects_info,
                                "Command xrLocateSceneComponentsMSFT param locations is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLocateSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsLocateInfoMSFT* locateInfo,
    XrSceneComponentLocationsMSFT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LocateSceneComponentsMSFT(scene, locateInfo, locations);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLocateSceneComponentsMSFT(
    XrSceneMSFT scene,
    const XrSceneComponentsLocateInfoMSFT* locateInfo,
    XrSceneComponentLocationsMSFT* locations) {
    XrResult test_result = GenValidUsageInputsXrLocateSceneComponentsMSFT(scene, locateInfo, locations);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLocateSceneComponentsMSFT(scene, locateInfo, locations);
}

XrResult GenValidUsageInputsXrGetSceneMeshBuffersMSFT(
XrSceneMSFT scene,
const XrSceneMeshBuffersGetInfoMSFT* getInfo,
XrSceneMeshBuffersMSFT* buffers) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrGetSceneMeshBuffersMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMeshBuffersMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMeshBuffersMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMeshBuffersMSFT", objects_info,
                                "Invalid NULL for XrSceneMeshBuffersGetInfoMSFT \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneMeshBuffersGetInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSceneMeshBuffersMSFT", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMeshBuffersMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMeshBuffersMSFT",
                                objects_info,
                                "Command xrGetSceneMeshBuffersMSFT param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == buffers) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMeshBuffersMSFT-buffers-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMeshBuffersMSFT", objects_info,
                                "Invalid NULL for XrSceneMeshBuffersMSFT \"buffers\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneMeshBuffersMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSceneMeshBuffersMSFT", objects_info,
                                                        false, buffers);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMeshBuffersMSFT-buffers-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMeshBuffersMSFT",
                                objects_info,
                                "Command xrGetSceneMeshBuffersMSFT param buffers is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSceneMeshBuffersMSFT(
    XrSceneMSFT scene,
    const XrSceneMeshBuffersGetInfoMSFT* getInfo,
    XrSceneMeshBuffersMSFT* buffers) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSceneMeshBuffersMSFT(
    XrSceneMSFT scene,
    const XrSceneMeshBuffersGetInfoMSFT* getInfo,
    XrSceneMeshBuffersMSFT* buffers) {
    XrResult test_result = GenValidUsageInputsXrGetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSceneMeshBuffersMSFT(scene, getInfo, buffers);
}


// ---- XR_MSFT_scene_understanding_serialization extension commands
XrResult GenValidUsageInputsXrDeserializeSceneMSFT(
XrSceneObserverMSFT sceneObserver,
const XrSceneDeserializeInfoMSFT* deserializeInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(sceneObserver, XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneObserverMSFTHandle(&sceneObserver);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneObserverMSFT handle \"sceneObserver\" ";
                oss << HandleToHexString(sceneObserver);
                CoreValidLogMessage(nullptr, "VUID-xrDeserializeSceneMSFT-sceneObserver-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDeserializeSceneMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == deserializeInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrDeserializeSceneMSFT-deserializeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDeserializeSceneMSFT", objects_info,
                                "Invalid NULL for XrSceneDeserializeInfoMSFT \"deserializeInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneDeserializeInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrDeserializeSceneMSFT", objects_info,
                                                        true, deserializeInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrDeserializeSceneMSFT-deserializeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDeserializeSceneMSFT",
                                objects_info,
                                "Command xrDeserializeSceneMSFT param deserializeInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDeserializeSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneDeserializeInfoMSFT* deserializeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_sceneobservermsft_info.getWithInstanceInfo(sceneObserver);
        GenValidUsageXrHandleInfo *gen_sceneobservermsft_info = info_with_instance.first;
        (void)gen_sceneobservermsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DeserializeSceneMSFT(sceneObserver, deserializeInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDeserializeSceneMSFT(
    XrSceneObserverMSFT sceneObserver,
    const XrSceneDeserializeInfoMSFT* deserializeInfo) {
    XrResult test_result = GenValidUsageInputsXrDeserializeSceneMSFT(sceneObserver, deserializeInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDeserializeSceneMSFT(sceneObserver, deserializeInfo);
}

XrResult GenValidUsageInputsXrGetSerializedSceneFragmentDataMSFT(
XrSceneMSFT scene,
const XrSerializedSceneFragmentDataGetInfoMSFT* getInfo,
uint32_t countInput,
uint32_t* readOutput,
uint8_t* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrGetSerializedSceneFragmentDataMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSerializedSceneFragmentDataMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSerializedSceneFragmentDataMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSerializedSceneFragmentDataMSFT", objects_info,
                                "Invalid NULL for XrSerializedSceneFragmentDataGetInfoMSFT \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSerializedSceneFragmentDataGetInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSerializedSceneFragmentDataMSFT", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSerializedSceneFragmentDataMSFT-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSerializedSceneFragmentDataMSFT",
                                objects_info,
                                "Command xrGetSerializedSceneFragmentDataMSFT param getInfo is invalid");
            return xr_result;
        }
        // Optional array must be non-NULL when countInput is non-zero
        if (0 != countInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSerializedSceneFragmentDataMSFT-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSerializedSceneFragmentDataMSFT",
                                objects_info,
                                "Command xrGetSerializedSceneFragmentDataMSFT param buffer is NULL, but countInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == readOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSerializedSceneFragmentDataMSFT-readOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSerializedSceneFragmentDataMSFT", objects_info,
                                "Invalid NULL for uint32_t \"readOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSerializedSceneFragmentDataMSFT-readOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetSerializedSceneFragmentDataMSFT-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSerializedSceneFragmentDataMSFT(
    XrSceneMSFT scene,
    const XrSerializedSceneFragmentDataGetInfoMSFT* getInfo,
    uint32_t countInput,
    uint32_t* readOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSerializedSceneFragmentDataMSFT(
    XrSceneMSFT scene,
    const XrSerializedSceneFragmentDataGetInfoMSFT* getInfo,
    uint32_t countInput,
    uint32_t* readOutput,
    uint8_t* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
}


// ---- XR_FB_display_refresh_rate extension commands
XrResult GenValidUsageInputsXrEnumerateDisplayRefreshRatesFB(
XrSession session,
uint32_t displayRefreshRateCapacityInput,
uint32_t* displayRefreshRateCountOutput,
float* displayRefreshRates) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateDisplayRefreshRatesFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateDisplayRefreshRatesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when displayRefreshRateCapacityInput is non-zero
        if (0 != displayRefreshRateCapacityInput && nullptr == displayRefreshRates) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateDisplayRefreshRatesFB-displayRefreshRates-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateDisplayRefreshRatesFB",
                                objects_info,
                                "Command xrEnumerateDisplayRefreshRatesFB param displayRefreshRates is NULL, but displayRefreshRateCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == displayRefreshRateCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateDisplayRefreshRatesFB-displayRefreshRateCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateDisplayRefreshRatesFB", objects_info,
                                "Invalid NULL for uint32_t \"displayRefreshRateCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateDisplayRefreshRatesFB-displayRefreshRateCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrEnumerateDisplayRefreshRatesFB-displayRefreshRates-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateDisplayRefreshRatesFB(
    XrSession session,
    uint32_t displayRefreshRateCapacityInput,
    uint32_t* displayRefreshRateCountOutput,
    float* displayRefreshRates) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateDisplayRefreshRatesFB(
    XrSession session,
    uint32_t displayRefreshRateCapacityInput,
    uint32_t* displayRefreshRateCountOutput,
    float* displayRefreshRates) {
    XrResult test_result = GenValidUsageInputsXrEnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
}

XrResult GenValidUsageInputsXrGetDisplayRefreshRateFB(
XrSession session,
float* displayRefreshRate) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetDisplayRefreshRateFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDisplayRefreshRateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == displayRefreshRate) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetDisplayRefreshRateFB-displayRefreshRate-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDisplayRefreshRateFB", objects_info,
                                "Invalid NULL for float \"displayRefreshRate\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetDisplayRefreshRateFB-displayRefreshRate-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetDisplayRefreshRateFB(
    XrSession session,
    float* displayRefreshRate) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetDisplayRefreshRateFB(session, displayRefreshRate);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetDisplayRefreshRateFB(
    XrSession session,
    float* displayRefreshRate) {
    XrResult test_result = GenValidUsageInputsXrGetDisplayRefreshRateFB(session, displayRefreshRate);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetDisplayRefreshRateFB(session, displayRefreshRate);
}

XrResult GenValidUsageInputsXrRequestDisplayRefreshRateFB(
XrSession session,
float displayRefreshRate) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrRequestDisplayRefreshRateFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestDisplayRefreshRateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrRequestDisplayRefreshRateFB(
    XrSession session,
    float displayRefreshRate) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->RequestDisplayRefreshRateFB(session, displayRefreshRate);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrRequestDisplayRefreshRateFB(
    XrSession session,
    float displayRefreshRate) {
    XrResult test_result = GenValidUsageInputsXrRequestDisplayRefreshRateFB(session, displayRefreshRate);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrRequestDisplayRefreshRateFB(session, displayRefreshRate);
}


// ---- XR_HTCX_vive_tracker_interaction extension commands
XrResult GenValidUsageInputsXrEnumerateViveTrackerPathsHTCX(
XrInstance instance,
uint32_t pathCapacityInput,
uint32_t* pathCountOutput,
XrViveTrackerPathsHTCX* paths) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateViveTrackerPathsHTCX-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViveTrackerPathsHTCX",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when pathCapacityInput is non-zero
        if (0 != pathCapacityInput && nullptr == paths) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViveTrackerPathsHTCX-paths-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViveTrackerPathsHTCX",
                                objects_info,
                                "Command xrEnumerateViveTrackerPathsHTCX param paths is NULL, but pathCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == pathCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViveTrackerPathsHTCX-pathCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViveTrackerPathsHTCX", objects_info,
                                "Invalid NULL for uint32_t \"pathCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateViveTrackerPathsHTCX-pathCountOutput-parameter" type
        if (paths) {
            for (uint32_t value_paths_inc = 0; value_paths_inc < pathCapacityInput; ++value_paths_inc) {
                // Validate that the structure XrViveTrackerPathsHTCX is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateViveTrackerPathsHTCX", objects_info,
                                                                true, &paths[value_paths_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateViveTrackerPathsHTCX-paths-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateViveTrackerPathsHTCX",
                                        objects_info,
                                        "Command xrEnumerateViveTrackerPathsHTCX param paths is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateViveTrackerPathsHTCX(
    XrInstance instance,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrViveTrackerPathsHTCX* paths) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateViveTrackerPathsHTCX(
    XrInstance instance,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrViveTrackerPathsHTCX* paths) {
    XrResult test_result = GenValidUsageInputsXrEnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
}


// ---- XR_HTC_facial_tracking extension commands
XrResult GenValidUsageInputsXrCreateFacialTrackerHTC(
XrSession session,
const XrFacialTrackerCreateInfoHTC* createInfo,
XrFacialTrackerHTC* facialTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateFacialTrackerHTC-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFacialTrackerHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFacialTrackerHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFacialTrackerHTC", objects_info,
                                "Invalid NULL for XrFacialTrackerCreateInfoHTC \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFacialTrackerCreateInfoHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateFacialTrackerHTC", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFacialTrackerHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFacialTrackerHTC",
                                objects_info,
                                "Command xrCreateFacialTrackerHTC param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == facialTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFacialTrackerHTC-facialTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFacialTrackerHTC", objects_info,
                                "Invalid NULL for XrFacialTrackerHTC \"facialTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateFacialTrackerHTC(
    XrSession session,
    const XrFacialTrackerCreateInfoHTC* createInfo,
    XrFacialTrackerHTC* facialTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateFacialTrackerHTC(session, createInfo, facialTracker);
        if (XR_SUCCESS == result && nullptr != facialTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_facialtrackerhtc_info.insert(*facialTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateFacialTrackerHTC(
    XrSession session,
    const XrFacialTrackerCreateInfoHTC* createInfo,
    XrFacialTrackerHTC* facialTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateFacialTrackerHTC(session, createInfo, facialTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateFacialTrackerHTC(session, createInfo, facialTracker);
}

XrResult GenValidUsageInputsXrDestroyFacialTrackerHTC(
XrFacialTrackerHTC facialTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(facialTracker, XR_OBJECT_TYPE_FACIAL_TRACKER_HTC);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFacialTrackerHTCHandle(&facialTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFacialTrackerHTC handle \"facialTracker\" ";
                oss << HandleToHexString(facialTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyFacialTrackerHTC-facialTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyFacialTrackerHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facialtrackerhtc_info.getWithInstanceInfo(facialTracker);
        GenValidUsageXrHandleInfo *gen_facialtrackerhtc_info = info_with_instance.first;
        (void)gen_facialtrackerhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyFacialTrackerHTC(
    XrFacialTrackerHTC facialTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facialtrackerhtc_info.getWithInstanceInfo(facialTracker);
        GenValidUsageXrHandleInfo *gen_facialtrackerhtc_info = info_with_instance.first;
        (void)gen_facialtrackerhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyFacialTrackerHTC(facialTracker);
        if (XR_SUCCEEDED(result)) {
            g_facialtrackerhtc_info.erase(facialTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyFacialTrackerHTC(
    XrFacialTrackerHTC facialTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyFacialTrackerHTC(facialTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyFacialTrackerHTC(facialTracker);
}

XrResult GenValidUsageInputsXrGetFacialExpressionsHTC(
XrFacialTrackerHTC facialTracker,
XrFacialExpressionsHTC* facialExpressions) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(facialTracker, XR_OBJECT_TYPE_FACIAL_TRACKER_HTC);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFacialTrackerHTCHandle(&facialTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFacialTrackerHTC handle \"facialTracker\" ";
                oss << HandleToHexString(facialTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetFacialExpressionsHTC-facialTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFacialExpressionsHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facialtrackerhtc_info.getWithInstanceInfo(facialTracker);
        GenValidUsageXrHandleInfo *gen_facialtrackerhtc_info = info_with_instance.first;
        (void)gen_facialtrackerhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == facialExpressions) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFacialExpressionsHTC-facialExpressions-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFacialExpressionsHTC", objects_info,
                                "Invalid NULL for XrFacialExpressionsHTC \"facialExpressions\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFacialExpressionsHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFacialExpressionsHTC", objects_info,
                                                        false, facialExpressions);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFacialExpressionsHTC-facialExpressions-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFacialExpressionsHTC",
                                objects_info,
                                "Command xrGetFacialExpressionsHTC param facialExpressions is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetFacialExpressionsHTC(
    XrFacialTrackerHTC facialTracker,
    XrFacialExpressionsHTC* facialExpressions) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facialtrackerhtc_info.getWithInstanceInfo(facialTracker);
        GenValidUsageXrHandleInfo *gen_facialtrackerhtc_info = info_with_instance.first;
        (void)gen_facialtrackerhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetFacialExpressionsHTC(facialTracker, facialExpressions);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetFacialExpressionsHTC(
    XrFacialTrackerHTC facialTracker,
    XrFacialExpressionsHTC* facialExpressions) {
    XrResult test_result = GenValidUsageInputsXrGetFacialExpressionsHTC(facialTracker, facialExpressions);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetFacialExpressionsHTC(facialTracker, facialExpressions);
}


// ---- XR_FB_color_space extension commands
XrResult GenValidUsageInputsXrEnumerateColorSpacesFB(
XrSession session,
uint32_t colorSpaceCapacityInput,
uint32_t* colorSpaceCountOutput,
XrColorSpaceFB* colorSpaces) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateColorSpacesFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateColorSpacesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when colorSpaceCapacityInput is non-zero
        if (0 != colorSpaceCapacityInput && nullptr == colorSpaces) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateColorSpacesFB-colorSpaces-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateColorSpacesFB",
                                objects_info,
                                "Command xrEnumerateColorSpacesFB param colorSpaces is NULL, but colorSpaceCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == colorSpaceCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateColorSpacesFB-colorSpaceCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateColorSpacesFB", objects_info,
                                "Invalid NULL for uint32_t \"colorSpaceCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateColorSpacesFB-colorSpaceCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateColorSpacesFB-colorSpaces-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateColorSpacesFB(
    XrSession session,
    uint32_t colorSpaceCapacityInput,
    uint32_t* colorSpaceCountOutput,
    XrColorSpaceFB* colorSpaces) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateColorSpacesFB(
    XrSession session,
    uint32_t colorSpaceCapacityInput,
    uint32_t* colorSpaceCountOutput,
    XrColorSpaceFB* colorSpaces) {
    XrResult test_result = GenValidUsageInputsXrEnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
}

XrResult GenValidUsageInputsXrSetColorSpaceFB(
XrSession session,
const XrColorSpaceFB colorSpace) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetColorSpaceFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetColorSpaceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrColorSpaceFB value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrSetColorSpaceFB", "xrSetColorSpaceFB", "colorSpace", objects_info, colorSpace)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrColorSpaceFB \"colorSpace\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(colorSpace));
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetColorSpaceFB-colorSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetColorSpaceFB",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetColorSpaceFB(
    XrSession session,
    const XrColorSpaceFB colorSpace) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetColorSpaceFB(session, colorSpace);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetColorSpaceFB(
    XrSession session,
    const XrColorSpaceFB colorSpace) {
    XrResult test_result = GenValidUsageInputsXrSetColorSpaceFB(session, colorSpace);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetColorSpaceFB(session, colorSpace);
}


// ---- XR_FB_hand_tracking_mesh extension commands
XrResult GenValidUsageInputsXrGetHandMeshFB(
XrHandTrackerEXT handTracker,
XrHandTrackingMeshFB* mesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetHandMeshFB-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetHandMeshFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == mesh) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetHandMeshFB-mesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetHandMeshFB", objects_info,
                                "Invalid NULL for XrHandTrackingMeshFB \"mesh\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHandTrackingMeshFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetHandMeshFB", objects_info,
                                                        false, mesh);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetHandMeshFB-mesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetHandMeshFB",
                                objects_info,
                                "Command xrGetHandMeshFB param mesh is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetHandMeshFB(
    XrHandTrackerEXT handTracker,
    XrHandTrackingMeshFB* mesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetHandMeshFB(handTracker, mesh);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetHandMeshFB(
    XrHandTrackerEXT handTracker,
    XrHandTrackingMeshFB* mesh) {
    XrResult test_result = GenValidUsageInputsXrGetHandMeshFB(handTracker, mesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetHandMeshFB(handTracker, mesh);
}


// ---- XR_FB_spatial_entity extension commands
XrResult GenValidUsageInputsXrCreateSpatialAnchorFB(
XrSession session,
const XrSpatialAnchorCreateInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFB", objects_info,
                                "Invalid NULL for XrSpatialAnchorCreateInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialAnchorFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFB",
                                objects_info,
                                "Command xrCreateSpatialAnchorFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateSpatialAnchorFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorFB(
    XrSession session,
    const XrSpatialAnchorCreateInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorFB(
    XrSession session,
    const XrSpatialAnchorCreateInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorFB(session, info, requestId);
}

XrResult GenValidUsageInputsXrGetSpaceUuidFB(
XrSpace space,
XrUuidEXT* uuid) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceUuidFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceUuidFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == uuid) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceUuidFB-uuid-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceUuidFB", objects_info,
                                "Invalid NULL for XrUuidEXT \"uuid\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSpaceUuidFB-uuid-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceUuidFB(
    XrSpace space,
    XrUuidEXT* uuid) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceUuidFB(space, uuid);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceUuidFB(
    XrSpace space,
    XrUuidEXT* uuid) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceUuidFB(space, uuid);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceUuidFB(space, uuid);
}

XrResult GenValidUsageInputsXrEnumerateSpaceSupportedComponentsFB(
XrSpace space,
uint32_t componentTypeCapacityInput,
uint32_t* componentTypeCountOutput,
XrSpaceComponentTypeFB* componentTypes) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateSpaceSupportedComponentsFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSpaceSupportedComponentsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when componentTypeCapacityInput is non-zero
        if (0 != componentTypeCapacityInput && nullptr == componentTypes) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSpaceSupportedComponentsFB-componentTypes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSpaceSupportedComponentsFB",
                                objects_info,
                                "Command xrEnumerateSpaceSupportedComponentsFB param componentTypes is NULL, but componentTypeCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == componentTypeCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateSpaceSupportedComponentsFB-componentTypeCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateSpaceSupportedComponentsFB", objects_info,
                                "Invalid NULL for uint32_t \"componentTypeCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateSpaceSupportedComponentsFB-componentTypeCountOutput-parameter" type
                // NOTE: Can't validate "VUID-xrEnumerateSpaceSupportedComponentsFB-componentTypes-parameter" output enum buffer
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateSpaceSupportedComponentsFB(
    XrSpace space,
    uint32_t componentTypeCapacityInput,
    uint32_t* componentTypeCountOutput,
    XrSpaceComponentTypeFB* componentTypes) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateSpaceSupportedComponentsFB(
    XrSpace space,
    uint32_t componentTypeCapacityInput,
    uint32_t* componentTypeCountOutput,
    XrSpaceComponentTypeFB* componentTypes) {
    XrResult test_result = GenValidUsageInputsXrEnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
}

XrResult GenValidUsageInputsXrSetSpaceComponentStatusFB(
XrSpace space,
const XrSpaceComponentStatusSetInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrSetSpaceComponentStatusFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetSpaceComponentStatusFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetSpaceComponentStatusFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetSpaceComponentStatusFB", objects_info,
                                "Invalid NULL for XrSpaceComponentStatusSetInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceComponentStatusSetInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSetSpaceComponentStatusFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetSpaceComponentStatusFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetSpaceComponentStatusFB",
                                objects_info,
                                "Command xrSetSpaceComponentStatusFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetSpaceComponentStatusFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetSpaceComponentStatusFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrSetSpaceComponentStatusFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetSpaceComponentStatusFB(
    XrSpace space,
    const XrSpaceComponentStatusSetInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetSpaceComponentStatusFB(space, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetSpaceComponentStatusFB(
    XrSpace space,
    const XrSpaceComponentStatusSetInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrSetSpaceComponentStatusFB(space, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetSpaceComponentStatusFB(space, info, requestId);
}

XrResult GenValidUsageInputsXrGetSpaceComponentStatusFB(
XrSpace space,
XrSpaceComponentTypeFB componentType,
XrSpaceComponentStatusFB* status) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceComponentStatusFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceComponentStatusFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrSpaceComponentTypeFB value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetSpaceComponentStatusFB", "xrGetSpaceComponentStatusFB", "componentType", objects_info, componentType)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrSpaceComponentTypeFB \"componentType\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(componentType));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceComponentStatusFB-componentType-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceComponentStatusFB",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == status) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceComponentStatusFB-status-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceComponentStatusFB", objects_info,
                                "Invalid NULL for XrSpaceComponentStatusFB \"status\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceComponentStatusFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceComponentStatusFB", objects_info,
                                                        false, status);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceComponentStatusFB-status-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceComponentStatusFB",
                                objects_info,
                                "Command xrGetSpaceComponentStatusFB param status is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceComponentStatusFB(
    XrSpace space,
    XrSpaceComponentTypeFB componentType,
    XrSpaceComponentStatusFB* status) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceComponentStatusFB(space, componentType, status);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceComponentStatusFB(
    XrSpace space,
    XrSpaceComponentTypeFB componentType,
    XrSpaceComponentStatusFB* status) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceComponentStatusFB(space, componentType, status);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceComponentStatusFB(space, componentType, status);
}


// ---- XR_FB_foveation extension commands
XrResult GenValidUsageInputsXrCreateFoveationProfileFB(
XrSession session,
const XrFoveationProfileCreateInfoFB* createInfo,
XrFoveationProfileFB* profile) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateFoveationProfileFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFoveationProfileFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFoveationProfileFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFoveationProfileFB", objects_info,
                                "Invalid NULL for XrFoveationProfileCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFoveationProfileCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateFoveationProfileFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFoveationProfileFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFoveationProfileFB",
                                objects_info,
                                "Command xrCreateFoveationProfileFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == profile) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFoveationProfileFB-profile-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFoveationProfileFB", objects_info,
                                "Invalid NULL for XrFoveationProfileFB \"profile\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateFoveationProfileFB(
    XrSession session,
    const XrFoveationProfileCreateInfoFB* createInfo,
    XrFoveationProfileFB* profile) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateFoveationProfileFB(session, createInfo, profile);
        if (XR_SUCCESS == result && nullptr != profile) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_foveationprofilefb_info.insert(*profile, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateFoveationProfileFB(
    XrSession session,
    const XrFoveationProfileCreateInfoFB* createInfo,
    XrFoveationProfileFB* profile) {
    XrResult test_result = GenValidUsageInputsXrCreateFoveationProfileFB(session, createInfo, profile);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateFoveationProfileFB(session, createInfo, profile);
}

XrResult GenValidUsageInputsXrDestroyFoveationProfileFB(
XrFoveationProfileFB profile) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(profile, XR_OBJECT_TYPE_FOVEATION_PROFILE_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFoveationProfileFBHandle(&profile);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFoveationProfileFB handle \"profile\" ";
                oss << HandleToHexString(profile);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyFoveationProfileFB-profile-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyFoveationProfileFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_foveationprofilefb_info.getWithInstanceInfo(profile);
        GenValidUsageXrHandleInfo *gen_foveationprofilefb_info = info_with_instance.first;
        (void)gen_foveationprofilefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyFoveationProfileFB(
    XrFoveationProfileFB profile) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_foveationprofilefb_info.getWithInstanceInfo(profile);
        GenValidUsageXrHandleInfo *gen_foveationprofilefb_info = info_with_instance.first;
        (void)gen_foveationprofilefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyFoveationProfileFB(profile);
        if (XR_SUCCEEDED(result)) {
            g_foveationprofilefb_info.erase(profile);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyFoveationProfileFB(
    XrFoveationProfileFB profile) {
    XrResult test_result = GenValidUsageInputsXrDestroyFoveationProfileFB(profile);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyFoveationProfileFB(profile);
}


// ---- XR_FB_keyboard_tracking extension commands
XrResult GenValidUsageInputsXrQuerySystemTrackedKeyboardFB(
XrSession session,
const XrKeyboardTrackingQueryFB* queryInfo,
XrKeyboardTrackingDescriptionFB* keyboard) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrQuerySystemTrackedKeyboardFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySystemTrackedKeyboardFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == queryInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySystemTrackedKeyboardFB-queryInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySystemTrackedKeyboardFB", objects_info,
                                "Invalid NULL for XrKeyboardTrackingQueryFB \"queryInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrKeyboardTrackingQueryFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrQuerySystemTrackedKeyboardFB", objects_info,
                                                        true, queryInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySystemTrackedKeyboardFB-queryInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySystemTrackedKeyboardFB",
                                objects_info,
                                "Command xrQuerySystemTrackedKeyboardFB param queryInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == keyboard) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySystemTrackedKeyboardFB-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySystemTrackedKeyboardFB", objects_info,
                                "Invalid NULL for XrKeyboardTrackingDescriptionFB \"keyboard\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrKeyboardTrackingDescriptionFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrQuerySystemTrackedKeyboardFB", objects_info,
                                                        false, keyboard);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySystemTrackedKeyboardFB-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySystemTrackedKeyboardFB",
                                objects_info,
                                "Command xrQuerySystemTrackedKeyboardFB param keyboard is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrQuerySystemTrackedKeyboardFB(
    XrSession session,
    const XrKeyboardTrackingQueryFB* queryInfo,
    XrKeyboardTrackingDescriptionFB* keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->QuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrQuerySystemTrackedKeyboardFB(
    XrSession session,
    const XrKeyboardTrackingQueryFB* queryInfo,
    XrKeyboardTrackingDescriptionFB* keyboard) {
    XrResult test_result = GenValidUsageInputsXrQuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrQuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
}

XrResult GenValidUsageInputsXrCreateKeyboardSpaceFB(
XrSession session,
const XrKeyboardSpaceCreateInfoFB* createInfo,
XrSpace* keyboardSpace) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateKeyboardSpaceFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateKeyboardSpaceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateKeyboardSpaceFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateKeyboardSpaceFB", objects_info,
                                "Invalid NULL for XrKeyboardSpaceCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrKeyboardSpaceCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateKeyboardSpaceFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateKeyboardSpaceFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateKeyboardSpaceFB",
                                objects_info,
                                "Command xrCreateKeyboardSpaceFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == keyboardSpace) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateKeyboardSpaceFB-keyboardSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateKeyboardSpaceFB", objects_info,
                                "Invalid NULL for XrSpace \"keyboardSpace\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateKeyboardSpaceFB(
    XrSession session,
    const XrKeyboardSpaceCreateInfoFB* createInfo,
    XrSpace* keyboardSpace) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
        if (XR_SUCCESS == result && nullptr != keyboardSpace) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*keyboardSpace, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateKeyboardSpaceFB(
    XrSession session,
    const XrKeyboardSpaceCreateInfoFB* createInfo,
    XrSpace* keyboardSpace) {
    XrResult test_result = GenValidUsageInputsXrCreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
}


// ---- XR_FB_triangle_mesh extension commands
XrResult GenValidUsageInputsXrCreateTriangleMeshFB(
XrSession session,
const XrTriangleMeshCreateInfoFB* createInfo,
XrTriangleMeshFB* outTriangleMesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateTriangleMeshFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateTriangleMeshFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateTriangleMeshFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateTriangleMeshFB", objects_info,
                                "Invalid NULL for XrTriangleMeshCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrTriangleMeshCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateTriangleMeshFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateTriangleMeshFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateTriangleMeshFB",
                                objects_info,
                                "Command xrCreateTriangleMeshFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outTriangleMesh) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateTriangleMeshFB-outTriangleMesh-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateTriangleMeshFB", objects_info,
                                "Invalid NULL for XrTriangleMeshFB \"outTriangleMesh\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateTriangleMeshFB(
    XrSession session,
    const XrTriangleMeshCreateInfoFB* createInfo,
    XrTriangleMeshFB* outTriangleMesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateTriangleMeshFB(session, createInfo, outTriangleMesh);
        if (XR_SUCCESS == result && nullptr != outTriangleMesh) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_trianglemeshfb_info.insert(*outTriangleMesh, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateTriangleMeshFB(
    XrSession session,
    const XrTriangleMeshCreateInfoFB* createInfo,
    XrTriangleMeshFB* outTriangleMesh) {
    XrResult test_result = GenValidUsageInputsXrCreateTriangleMeshFB(session, createInfo, outTriangleMesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateTriangleMeshFB(session, createInfo, outTriangleMesh);
}

XrResult GenValidUsageInputsXrDestroyTriangleMeshFB(
XrTriangleMeshFB mesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyTriangleMeshFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyTriangleMeshFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyTriangleMeshFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyTriangleMeshFB(mesh);
        if (XR_SUCCEEDED(result)) {
            g_trianglemeshfb_info.erase(mesh);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyTriangleMeshFB(
    XrTriangleMeshFB mesh) {
    XrResult test_result = GenValidUsageInputsXrDestroyTriangleMeshFB(mesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyTriangleMeshFB(mesh);
}

XrResult GenValidUsageInputsXrTriangleMeshGetVertexBufferFB(
XrTriangleMeshFB mesh,
XrVector3f** outVertexBuffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshGetVertexBufferFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshGetVertexBufferFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outVertexBuffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTriangleMeshGetVertexBufferFB-outVertexBuffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshGetVertexBufferFB", objects_info,
                                "Invalid NULL for XrVector3f \"outVertexBuffer\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrTriangleMeshGetVertexBufferFB-outVertexBuffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshGetVertexBufferFB(
    XrTriangleMeshFB mesh,
    XrVector3f** outVertexBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshGetVertexBufferFB(
    XrTriangleMeshFB mesh,
    XrVector3f** outVertexBuffer) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
}

XrResult GenValidUsageInputsXrTriangleMeshGetIndexBufferFB(
XrTriangleMeshFB mesh,
uint32_t** outIndexBuffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshGetIndexBufferFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshGetIndexBufferFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outIndexBuffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTriangleMeshGetIndexBufferFB-outIndexBuffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshGetIndexBufferFB", objects_info,
                                "Invalid NULL for uint32_t \"outIndexBuffer\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrTriangleMeshGetIndexBufferFB-outIndexBuffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshGetIndexBufferFB(
    XrTriangleMeshFB mesh,
    uint32_t** outIndexBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshGetIndexBufferFB(
    XrTriangleMeshFB mesh,
    uint32_t** outIndexBuffer) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
}

XrResult GenValidUsageInputsXrTriangleMeshBeginUpdateFB(
XrTriangleMeshFB mesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshBeginUpdateFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshBeginUpdateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshBeginUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshBeginUpdateFB(mesh);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshBeginUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshBeginUpdateFB(mesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshBeginUpdateFB(mesh);
}

XrResult GenValidUsageInputsXrTriangleMeshEndUpdateFB(
XrTriangleMeshFB mesh,
uint32_t vertexCount,
uint32_t triangleCount) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshEndUpdateFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshEndUpdateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshEndUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t vertexCount,
    uint32_t triangleCount) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshEndUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t vertexCount,
    uint32_t triangleCount) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
}

XrResult GenValidUsageInputsXrTriangleMeshBeginVertexBufferUpdateFB(
XrTriangleMeshFB mesh,
uint32_t* outVertexCount) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshBeginVertexBufferUpdateFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshBeginVertexBufferUpdateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outVertexCount) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrTriangleMeshBeginVertexBufferUpdateFB-outVertexCount-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshBeginVertexBufferUpdateFB", objects_info,
                                "Invalid NULL for uint32_t \"outVertexCount\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrTriangleMeshBeginVertexBufferUpdateFB-outVertexCount-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshBeginVertexBufferUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t* outVertexCount) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshBeginVertexBufferUpdateFB(
    XrTriangleMeshFB mesh,
    uint32_t* outVertexCount) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
}

XrResult GenValidUsageInputsXrTriangleMeshEndVertexBufferUpdateFB(
XrTriangleMeshFB mesh) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(mesh, XR_OBJECT_TYPE_TRIANGLE_MESH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrTriangleMeshFBHandle(&mesh);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrTriangleMeshFB handle \"mesh\" ";
                oss << HandleToHexString(mesh);
                CoreValidLogMessage(nullptr, "VUID-xrTriangleMeshEndVertexBufferUpdateFB-mesh-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrTriangleMeshEndVertexBufferUpdateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrTriangleMeshEndVertexBufferUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_trianglemeshfb_info.getWithInstanceInfo(mesh);
        GenValidUsageXrHandleInfo *gen_trianglemeshfb_info = info_with_instance.first;
        (void)gen_trianglemeshfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->TriangleMeshEndVertexBufferUpdateFB(mesh);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrTriangleMeshEndVertexBufferUpdateFB(
    XrTriangleMeshFB mesh) {
    XrResult test_result = GenValidUsageInputsXrTriangleMeshEndVertexBufferUpdateFB(mesh);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrTriangleMeshEndVertexBufferUpdateFB(mesh);
}


// ---- XR_FB_passthrough extension commands
XrResult GenValidUsageInputsXrCreatePassthroughFB(
XrSession session,
const XrPassthroughCreateInfoFB* createInfo,
XrPassthroughFB* outPassthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreatePassthroughFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughFB", objects_info,
                                "Invalid NULL for XrPassthroughCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreatePassthroughFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughFB",
                                objects_info,
                                "Command xrCreatePassthroughFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outPassthrough) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughFB-outPassthrough-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughFB", objects_info,
                                "Invalid NULL for XrPassthroughFB \"outPassthrough\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreatePassthroughFB(
    XrSession session,
    const XrPassthroughCreateInfoFB* createInfo,
    XrPassthroughFB* outPassthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreatePassthroughFB(session, createInfo, outPassthrough);
        if (XR_SUCCESS == result && nullptr != outPassthrough) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_passthroughfb_info.insert(*outPassthrough, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreatePassthroughFB(
    XrSession session,
    const XrPassthroughCreateInfoFB* createInfo,
    XrPassthroughFB* outPassthrough) {
    XrResult test_result = GenValidUsageInputsXrCreatePassthroughFB(session, createInfo, outPassthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreatePassthroughFB(session, createInfo, outPassthrough);
}

XrResult GenValidUsageInputsXrDestroyPassthroughFB(
XrPassthroughFB passthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(passthrough, XR_OBJECT_TYPE_PASSTHROUGH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughFBHandle(&passthrough);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughFB handle \"passthrough\" ";
                oss << HandleToHexString(passthrough);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyPassthroughFB-passthrough-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyPassthroughFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyPassthroughFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyPassthroughFB(passthrough);
        if (XR_SUCCEEDED(result)) {
            g_passthroughfb_info.erase(passthrough);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyPassthroughFB(
    XrPassthroughFB passthrough) {
    XrResult test_result = GenValidUsageInputsXrDestroyPassthroughFB(passthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyPassthroughFB(passthrough);
}

XrResult GenValidUsageInputsXrPassthroughStartFB(
XrPassthroughFB passthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(passthrough, XR_OBJECT_TYPE_PASSTHROUGH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughFBHandle(&passthrough);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughFB handle \"passthrough\" ";
                oss << HandleToHexString(passthrough);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughStartFB-passthrough-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughStartFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughStartFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughStartFB(passthrough);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughStartFB(
    XrPassthroughFB passthrough) {
    XrResult test_result = GenValidUsageInputsXrPassthroughStartFB(passthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughStartFB(passthrough);
}

XrResult GenValidUsageInputsXrPassthroughPauseFB(
XrPassthroughFB passthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(passthrough, XR_OBJECT_TYPE_PASSTHROUGH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughFBHandle(&passthrough);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughFB handle \"passthrough\" ";
                oss << HandleToHexString(passthrough);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughPauseFB-passthrough-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughPauseFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughPauseFB(
    XrPassthroughFB passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughPauseFB(passthrough);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughPauseFB(
    XrPassthroughFB passthrough) {
    XrResult test_result = GenValidUsageInputsXrPassthroughPauseFB(passthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughPauseFB(passthrough);
}

XrResult GenValidUsageInputsXrCreatePassthroughLayerFB(
XrSession session,
const XrPassthroughLayerCreateInfoFB* createInfo,
XrPassthroughLayerFB* outLayer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreatePassthroughLayerFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughLayerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughLayerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughLayerFB", objects_info,
                                "Invalid NULL for XrPassthroughLayerCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughLayerCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreatePassthroughLayerFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughLayerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughLayerFB",
                                objects_info,
                                "Command xrCreatePassthroughLayerFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outLayer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughLayerFB-outLayer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughLayerFB", objects_info,
                                "Invalid NULL for XrPassthroughLayerFB \"outLayer\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreatePassthroughLayerFB(
    XrSession session,
    const XrPassthroughLayerCreateInfoFB* createInfo,
    XrPassthroughLayerFB* outLayer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreatePassthroughLayerFB(session, createInfo, outLayer);
        if (XR_SUCCESS == result && nullptr != outLayer) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_passthroughlayerfb_info.insert(*outLayer, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreatePassthroughLayerFB(
    XrSession session,
    const XrPassthroughLayerCreateInfoFB* createInfo,
    XrPassthroughLayerFB* outLayer) {
    XrResult test_result = GenValidUsageInputsXrCreatePassthroughLayerFB(session, createInfo, outLayer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreatePassthroughLayerFB(session, createInfo, outLayer);
}

XrResult GenValidUsageInputsXrDestroyPassthroughLayerFB(
XrPassthroughLayerFB layer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(layer, XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&layer);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
                oss << HandleToHexString(layer);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyPassthroughLayerFB-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyPassthroughLayerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyPassthroughLayerFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyPassthroughLayerFB(layer);
        if (XR_SUCCEEDED(result)) {
            g_passthroughlayerfb_info.erase(layer);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyPassthroughLayerFB(
    XrPassthroughLayerFB layer) {
    XrResult test_result = GenValidUsageInputsXrDestroyPassthroughLayerFB(layer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyPassthroughLayerFB(layer);
}

XrResult GenValidUsageInputsXrPassthroughLayerPauseFB(
XrPassthroughLayerFB layer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(layer, XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&layer);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
                oss << HandleToHexString(layer);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughLayerPauseFB-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerPauseFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughLayerPauseFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughLayerPauseFB(layer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughLayerPauseFB(
    XrPassthroughLayerFB layer) {
    XrResult test_result = GenValidUsageInputsXrPassthroughLayerPauseFB(layer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughLayerPauseFB(layer);
}

XrResult GenValidUsageInputsXrPassthroughLayerResumeFB(
XrPassthroughLayerFB layer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(layer, XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&layer);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
                oss << HandleToHexString(layer);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughLayerResumeFB-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerResumeFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughLayerResumeFB(
    XrPassthroughLayerFB layer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughLayerResumeFB(layer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughLayerResumeFB(
    XrPassthroughLayerFB layer) {
    XrResult test_result = GenValidUsageInputsXrPassthroughLayerResumeFB(layer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughLayerResumeFB(layer);
}

XrResult GenValidUsageInputsXrPassthroughLayerSetStyleFB(
XrPassthroughLayerFB layer,
const XrPassthroughStyleFB* style) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(layer, XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&layer);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
                oss << HandleToHexString(layer);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughLayerSetStyleFB-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetStyleFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == style) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPassthroughLayerSetStyleFB-style-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetStyleFB", objects_info,
                                "Invalid NULL for XrPassthroughStyleFB \"style\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughStyleFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrPassthroughLayerSetStyleFB", objects_info,
                                                        true, style);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPassthroughLayerSetStyleFB-style-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetStyleFB",
                                objects_info,
                                "Command xrPassthroughLayerSetStyleFB param style is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughLayerSetStyleFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughStyleFB* style) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughLayerSetStyleFB(layer, style);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughLayerSetStyleFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughStyleFB* style) {
    XrResult test_result = GenValidUsageInputsXrPassthroughLayerSetStyleFB(layer, style);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughLayerSetStyleFB(layer, style);
}

XrResult GenValidUsageInputsXrCreateGeometryInstanceFB(
XrSession session,
const XrGeometryInstanceCreateInfoFB* createInfo,
XrGeometryInstanceFB* outGeometryInstance) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateGeometryInstanceFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateGeometryInstanceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateGeometryInstanceFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateGeometryInstanceFB", objects_info,
                                "Invalid NULL for XrGeometryInstanceCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGeometryInstanceCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateGeometryInstanceFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateGeometryInstanceFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateGeometryInstanceFB",
                                objects_info,
                                "Command xrCreateGeometryInstanceFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == outGeometryInstance) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateGeometryInstanceFB-outGeometryInstance-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateGeometryInstanceFB", objects_info,
                                "Invalid NULL for XrGeometryInstanceFB \"outGeometryInstance\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateGeometryInstanceFB(
    XrSession session,
    const XrGeometryInstanceCreateInfoFB* createInfo,
    XrGeometryInstanceFB* outGeometryInstance) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
        if (XR_SUCCESS == result && nullptr != outGeometryInstance) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_geometryinstancefb_info.insert(*outGeometryInstance, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateGeometryInstanceFB(
    XrSession session,
    const XrGeometryInstanceCreateInfoFB* createInfo,
    XrGeometryInstanceFB* outGeometryInstance) {
    XrResult test_result = GenValidUsageInputsXrCreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
}

XrResult GenValidUsageInputsXrDestroyGeometryInstanceFB(
XrGeometryInstanceFB instance) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrGeometryInstanceFBHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrGeometryInstanceFB handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyGeometryInstanceFB-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyGeometryInstanceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_geometryinstancefb_info.getWithInstanceInfo(instance);
        GenValidUsageXrHandleInfo *gen_geometryinstancefb_info = info_with_instance.first;
        (void)gen_geometryinstancefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyGeometryInstanceFB(
    XrGeometryInstanceFB instance) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_geometryinstancefb_info.getWithInstanceInfo(instance);
        GenValidUsageXrHandleInfo *gen_geometryinstancefb_info = info_with_instance.first;
        (void)gen_geometryinstancefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyGeometryInstanceFB(instance);
        if (XR_SUCCEEDED(result)) {
            g_geometryinstancefb_info.erase(instance);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyGeometryInstanceFB(
    XrGeometryInstanceFB instance) {
    XrResult test_result = GenValidUsageInputsXrDestroyGeometryInstanceFB(instance);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyGeometryInstanceFB(instance);
}

XrResult GenValidUsageInputsXrGeometryInstanceSetTransformFB(
XrGeometryInstanceFB instance,
const XrGeometryInstanceTransformFB* transformation) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrGeometryInstanceFBHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrGeometryInstanceFB handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGeometryInstanceSetTransformFB-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGeometryInstanceSetTransformFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_geometryinstancefb_info.getWithInstanceInfo(instance);
        GenValidUsageXrHandleInfo *gen_geometryinstancefb_info = info_with_instance.first;
        (void)gen_geometryinstancefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == transformation) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGeometryInstanceSetTransformFB-transformation-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGeometryInstanceSetTransformFB", objects_info,
                                "Invalid NULL for XrGeometryInstanceTransformFB \"transformation\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrGeometryInstanceTransformFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGeometryInstanceSetTransformFB", objects_info,
                                                        true, transformation);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGeometryInstanceSetTransformFB-transformation-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGeometryInstanceSetTransformFB",
                                objects_info,
                                "Command xrGeometryInstanceSetTransformFB param transformation is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGeometryInstanceSetTransformFB(
    XrGeometryInstanceFB instance,
    const XrGeometryInstanceTransformFB* transformation) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_geometryinstancefb_info.getWithInstanceInfo(instance);
        GenValidUsageXrHandleInfo *gen_geometryinstancefb_info = info_with_instance.first;
        (void)gen_geometryinstancefb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GeometryInstanceSetTransformFB(instance, transformation);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGeometryInstanceSetTransformFB(
    XrGeometryInstanceFB instance,
    const XrGeometryInstanceTransformFB* transformation) {
    XrResult test_result = GenValidUsageInputsXrGeometryInstanceSetTransformFB(instance, transformation);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGeometryInstanceSetTransformFB(instance, transformation);
}


// ---- XR_FB_render_model extension commands
XrResult GenValidUsageInputsXrEnumerateRenderModelPathsFB(
XrSession session,
uint32_t pathCapacityInput,
uint32_t* pathCountOutput,
XrRenderModelPathInfoFB* paths) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateRenderModelPathsFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateRenderModelPathsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when pathCapacityInput is non-zero
        if (0 != pathCapacityInput && nullptr == paths) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateRenderModelPathsFB-paths-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateRenderModelPathsFB",
                                objects_info,
                                "Command xrEnumerateRenderModelPathsFB param paths is NULL, but pathCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == pathCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateRenderModelPathsFB-pathCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateRenderModelPathsFB", objects_info,
                                "Invalid NULL for uint32_t \"pathCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateRenderModelPathsFB-pathCountOutput-parameter" type
        if (paths) {
            for (uint32_t value_paths_inc = 0; value_paths_inc < pathCapacityInput; ++value_paths_inc) {
                // Validate that the structure XrRenderModelPathInfoFB is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateRenderModelPathsFB", objects_info,
                                                                true, &paths[value_paths_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateRenderModelPathsFB-paths-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateRenderModelPathsFB",
                                        objects_info,
                                        "Command xrEnumerateRenderModelPathsFB param paths is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateRenderModelPathsFB(
    XrSession session,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrRenderModelPathInfoFB* paths) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateRenderModelPathsFB(
    XrSession session,
    uint32_t pathCapacityInput,
    uint32_t* pathCountOutput,
    XrRenderModelPathInfoFB* paths) {
    XrResult test_result = GenValidUsageInputsXrEnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
}

XrResult GenValidUsageInputsXrGetRenderModelPropertiesFB(
XrSession session,
XrPath path,
XrRenderModelPropertiesFB* properties) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetRenderModelPropertiesFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRenderModelPropertiesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == properties) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRenderModelPropertiesFB-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRenderModelPropertiesFB", objects_info,
                                "Invalid NULL for XrRenderModelPropertiesFB \"properties\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRenderModelPropertiesFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetRenderModelPropertiesFB", objects_info,
                                                        false, properties);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRenderModelPropertiesFB-properties-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRenderModelPropertiesFB",
                                objects_info,
                                "Command xrGetRenderModelPropertiesFB param properties is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetRenderModelPropertiesFB(
    XrSession session,
    XrPath path,
    XrRenderModelPropertiesFB* properties) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetRenderModelPropertiesFB(session, path, properties);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetRenderModelPropertiesFB(
    XrSession session,
    XrPath path,
    XrRenderModelPropertiesFB* properties) {
    XrResult test_result = GenValidUsageInputsXrGetRenderModelPropertiesFB(session, path, properties);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetRenderModelPropertiesFB(session, path, properties);
}

XrResult GenValidUsageInputsXrLoadRenderModelFB(
XrSession session,
const XrRenderModelLoadInfoFB* info,
XrRenderModelBufferFB* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrLoadRenderModelFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadRenderModelFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadRenderModelFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadRenderModelFB", objects_info,
                                "Invalid NULL for XrRenderModelLoadInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRenderModelLoadInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLoadRenderModelFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadRenderModelFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadRenderModelFB",
                                objects_info,
                                "Command xrLoadRenderModelFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadRenderModelFB-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadRenderModelFB", objects_info,
                                "Invalid NULL for XrRenderModelBufferFB \"buffer\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRenderModelBufferFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrLoadRenderModelFB", objects_info,
                                                        false, buffer);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrLoadRenderModelFB-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrLoadRenderModelFB",
                                objects_info,
                                "Command xrLoadRenderModelFB param buffer is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrLoadRenderModelFB(
    XrSession session,
    const XrRenderModelLoadInfoFB* info,
    XrRenderModelBufferFB* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->LoadRenderModelFB(session, info, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrLoadRenderModelFB(
    XrSession session,
    const XrRenderModelLoadInfoFB* info,
    XrRenderModelBufferFB* buffer) {
    XrResult test_result = GenValidUsageInputsXrLoadRenderModelFB(session, info, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrLoadRenderModelFB(session, info, buffer);
}


// ---- XR_VARJO_environment_depth_estimation extension commands
XrResult GenValidUsageInputsXrSetEnvironmentDepthEstimationVARJO(
XrSession session,
XrBool32 enabled) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetEnvironmentDepthEstimationVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetEnvironmentDepthEstimationVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetEnvironmentDepthEstimationVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetEnvironmentDepthEstimationVARJO(session, enabled);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetEnvironmentDepthEstimationVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult test_result = GenValidUsageInputsXrSetEnvironmentDepthEstimationVARJO(session, enabled);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetEnvironmentDepthEstimationVARJO(session, enabled);
}


// ---- XR_VARJO_marker_tracking extension commands
XrResult GenValidUsageInputsXrSetMarkerTrackingVARJO(
XrSession session,
XrBool32 enabled) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetMarkerTrackingVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetMarkerTrackingVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetMarkerTrackingVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetMarkerTrackingVARJO(session, enabled);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetMarkerTrackingVARJO(
    XrSession session,
    XrBool32 enabled) {
    XrResult test_result = GenValidUsageInputsXrSetMarkerTrackingVARJO(session, enabled);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetMarkerTrackingVARJO(session, enabled);
}

XrResult GenValidUsageInputsXrSetMarkerTrackingTimeoutVARJO(
XrSession session,
uint64_t markerId,
XrDuration timeout) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetMarkerTrackingTimeoutVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetMarkerTrackingTimeoutVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetMarkerTrackingTimeoutVARJO(
    XrSession session,
    uint64_t markerId,
    XrDuration timeout) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetMarkerTrackingTimeoutVARJO(
    XrSession session,
    uint64_t markerId,
    XrDuration timeout) {
    XrResult test_result = GenValidUsageInputsXrSetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
}

XrResult GenValidUsageInputsXrSetMarkerTrackingPredictionVARJO(
XrSession session,
uint64_t markerId,
XrBool32 enable) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetMarkerTrackingPredictionVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetMarkerTrackingPredictionVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetMarkerTrackingPredictionVARJO(
    XrSession session,
    uint64_t markerId,
    XrBool32 enable) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetMarkerTrackingPredictionVARJO(session, markerId, enable);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetMarkerTrackingPredictionVARJO(
    XrSession session,
    uint64_t markerId,
    XrBool32 enable) {
    XrResult test_result = GenValidUsageInputsXrSetMarkerTrackingPredictionVARJO(session, markerId, enable);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetMarkerTrackingPredictionVARJO(session, markerId, enable);
}

XrResult GenValidUsageInputsXrGetMarkerSizeVARJO(
XrSession session,
uint64_t markerId,
XrExtent2Df* size) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerSizeVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerSizeVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == size) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerSizeVARJO-size-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerSizeVARJO", objects_info,
                                "Invalid NULL for XrExtent2Df \"size\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkerSizeVARJO-size-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerSizeVARJO(
    XrSession session,
    uint64_t markerId,
    XrExtent2Df* size) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerSizeVARJO(session, markerId, size);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerSizeVARJO(
    XrSession session,
    uint64_t markerId,
    XrExtent2Df* size) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerSizeVARJO(session, markerId, size);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerSizeVARJO(session, markerId, size);
}

XrResult GenValidUsageInputsXrCreateMarkerSpaceVARJO(
XrSession session,
const XrMarkerSpaceCreateInfoVARJO* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateMarkerSpaceVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceVARJO-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceVARJO", objects_info,
                                "Invalid NULL for XrMarkerSpaceCreateInfoVARJO \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMarkerSpaceCreateInfoVARJO is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateMarkerSpaceVARJO", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceVARJO-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceVARJO",
                                objects_info,
                                "Command xrCreateMarkerSpaceVARJO param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceVARJO-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceVARJO", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateMarkerSpaceVARJO(
    XrSession session,
    const XrMarkerSpaceCreateInfoVARJO* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateMarkerSpaceVARJO(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateMarkerSpaceVARJO(
    XrSession session,
    const XrMarkerSpaceCreateInfoVARJO* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateMarkerSpaceVARJO(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateMarkerSpaceVARJO(session, createInfo, space);
}


// ---- XR_VARJO_view_offset extension commands
XrResult GenValidUsageInputsXrSetViewOffsetVARJO(
XrSession session,
float offset) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetViewOffsetVARJO-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetViewOffsetVARJO",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetViewOffsetVARJO(
    XrSession session,
    float offset) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetViewOffsetVARJO(session, offset);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetViewOffsetVARJO(
    XrSession session,
    float offset) {
    XrResult test_result = GenValidUsageInputsXrSetViewOffsetVARJO(session, offset);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetViewOffsetVARJO(session, offset);
}


// ---- XR_ML_compat extension commands
#if defined(XR_USE_PLATFORM_ML)

XrResult GenValidUsageInputsXrCreateSpaceFromCoordinateFrameUIDML(
XrSession session,
const XrCoordinateSpaceCreateInfoML *createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpaceFromCoordinateFrameUIDML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceFromCoordinateFrameUIDML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceFromCoordinateFrameUIDML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceFromCoordinateFrameUIDML", objects_info,
                                "Invalid NULL for XrCoordinateSpaceCreateInfoML \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrCoordinateSpaceCreateInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpaceFromCoordinateFrameUIDML", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceFromCoordinateFrameUIDML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceFromCoordinateFrameUIDML",
                                objects_info,
                                "Command xrCreateSpaceFromCoordinateFrameUIDML param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceFromCoordinateFrameUIDML-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceFromCoordinateFrameUIDML", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpaceFromCoordinateFrameUIDML(
    XrSession session,
    const XrCoordinateSpaceCreateInfoML *createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpaceFromCoordinateFrameUIDML(
    XrSession session,
    const XrCoordinateSpaceCreateInfoML *createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
}

#endif // defined(XR_USE_PLATFORM_ML)


// ---- XR_ML_marker_understanding extension commands
XrResult GenValidUsageInputsXrCreateMarkerDetectorML(
XrSession session,
const XrMarkerDetectorCreateInfoML* createInfo,
XrMarkerDetectorML* markerDetector) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateMarkerDetectorML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerDetectorML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerDetectorML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerDetectorML", objects_info,
                                "Invalid NULL for XrMarkerDetectorCreateInfoML \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMarkerDetectorCreateInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateMarkerDetectorML", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerDetectorML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerDetectorML",
                                objects_info,
                                "Command xrCreateMarkerDetectorML param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == markerDetector) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerDetectorML-markerDetector-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerDetectorML", objects_info,
                                "Invalid NULL for XrMarkerDetectorML \"markerDetector\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateMarkerDetectorML(
    XrSession session,
    const XrMarkerDetectorCreateInfoML* createInfo,
    XrMarkerDetectorML* markerDetector) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateMarkerDetectorML(session, createInfo, markerDetector);
        if (XR_SUCCESS == result && nullptr != markerDetector) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_markerdetectorml_info.insert(*markerDetector, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateMarkerDetectorML(
    XrSession session,
    const XrMarkerDetectorCreateInfoML* createInfo,
    XrMarkerDetectorML* markerDetector) {
    XrResult test_result = GenValidUsageInputsXrCreateMarkerDetectorML(session, createInfo, markerDetector);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateMarkerDetectorML(session, createInfo, markerDetector);
}

XrResult GenValidUsageInputsXrDestroyMarkerDetectorML(
XrMarkerDetectorML markerDetector) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyMarkerDetectorML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyMarkerDetectorML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyMarkerDetectorML(
    XrMarkerDetectorML markerDetector) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyMarkerDetectorML(markerDetector);
        if (XR_SUCCEEDED(result)) {
            g_markerdetectorml_info.erase(markerDetector);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyMarkerDetectorML(
    XrMarkerDetectorML markerDetector) {
    XrResult test_result = GenValidUsageInputsXrDestroyMarkerDetectorML(markerDetector);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyMarkerDetectorML(markerDetector);
}

XrResult GenValidUsageInputsXrSnapshotMarkerDetectorML(
XrMarkerDetectorML markerDetector,
XrMarkerDetectorSnapshotInfoML* snapshotInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrSnapshotMarkerDetectorML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSnapshotMarkerDetectorML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == snapshotInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSnapshotMarkerDetectorML-snapshotInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSnapshotMarkerDetectorML", objects_info,
                                "Invalid NULL for XrMarkerDetectorSnapshotInfoML \"snapshotInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMarkerDetectorSnapshotInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSnapshotMarkerDetectorML", objects_info,
                                                        false, snapshotInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSnapshotMarkerDetectorML-snapshotInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSnapshotMarkerDetectorML",
                                objects_info,
                                "Command xrSnapshotMarkerDetectorML param snapshotInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSnapshotMarkerDetectorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorSnapshotInfoML* snapshotInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSnapshotMarkerDetectorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorSnapshotInfoML* snapshotInfo) {
    XrResult test_result = GenValidUsageInputsXrSnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSnapshotMarkerDetectorML(markerDetector, snapshotInfo);
}

XrResult GenValidUsageInputsXrGetMarkerDetectorStateML(
XrMarkerDetectorML markerDetector,
XrMarkerDetectorStateML* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerDetectorStateML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerDetectorStateML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerDetectorStateML-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerDetectorStateML", objects_info,
                                "Invalid NULL for XrMarkerDetectorStateML \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMarkerDetectorStateML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetMarkerDetectorStateML", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerDetectorStateML-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerDetectorStateML",
                                objects_info,
                                "Command xrGetMarkerDetectorStateML param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerDetectorStateML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorStateML* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerDetectorStateML(markerDetector, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerDetectorStateML(
    XrMarkerDetectorML markerDetector,
    XrMarkerDetectorStateML* state) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerDetectorStateML(markerDetector, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerDetectorStateML(markerDetector, state);
}

XrResult GenValidUsageInputsXrGetMarkersML(
XrMarkerDetectorML markerDetector,
uint32_t markerCapacityInput,
uint32_t* markerCountOutput,
XrMarkerML* markers) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkersML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkersML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when markerCapacityInput is non-zero
        if (0 != markerCapacityInput && nullptr == markers) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkersML-markers-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkersML",
                                objects_info,
                                "Command xrGetMarkersML param markers is NULL, but markerCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == markerCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkersML-markerCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkersML", objects_info,
                                "Invalid NULL for uint32_t \"markerCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkersML-markerCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetMarkersML-markers-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkersML(
    XrMarkerDetectorML markerDetector,
    uint32_t markerCapacityInput,
    uint32_t* markerCountOutput,
    XrMarkerML* markers) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkersML(
    XrMarkerDetectorML markerDetector,
    uint32_t markerCapacityInput,
    uint32_t* markerCountOutput,
    XrMarkerML* markers) {
    XrResult test_result = GenValidUsageInputsXrGetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
}

XrResult GenValidUsageInputsXrGetMarkerReprojectionErrorML(
XrMarkerDetectorML markerDetector,
XrMarkerML marker,
float* reprojectionErrorMeters) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerReprojectionErrorML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerReprojectionErrorML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == reprojectionErrorMeters) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerReprojectionErrorML-reprojectionErrorMeters-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerReprojectionErrorML", objects_info,
                                "Invalid NULL for float \"reprojectionErrorMeters\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkerReprojectionErrorML-reprojectionErrorMeters-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerReprojectionErrorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* reprojectionErrorMeters) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerReprojectionErrorML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* reprojectionErrorMeters) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
}

XrResult GenValidUsageInputsXrGetMarkerLengthML(
XrMarkerDetectorML markerDetector,
XrMarkerML marker,
float* meters) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerLengthML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerLengthML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == meters) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerLengthML-meters-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerLengthML", objects_info,
                                "Invalid NULL for float \"meters\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkerLengthML-meters-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerLengthML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* meters) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerLengthML(markerDetector, marker, meters);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerLengthML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    float* meters) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerLengthML(markerDetector, marker, meters);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerLengthML(markerDetector, marker, meters);
}

XrResult GenValidUsageInputsXrGetMarkerNumberML(
XrMarkerDetectorML markerDetector,
XrMarkerML marker,
uint64_t* number) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerNumberML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerNumberML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == number) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerNumberML-number-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerNumberML", objects_info,
                                "Invalid NULL for uint64_t \"number\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkerNumberML-number-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerNumberML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint64_t* number) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerNumberML(markerDetector, marker, number);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerNumberML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint64_t* number) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerNumberML(markerDetector, marker, number);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerNumberML(markerDetector, marker, number);
}

XrResult GenValidUsageInputsXrGetMarkerStringML(
XrMarkerDetectorML markerDetector,
XrMarkerML marker,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(markerDetector, XR_OBJECT_TYPE_MARKER_DETECTOR_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrMarkerDetectorMLHandle(&markerDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrMarkerDetectorML handle \"markerDetector\" ";
                oss << HandleToHexString(markerDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetMarkerStringML-markerDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerStringML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerStringML-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerStringML",
                                objects_info,
                                "Command xrGetMarkerStringML param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetMarkerStringML-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetMarkerStringML", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetMarkerStringML-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetMarkerStringML-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetMarkerStringML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_markerdetectorml_info.getWithInstanceInfo(markerDetector);
        GenValidUsageXrHandleInfo *gen_markerdetectorml_info = info_with_instance.first;
        (void)gen_markerdetectorml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetMarkerStringML(
    XrMarkerDetectorML markerDetector,
    XrMarkerML marker,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
}

XrResult GenValidUsageInputsXrCreateMarkerSpaceML(
XrSession session,
const XrMarkerSpaceCreateInfoML* createInfo,
XrSpace* space) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateMarkerSpaceML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceML", objects_info,
                                "Invalid NULL for XrMarkerSpaceCreateInfoML \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMarkerSpaceCreateInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateMarkerSpaceML", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceML-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceML",
                                objects_info,
                                "Command xrCreateMarkerSpaceML param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == space) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateMarkerSpaceML-space-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateMarkerSpaceML", objects_info,
                                "Invalid NULL for XrSpace \"space\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateMarkerSpaceML(
    XrSession session,
    const XrMarkerSpaceCreateInfoML* createInfo,
    XrSpace* space) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateMarkerSpaceML(session, createInfo, space);
        if (XR_SUCCESS == result && nullptr != space) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*space, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateMarkerSpaceML(
    XrSession session,
    const XrMarkerSpaceCreateInfoML* createInfo,
    XrSpace* space) {
    XrResult test_result = GenValidUsageInputsXrCreateMarkerSpaceML(session, createInfo, space);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateMarkerSpaceML(session, createInfo, space);
}


// ---- XR_ML_localization_map extension commands
XrResult GenValidUsageInputsXrEnableLocalizationEventsML(
XrSession session,
const XrLocalizationEnableEventsInfoML * info) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnableLocalizationEventsML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableLocalizationEventsML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnableLocalizationEventsML-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableLocalizationEventsML", objects_info,
                                "Invalid NULL for XrLocalizationEnableEventsInfoML \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrLocalizationEnableEventsInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrEnableLocalizationEventsML", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnableLocalizationEventsML-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableLocalizationEventsML",
                                objects_info,
                                "Command xrEnableLocalizationEventsML param info is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnableLocalizationEventsML(
    XrSession session,
    const XrLocalizationEnableEventsInfoML * info) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnableLocalizationEventsML(session, info);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnableLocalizationEventsML(
    XrSession session,
    const XrLocalizationEnableEventsInfoML * info) {
    XrResult test_result = GenValidUsageInputsXrEnableLocalizationEventsML(session, info);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnableLocalizationEventsML(session, info);
}

XrResult GenValidUsageInputsXrQueryLocalizationMapsML(
XrSession session,
const XrLocalizationMapQueryInfoBaseHeaderML* queryInfo,
uint32_t mapCapacityInput,
uint32_t * mapCountOutput,
XrLocalizationMapML* maps) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrQueryLocalizationMapsML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryLocalizationMapsML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Validate that the base-structure XrLocalizationMapQueryInfoBaseHeaderML is valid
        if (nullptr != queryInfo) {
            xr_result = ValidateXrStruct(gen_instance_info, "xrQueryLocalizationMapsML",
                                                            objects_info, false, queryInfo);
            if (XR_SUCCESS != xr_result) {
                CoreValidLogMessage(gen_instance_info, "VUID-xrQueryLocalizationMapsML-queryInfo-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryLocalizationMapsML",
                                    objects_info,
                                    "Command xrQueryLocalizationMapsML param queryInfo is invalid");
                return xr_result;
            }
        }
        // Optional array must be non-NULL when mapCapacityInput is non-zero
        if (0 != mapCapacityInput && nullptr == maps) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQueryLocalizationMapsML-maps-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryLocalizationMapsML",
                                objects_info,
                                "Command xrQueryLocalizationMapsML param maps is NULL, but mapCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == mapCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQueryLocalizationMapsML-mapCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryLocalizationMapsML", objects_info,
                                "Invalid NULL for uint32_t \"mapCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrQueryLocalizationMapsML-mapCountOutput-parameter" type
        if (maps) {
            for (uint32_t value_maps_inc = 0; value_maps_inc < mapCapacityInput; ++value_maps_inc) {
                // Validate that the structure XrLocalizationMapML is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrQueryLocalizationMapsML", objects_info,
                                                                true, &maps[value_maps_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrQueryLocalizationMapsML-maps-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryLocalizationMapsML",
                                        objects_info,
                                        "Command xrQueryLocalizationMapsML param maps is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrQueryLocalizationMapsML(
    XrSession session,
    const XrLocalizationMapQueryInfoBaseHeaderML* queryInfo,
    uint32_t mapCapacityInput,
    uint32_t * mapCountOutput,
    XrLocalizationMapML* maps) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->QueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrQueryLocalizationMapsML(
    XrSession session,
    const XrLocalizationMapQueryInfoBaseHeaderML* queryInfo,
    uint32_t mapCapacityInput,
    uint32_t * mapCountOutput,
    XrLocalizationMapML* maps) {
    XrResult test_result = GenValidUsageInputsXrQueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrQueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
}

XrResult GenValidUsageInputsXrRequestMapLocalizationML(
XrSession session,
const XrMapLocalizationRequestInfoML* requestInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrRequestMapLocalizationML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestMapLocalizationML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRequestMapLocalizationML-requestInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestMapLocalizationML", objects_info,
                                "Invalid NULL for XrMapLocalizationRequestInfoML \"requestInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrMapLocalizationRequestInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrRequestMapLocalizationML", objects_info,
                                                        true, requestInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRequestMapLocalizationML-requestInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestMapLocalizationML",
                                objects_info,
                                "Command xrRequestMapLocalizationML param requestInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrRequestMapLocalizationML(
    XrSession session,
    const XrMapLocalizationRequestInfoML* requestInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->RequestMapLocalizationML(session, requestInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrRequestMapLocalizationML(
    XrSession session,
    const XrMapLocalizationRequestInfoML* requestInfo) {
    XrResult test_result = GenValidUsageInputsXrRequestMapLocalizationML(session, requestInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrRequestMapLocalizationML(session, requestInfo);
}

XrResult GenValidUsageInputsXrImportLocalizationMapML(
XrSession session,
const XrLocalizationMapImportInfoML* importInfo,
XrUuidEXT* mapUuid) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrImportLocalizationMapML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrImportLocalizationMapML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == importInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrImportLocalizationMapML-importInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrImportLocalizationMapML", objects_info,
                                "Invalid NULL for XrLocalizationMapImportInfoML \"importInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrLocalizationMapImportInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrImportLocalizationMapML", objects_info,
                                                        true, importInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrImportLocalizationMapML-importInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrImportLocalizationMapML",
                                objects_info,
                                "Command xrImportLocalizationMapML param importInfo is invalid");
            return xr_result;
        }
        // NOTE: Can't validate "VUID-xrImportLocalizationMapML-mapUuid-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrImportLocalizationMapML(
    XrSession session,
    const XrLocalizationMapImportInfoML* importInfo,
    XrUuidEXT* mapUuid) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ImportLocalizationMapML(session, importInfo, mapUuid);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrImportLocalizationMapML(
    XrSession session,
    const XrLocalizationMapImportInfoML* importInfo,
    XrUuidEXT* mapUuid) {
    XrResult test_result = GenValidUsageInputsXrImportLocalizationMapML(session, importInfo, mapUuid);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrImportLocalizationMapML(session, importInfo, mapUuid);
}

XrResult GenValidUsageInputsXrCreateExportedLocalizationMapML(
XrSession session,
const XrUuidEXT* mapUuid,
XrExportedLocalizationMapML* map) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateExportedLocalizationMapML-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateExportedLocalizationMapML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == mapUuid) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateExportedLocalizationMapML-mapUuid-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateExportedLocalizationMapML", objects_info,
                                "Invalid NULL for XrUuidEXT \"mapUuid\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrCreateExportedLocalizationMapML-mapUuid-parameter" type
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == map) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateExportedLocalizationMapML-map-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateExportedLocalizationMapML", objects_info,
                                "Invalid NULL for XrExportedLocalizationMapML \"map\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateExportedLocalizationMapML(
    XrSession session,
    const XrUuidEXT* mapUuid,
    XrExportedLocalizationMapML* map) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateExportedLocalizationMapML(session, mapUuid, map);
        if (XR_SUCCESS == result && nullptr != map) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_exportedlocalizationmapml_info.insert(*map, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateExportedLocalizationMapML(
    XrSession session,
    const XrUuidEXT* mapUuid,
    XrExportedLocalizationMapML* map) {
    XrResult test_result = GenValidUsageInputsXrCreateExportedLocalizationMapML(session, mapUuid, map);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateExportedLocalizationMapML(session, mapUuid, map);
}

XrResult GenValidUsageInputsXrDestroyExportedLocalizationMapML(
XrExportedLocalizationMapML map) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(map, XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrExportedLocalizationMapMLHandle(&map);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrExportedLocalizationMapML handle \"map\" ";
                oss << HandleToHexString(map);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyExportedLocalizationMapML-map-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyExportedLocalizationMapML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_exportedlocalizationmapml_info.getWithInstanceInfo(map);
        GenValidUsageXrHandleInfo *gen_exportedlocalizationmapml_info = info_with_instance.first;
        (void)gen_exportedlocalizationmapml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyExportedLocalizationMapML(
    XrExportedLocalizationMapML map) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_exportedlocalizationmapml_info.getWithInstanceInfo(map);
        GenValidUsageXrHandleInfo *gen_exportedlocalizationmapml_info = info_with_instance.first;
        (void)gen_exportedlocalizationmapml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyExportedLocalizationMapML(map);
        if (XR_SUCCEEDED(result)) {
            g_exportedlocalizationmapml_info.erase(map);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyExportedLocalizationMapML(
    XrExportedLocalizationMapML map) {
    XrResult test_result = GenValidUsageInputsXrDestroyExportedLocalizationMapML(map);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyExportedLocalizationMapML(map);
}

XrResult GenValidUsageInputsXrGetExportedLocalizationMapDataML(
XrExportedLocalizationMapML map,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(map, XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrExportedLocalizationMapMLHandle(&map);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrExportedLocalizationMapML handle \"map\" ";
                oss << HandleToHexString(map);
                CoreValidLogMessage(nullptr, "VUID-xrGetExportedLocalizationMapDataML-map-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetExportedLocalizationMapDataML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_exportedlocalizationmapml_info.getWithInstanceInfo(map);
        GenValidUsageXrHandleInfo *gen_exportedlocalizationmapml_info = info_with_instance.first;
        (void)gen_exportedlocalizationmapml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetExportedLocalizationMapDataML-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetExportedLocalizationMapDataML",
                                objects_info,
                                "Command xrGetExportedLocalizationMapDataML param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetExportedLocalizationMapDataML-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetExportedLocalizationMapDataML", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetExportedLocalizationMapDataML-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetExportedLocalizationMapDataML-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetExportedLocalizationMapDataML(
    XrExportedLocalizationMapML map,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_exportedlocalizationmapml_info.getWithInstanceInfo(map);
        GenValidUsageXrHandleInfo *gen_exportedlocalizationmapml_info = info_with_instance.first;
        (void)gen_exportedlocalizationmapml_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetExportedLocalizationMapDataML(
    XrExportedLocalizationMapML map,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
}


// ---- XR_MSFT_spatial_anchor_persistence extension commands
XrResult GenValidUsageInputsXrCreateSpatialAnchorStoreConnectionMSFT(
XrSession session,
XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorStoreConnectionMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorStoreConnectionMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchorStore) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorStoreConnectionMSFT-spatialAnchorStore-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorStoreConnectionMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorStoreConnectionMSFT \"spatialAnchorStore\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorStoreConnectionMSFT(
    XrSession session,
    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
        if (XR_SUCCESS == result && nullptr != spatialAnchorStore) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spatialanchorstoreconnectionmsft_info.insert(*spatialAnchorStore, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorStoreConnectionMSFT(
    XrSession session,
    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
}

XrResult GenValidUsageInputsXrDestroySpatialAnchorStoreConnectionMSFT(
XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(spatialAnchorStore, XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&spatialAnchorStore);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
                oss << HandleToHexString(spatialAnchorStore);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySpatialAnchorStoreConnectionMSFT-spatialAnchorStore-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySpatialAnchorStoreConnectionMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySpatialAnchorStoreConnectionMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
        if (XR_SUCCEEDED(result)) {
            g_spatialanchorstoreconnectionmsft_info.erase(spatialAnchorStore);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySpatialAnchorStoreConnectionMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult test_result = GenValidUsageInputsXrDestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
}

XrResult GenValidUsageInputsXrPersistSpatialAnchorMSFT(
XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
const XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(spatialAnchorStore, XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&spatialAnchorStore);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
                oss << HandleToHexString(spatialAnchorStore);
                CoreValidLogMessage(nullptr, "VUID-xrPersistSpatialAnchorMSFT-spatialAnchorStore-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPersistSpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchorPersistenceInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPersistSpatialAnchorMSFT-spatialAnchorPersistenceInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPersistSpatialAnchorMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorPersistenceInfoMSFT \"spatialAnchorPersistenceInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorPersistenceInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrPersistSpatialAnchorMSFT", objects_info,
                                                        true, spatialAnchorPersistenceInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPersistSpatialAnchorMSFT-spatialAnchorPersistenceInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPersistSpatialAnchorMSFT",
                                objects_info,
                                "Command xrPersistSpatialAnchorMSFT param spatialAnchorPersistenceInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo) {
    XrResult test_result = GenValidUsageInputsXrPersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
}

XrResult GenValidUsageInputsXrEnumeratePersistedSpatialAnchorNamesMSFT(
XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
uint32_t spatialAnchorNameCapacityInput,
uint32_t* spatialAnchorNameCountOutput,
XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(spatialAnchorStore, XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&spatialAnchorStore);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
                oss << HandleToHexString(spatialAnchorStore);
                CoreValidLogMessage(nullptr, "VUID-xrEnumeratePersistedSpatialAnchorNamesMSFT-spatialAnchorStore-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePersistedSpatialAnchorNamesMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when spatialAnchorNameCapacityInput is non-zero
        if (0 != spatialAnchorNameCapacityInput && nullptr == spatialAnchorNames) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumeratePersistedSpatialAnchorNamesMSFT-spatialAnchorNames-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePersistedSpatialAnchorNamesMSFT",
                                objects_info,
                                "Command xrEnumeratePersistedSpatialAnchorNamesMSFT param spatialAnchorNames is NULL, but spatialAnchorNameCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchorNameCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumeratePersistedSpatialAnchorNamesMSFT-spatialAnchorNameCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePersistedSpatialAnchorNamesMSFT", objects_info,
                                "Invalid NULL for uint32_t \"spatialAnchorNameCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumeratePersistedSpatialAnchorNamesMSFT-spatialAnchorNameCountOutput-parameter" type
        if (spatialAnchorNames) {
            for (uint32_t value_spatialanchornames_inc = 0; value_spatialanchornames_inc < spatialAnchorNameCapacityInput; ++value_spatialanchornames_inc) {
                // Validate that the structure XrSpatialAnchorPersistenceNameMSFT is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumeratePersistedSpatialAnchorNamesMSFT", objects_info,
                                                                true, &spatialAnchorNames[value_spatialanchornames_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumeratePersistedSpatialAnchorNamesMSFT-spatialAnchorNames-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePersistedSpatialAnchorNamesMSFT",
                                        objects_info,
                                        "Command xrEnumeratePersistedSpatialAnchorNamesMSFT param spatialAnchorNames is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumeratePersistedSpatialAnchorNamesMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    uint32_t spatialAnchorNameCapacityInput,
    uint32_t* spatialAnchorNameCountOutput,
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumeratePersistedSpatialAnchorNamesMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    uint32_t spatialAnchorNameCapacityInput,
    uint32_t* spatialAnchorNameCountOutput,
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames) {
    XrResult test_result = GenValidUsageInputsXrEnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
}

XrResult GenValidUsageInputsXrCreateSpatialAnchorFromPersistedNameMSFT(
XrSession session,
const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo,
XrSpatialAnchorMSFT* spatialAnchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorFromPersistedNameMSFT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPersistedNameMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchorCreateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFromPersistedNameMSFT-spatialAnchorCreateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPersistedNameMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT \"spatialAnchorCreateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialAnchorFromPersistedNameMSFT", objects_info,
                                                        true, spatialAnchorCreateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFromPersistedNameMSFT-spatialAnchorCreateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPersistedNameMSFT",
                                objects_info,
                                "Command xrCreateSpatialAnchorFromPersistedNameMSFT param spatialAnchorCreateInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorFromPersistedNameMSFT-spatialAnchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorFromPersistedNameMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorMSFT \"spatialAnchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorFromPersistedNameMSFT(
    XrSession session,
    const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo,
    XrSpatialAnchorMSFT* spatialAnchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
        if (XR_SUCCESS == result && nullptr != spatialAnchor) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spatialanchormsft_info.insert(*spatialAnchor, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorFromPersistedNameMSFT(
    XrSession session,
    const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo,
    XrSpatialAnchorMSFT* spatialAnchor) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
}

XrResult GenValidUsageInputsXrUnpersistSpatialAnchorMSFT(
XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
const XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(spatialAnchorStore, XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&spatialAnchorStore);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
                oss << HandleToHexString(spatialAnchorStore);
                CoreValidLogMessage(nullptr, "VUID-xrUnpersistSpatialAnchorMSFT-spatialAnchorStore-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUnpersistSpatialAnchorMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spatialAnchorPersistenceName) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUnpersistSpatialAnchorMSFT-spatialAnchorPersistenceName-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUnpersistSpatialAnchorMSFT", objects_info,
                                "Invalid NULL for XrSpatialAnchorPersistenceNameMSFT \"spatialAnchorPersistenceName\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorPersistenceNameMSFT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrUnpersistSpatialAnchorMSFT", objects_info,
                                                        true, spatialAnchorPersistenceName);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUnpersistSpatialAnchorMSFT-spatialAnchorPersistenceName-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUnpersistSpatialAnchorMSFT",
                                objects_info,
                                "Command xrUnpersistSpatialAnchorMSFT param spatialAnchorPersistenceName is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrUnpersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->UnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrUnpersistSpatialAnchorMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore,
    const XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName) {
    XrResult test_result = GenValidUsageInputsXrUnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrUnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
}

XrResult GenValidUsageInputsXrClearSpatialAnchorStoreMSFT(
XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(spatialAnchorStore, XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpatialAnchorStoreConnectionMSFTHandle(&spatialAnchorStore);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpatialAnchorStoreConnectionMSFT handle \"spatialAnchorStore\" ";
                oss << HandleToHexString(spatialAnchorStore);
                CoreValidLogMessage(nullptr, "VUID-xrClearSpatialAnchorStoreMSFT-spatialAnchorStore-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrClearSpatialAnchorStoreMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrClearSpatialAnchorStoreMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spatialanchorstoreconnectionmsft_info.getWithInstanceInfo(spatialAnchorStore);
        GenValidUsageXrHandleInfo *gen_spatialanchorstoreconnectionmsft_info = info_with_instance.first;
        (void)gen_spatialanchorstoreconnectionmsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrClearSpatialAnchorStoreMSFT(
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore) {
    XrResult test_result = GenValidUsageInputsXrClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrClearSpatialAnchorStoreMSFT(spatialAnchorStore);
}


// ---- XR_MSFT_scene_marker extension commands
XrResult GenValidUsageInputsXrGetSceneMarkerRawDataMSFT(
XrSceneMSFT scene,
const XrUuidMSFT* markerId,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
uint8_t* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrGetSceneMarkerRawDataMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerRawDataMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == markerId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerRawDataMSFT-markerId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerRawDataMSFT", objects_info,
                                "Invalid NULL for XrUuidMSFT \"markerId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSceneMarkerRawDataMSFT-markerId-parameter" type
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerRawDataMSFT-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerRawDataMSFT",
                                objects_info,
                                "Command xrGetSceneMarkerRawDataMSFT param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerRawDataMSFT-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerRawDataMSFT", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSceneMarkerRawDataMSFT-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetSceneMarkerRawDataMSFT-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSceneMarkerRawDataMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSceneMarkerRawDataMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    uint8_t* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
}

XrResult GenValidUsageInputsXrGetSceneMarkerDecodedStringMSFT(
XrSceneMSFT scene,
const XrUuidMSFT* markerId,
uint32_t bufferCapacityInput,
uint32_t* bufferCountOutput,
char* buffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(scene, XR_OBJECT_TYPE_SCENE_MSFT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSceneMSFTHandle(&scene);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSceneMSFT handle \"scene\" ";
                oss << HandleToHexString(scene);
                CoreValidLogMessage(nullptr, "VUID-xrGetSceneMarkerDecodedStringMSFT-scene-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerDecodedStringMSFT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == markerId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerDecodedStringMSFT-markerId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerDecodedStringMSFT", objects_info,
                                "Invalid NULL for XrUuidMSFT \"markerId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSceneMarkerDecodedStringMSFT-markerId-parameter" type
        // Optional array must be non-NULL when bufferCapacityInput is non-zero
        if (0 != bufferCapacityInput && nullptr == buffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerDecodedStringMSFT-buffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerDecodedStringMSFT",
                                objects_info,
                                "Command xrGetSceneMarkerDecodedStringMSFT param buffer is NULL, but bufferCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == bufferCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSceneMarkerDecodedStringMSFT-bufferCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSceneMarkerDecodedStringMSFT", objects_info,
                                "Invalid NULL for uint32_t \"bufferCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSceneMarkerDecodedStringMSFT-bufferCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetSceneMarkerDecodedStringMSFT-buffer-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSceneMarkerDecodedStringMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_scenemsft_info.getWithInstanceInfo(scene);
        GenValidUsageXrHandleInfo *gen_scenemsft_info = info_with_instance.first;
        (void)gen_scenemsft_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSceneMarkerDecodedStringMSFT(
    XrSceneMSFT scene,
    const XrUuidMSFT* markerId,
    uint32_t bufferCapacityInput,
    uint32_t* bufferCountOutput,
    char* buffer) {
    XrResult test_result = GenValidUsageInputsXrGetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
}


// ---- XR_FB_spatial_entity_query extension commands
XrResult GenValidUsageInputsXrQuerySpacesFB(
XrSession session,
const XrSpaceQueryInfoBaseHeaderFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrQuerySpacesFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySpacesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySpacesFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySpacesFB", objects_info,
                                "Invalid NULL for XrSpaceQueryInfoBaseHeaderFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate if XrSpaceQueryInfoBaseHeaderFB is a child structure of type XrSpaceQueryInfoFB and it is valid
        {
            const XrSpaceQueryInfoFB* new_spacequeryinfofb_value = reinterpret_cast<const XrSpaceQueryInfoFB*>(info);
            if (new_spacequeryinfofb_value->type == XR_TYPE_SPACE_QUERY_INFO_FB) {
                xr_result = ValidateXrStruct(gen_instance_info, "xrQuerySpacesFB",
                                                                objects_info,false, new_spacequeryinfofb_value);
                if (XR_SUCCESS != xr_result) {
                    std::string error_message = "Command xrQuerySpacesFB param info";
                    error_message += " is invalid";
                    CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySpacesFB-info-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySpacesFB",
                                        objects_info,
                                        error_message);
                    return XR_ERROR_VALIDATION_FAILURE;
                }
            }
        }
        // Validate that the base-structure XrSpaceQueryInfoBaseHeaderFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrQuerySpacesFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySpacesFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySpacesFB",
                                objects_info,
                                "Command xrQuerySpacesFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQuerySpacesFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQuerySpacesFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrQuerySpacesFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrQuerySpacesFB(
    XrSession session,
    const XrSpaceQueryInfoBaseHeaderFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->QuerySpacesFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrQuerySpacesFB(
    XrSession session,
    const XrSpaceQueryInfoBaseHeaderFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrQuerySpacesFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrQuerySpacesFB(session, info, requestId);
}

XrResult GenValidUsageInputsXrRetrieveSpaceQueryResultsFB(
XrSession session,
XrAsyncRequestIdFB requestId,
XrSpaceQueryResultsFB* results) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrRetrieveSpaceQueryResultsFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRetrieveSpaceQueryResultsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == results) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRetrieveSpaceQueryResultsFB-results-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRetrieveSpaceQueryResultsFB", objects_info,
                                "Invalid NULL for XrSpaceQueryResultsFB \"results\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceQueryResultsFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrRetrieveSpaceQueryResultsFB", objects_info,
                                                        false, results);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRetrieveSpaceQueryResultsFB-results-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRetrieveSpaceQueryResultsFB",
                                objects_info,
                                "Command xrRetrieveSpaceQueryResultsFB param results is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrRetrieveSpaceQueryResultsFB(
    XrSession session,
    XrAsyncRequestIdFB requestId,
    XrSpaceQueryResultsFB* results) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->RetrieveSpaceQueryResultsFB(session, requestId, results);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrRetrieveSpaceQueryResultsFB(
    XrSession session,
    XrAsyncRequestIdFB requestId,
    XrSpaceQueryResultsFB* results) {
    XrResult test_result = GenValidUsageInputsXrRetrieveSpaceQueryResultsFB(session, requestId, results);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrRetrieveSpaceQueryResultsFB(session, requestId, results);
}


// ---- XR_FB_spatial_entity_storage extension commands
XrResult GenValidUsageInputsXrSaveSpaceFB(
XrSession session,
const XrSpaceSaveInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSaveSpaceFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceFB", objects_info,
                                "Invalid NULL for XrSpaceSaveInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceSaveInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSaveSpaceFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceFB",
                                objects_info,
                                "Command xrSaveSpaceFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrSaveSpaceFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSaveSpaceFB(
    XrSession session,
    const XrSpaceSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SaveSpaceFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSaveSpaceFB(
    XrSession session,
    const XrSpaceSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrSaveSpaceFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSaveSpaceFB(session, info, requestId);
}

XrResult GenValidUsageInputsXrEraseSpaceFB(
XrSession session,
const XrSpaceEraseInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEraseSpaceFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEraseSpaceFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEraseSpaceFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEraseSpaceFB", objects_info,
                                "Invalid NULL for XrSpaceEraseInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceEraseInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrEraseSpaceFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEraseSpaceFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEraseSpaceFB",
                                objects_info,
                                "Command xrEraseSpaceFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEraseSpaceFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEraseSpaceFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEraseSpaceFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEraseSpaceFB(
    XrSession session,
    const XrSpaceEraseInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EraseSpaceFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEraseSpaceFB(
    XrSession session,
    const XrSpaceEraseInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrEraseSpaceFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEraseSpaceFB(session, info, requestId);
}


// ---- XR_OCULUS_audio_device_guid extension commands
#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrGetAudioOutputDeviceGuidOculus(
XrInstance instance,
wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetAudioOutputDeviceGuidOculus-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetAudioOutputDeviceGuidOculus",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetAudioOutputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetAudioOutputDeviceGuidOculus(instance, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetAudioOutputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult test_result = GenValidUsageInputsXrGetAudioOutputDeviceGuidOculus(instance, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetAudioOutputDeviceGuidOculus(instance, buffer);
}

#endif // defined(XR_USE_PLATFORM_WIN32)

#if defined(XR_USE_PLATFORM_WIN32)

XrResult GenValidUsageInputsXrGetAudioInputDeviceGuidOculus(
XrInstance instance,
wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrGetAudioInputDeviceGuidOculus-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetAudioInputDeviceGuidOculus",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetAudioInputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->GetAudioInputDeviceGuidOculus(instance, buffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetAudioInputDeviceGuidOculus(
    XrInstance instance,
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]) {
    XrResult test_result = GenValidUsageInputsXrGetAudioInputDeviceGuidOculus(instance, buffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetAudioInputDeviceGuidOculus(instance, buffer);
}

#endif // defined(XR_USE_PLATFORM_WIN32)


// ---- XR_FB_spatial_entity_sharing extension commands
XrResult GenValidUsageInputsXrShareSpacesFB(
XrSession session,
const XrSpaceShareInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrShareSpacesFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrShareSpacesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrShareSpacesFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrShareSpacesFB", objects_info,
                                "Invalid NULL for XrSpaceShareInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceShareInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrShareSpacesFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrShareSpacesFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrShareSpacesFB",
                                objects_info,
                                "Command xrShareSpacesFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrShareSpacesFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrShareSpacesFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrShareSpacesFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrShareSpacesFB(
    XrSession session,
    const XrSpaceShareInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ShareSpacesFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrShareSpacesFB(
    XrSession session,
    const XrSpaceShareInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrShareSpacesFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrShareSpacesFB(session, info, requestId);
}


// ---- XR_FB_scene extension commands
XrResult GenValidUsageInputsXrGetSpaceBoundingBox2DFB(
XrSession session,
XrSpace space,
XrRect2Df* boundingBox2DOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceBoundingBox2DFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox2DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox2DFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox2DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox2DFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox2DFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == boundingBox2DOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox2DFB-boundingBox2DOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox2DFB", objects_info,
                                "Invalid NULL for XrRect2Df \"boundingBox2DOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSpaceBoundingBox2DFB-boundingBox2DOutput-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceBoundingBox2DFB(
    XrSession session,
    XrSpace space,
    XrRect2Df* boundingBox2DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceBoundingBox2DFB(
    XrSession session,
    XrSpace space,
    XrRect2Df* boundingBox2DOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
}

XrResult GenValidUsageInputsXrGetSpaceBoundingBox3DFB(
XrSession session,
XrSpace space,
XrRect3DfFB* boundingBox3DOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceBoundingBox3DFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox3DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox3DFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox3DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox3DFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox3DFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == boundingBox3DOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundingBox3DFB-boundingBox3DOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundingBox3DFB", objects_info,
                                "Invalid NULL for XrRect3DfFB \"boundingBox3DOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSpaceBoundingBox3DFB-boundingBox3DOutput-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceBoundingBox3DFB(
    XrSession session,
    XrSpace space,
    XrRect3DfFB* boundingBox3DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceBoundingBox3DFB(
    XrSession session,
    XrSpace space,
    XrRect3DfFB* boundingBox3DOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
}

XrResult GenValidUsageInputsXrGetSpaceSemanticLabelsFB(
XrSession session,
XrSpace space,
XrSemanticLabelsFB* semanticLabelsOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceSemanticLabelsFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceSemanticLabelsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceSemanticLabelsFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceSemanticLabelsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceSemanticLabelsFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceSemanticLabelsFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == semanticLabelsOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceSemanticLabelsFB-semanticLabelsOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceSemanticLabelsFB", objects_info,
                                "Invalid NULL for XrSemanticLabelsFB \"semanticLabelsOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSemanticLabelsFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceSemanticLabelsFB", objects_info,
                                                        false, semanticLabelsOutput);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceSemanticLabelsFB-semanticLabelsOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceSemanticLabelsFB",
                                objects_info,
                                "Command xrGetSpaceSemanticLabelsFB param semanticLabelsOutput is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceSemanticLabelsFB(
    XrSession session,
    XrSpace space,
    XrSemanticLabelsFB* semanticLabelsOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceSemanticLabelsFB(
    XrSession session,
    XrSpace space,
    XrSemanticLabelsFB* semanticLabelsOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
}

XrResult GenValidUsageInputsXrGetSpaceBoundary2DFB(
XrSession session,
XrSpace space,
XrBoundary2DFB* boundary2DOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceBoundary2DFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundary2DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundary2DFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundary2DFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundary2DFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundary2DFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == boundary2DOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundary2DFB-boundary2DOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundary2DFB", objects_info,
                                "Invalid NULL for XrBoundary2DFB \"boundary2DOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrBoundary2DFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceBoundary2DFB", objects_info,
                                                        false, boundary2DOutput);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceBoundary2DFB-boundary2DOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceBoundary2DFB",
                                objects_info,
                                "Command xrGetSpaceBoundary2DFB param boundary2DOutput is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceBoundary2DFB(
    XrSession session,
    XrSpace space,
    XrBoundary2DFB* boundary2DOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceBoundary2DFB(session, space, boundary2DOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceBoundary2DFB(
    XrSession session,
    XrSpace space,
    XrBoundary2DFB* boundary2DOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceBoundary2DFB(session, space, boundary2DOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceBoundary2DFB(session, space, boundary2DOutput);
}

XrResult GenValidUsageInputsXrGetSpaceRoomLayoutFB(
XrSession session,
XrSpace space,
XrRoomLayoutFB* roomLayoutOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceRoomLayoutFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceRoomLayoutFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceRoomLayoutFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceRoomLayoutFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceRoomLayoutFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceRoomLayoutFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == roomLayoutOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceRoomLayoutFB-roomLayoutOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceRoomLayoutFB", objects_info,
                                "Invalid NULL for XrRoomLayoutFB \"roomLayoutOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRoomLayoutFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceRoomLayoutFB", objects_info,
                                                        false, roomLayoutOutput);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceRoomLayoutFB-roomLayoutOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceRoomLayoutFB",
                                objects_info,
                                "Command xrGetSpaceRoomLayoutFB param roomLayoutOutput is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceRoomLayoutFB(
    XrSession session,
    XrSpace space,
    XrRoomLayoutFB* roomLayoutOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceRoomLayoutFB(
    XrSession session,
    XrSpace space,
    XrRoomLayoutFB* roomLayoutOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
}


// ---- XR_ALMALENCE_digital_lens_control extension commands
XrResult GenValidUsageInputsXrSetDigitalLensControlALMALENCE(
XrSession session,
const XrDigitalLensControlALMALENCE* digitalLensControl) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetDigitalLensControlALMALENCE-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDigitalLensControlALMALENCE",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == digitalLensControl) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetDigitalLensControlALMALENCE-digitalLensControl-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDigitalLensControlALMALENCE", objects_info,
                                "Invalid NULL for XrDigitalLensControlALMALENCE \"digitalLensControl\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrDigitalLensControlALMALENCE is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSetDigitalLensControlALMALENCE", objects_info,
                                                        true, digitalLensControl);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetDigitalLensControlALMALENCE-digitalLensControl-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetDigitalLensControlALMALENCE",
                                objects_info,
                                "Command xrSetDigitalLensControlALMALENCE param digitalLensControl is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetDigitalLensControlALMALENCE(
    XrSession session,
    const XrDigitalLensControlALMALENCE* digitalLensControl) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetDigitalLensControlALMALENCE(session, digitalLensControl);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetDigitalLensControlALMALENCE(
    XrSession session,
    const XrDigitalLensControlALMALENCE* digitalLensControl) {
    XrResult test_result = GenValidUsageInputsXrSetDigitalLensControlALMALENCE(session, digitalLensControl);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetDigitalLensControlALMALENCE(session, digitalLensControl);
}


// ---- XR_FB_scene_capture extension commands
XrResult GenValidUsageInputsXrRequestSceneCaptureFB(
XrSession session,
const XrSceneCaptureRequestInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrRequestSceneCaptureFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestSceneCaptureFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRequestSceneCaptureFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestSceneCaptureFB", objects_info,
                                "Invalid NULL for XrSceneCaptureRequestInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSceneCaptureRequestInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrRequestSceneCaptureFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRequestSceneCaptureFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestSceneCaptureFB",
                                objects_info,
                                "Command xrRequestSceneCaptureFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrRequestSceneCaptureFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrRequestSceneCaptureFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrRequestSceneCaptureFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrRequestSceneCaptureFB(
    XrSession session,
    const XrSceneCaptureRequestInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->RequestSceneCaptureFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrRequestSceneCaptureFB(
    XrSession session,
    const XrSceneCaptureRequestInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrRequestSceneCaptureFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrRequestSceneCaptureFB(session, info, requestId);
}


// ---- XR_FB_spatial_entity_container extension commands
XrResult GenValidUsageInputsXrGetSpaceContainerFB(
XrSession session,
XrSpace space,
XrSpaceContainerFB* spaceContainerOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceContainerFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceContainerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceContainerFB-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceContainerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_SPACE,  MakeHandleGeneric(space), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrSpace ";
            oss_error << HandleToHexString(space);
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceContainerFB-space-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceContainerFB",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == spaceContainerOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceContainerFB-spaceContainerOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceContainerFB", objects_info,
                                "Invalid NULL for XrSpaceContainerFB \"spaceContainerOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceContainerFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceContainerFB", objects_info,
                                                        false, spaceContainerOutput);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceContainerFB-spaceContainerOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceContainerFB",
                                objects_info,
                                "Command xrGetSpaceContainerFB param spaceContainerOutput is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceContainerFB(
    XrSession session,
    XrSpace space,
    XrSpaceContainerFB* spaceContainerOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceContainerFB(session, space, spaceContainerOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceContainerFB(
    XrSession session,
    XrSpace space,
    XrSpaceContainerFB* spaceContainerOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceContainerFB(session, space, spaceContainerOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceContainerFB(session, space, spaceContainerOutput);
}


// ---- XR_META_foveation_eye_tracked extension commands
XrResult GenValidUsageInputsXrGetFoveationEyeTrackedStateMETA(
XrSession session,
XrFoveationEyeTrackedStateMETA* foveationState) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetFoveationEyeTrackedStateMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFoveationEyeTrackedStateMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == foveationState) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFoveationEyeTrackedStateMETA-foveationState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFoveationEyeTrackedStateMETA", objects_info,
                                "Invalid NULL for XrFoveationEyeTrackedStateMETA \"foveationState\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFoveationEyeTrackedStateMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFoveationEyeTrackedStateMETA", objects_info,
                                                        false, foveationState);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFoveationEyeTrackedStateMETA-foveationState-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFoveationEyeTrackedStateMETA",
                                objects_info,
                                "Command xrGetFoveationEyeTrackedStateMETA param foveationState is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetFoveationEyeTrackedStateMETA(
    XrSession session,
    XrFoveationEyeTrackedStateMETA* foveationState) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetFoveationEyeTrackedStateMETA(session, foveationState);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetFoveationEyeTrackedStateMETA(
    XrSession session,
    XrFoveationEyeTrackedStateMETA* foveationState) {
    XrResult test_result = GenValidUsageInputsXrGetFoveationEyeTrackedStateMETA(session, foveationState);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetFoveationEyeTrackedStateMETA(session, foveationState);
}


// ---- XR_FB_face_tracking extension commands
XrResult GenValidUsageInputsXrCreateFaceTrackerFB(
XrSession session,
const XrFaceTrackerCreateInfoFB* createInfo,
XrFaceTrackerFB* faceTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateFaceTrackerFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTrackerFB", objects_info,
                                "Invalid NULL for XrFaceTrackerCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceTrackerCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateFaceTrackerFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTrackerFB",
                                objects_info,
                                "Command xrCreateFaceTrackerFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == faceTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTrackerFB-faceTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTrackerFB", objects_info,
                                "Invalid NULL for XrFaceTrackerFB \"faceTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateFaceTrackerFB(
    XrSession session,
    const XrFaceTrackerCreateInfoFB* createInfo,
    XrFaceTrackerFB* faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateFaceTrackerFB(session, createInfo, faceTracker);
        if (XR_SUCCESS == result && nullptr != faceTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_facetrackerfb_info.insert(*faceTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateFaceTrackerFB(
    XrSession session,
    const XrFaceTrackerCreateInfoFB* createInfo,
    XrFaceTrackerFB* faceTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateFaceTrackerFB(session, createInfo, faceTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateFaceTrackerFB(session, createInfo, faceTracker);
}

XrResult GenValidUsageInputsXrDestroyFaceTrackerFB(
XrFaceTrackerFB faceTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(faceTracker, XR_OBJECT_TYPE_FACE_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFaceTrackerFBHandle(&faceTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFaceTrackerFB handle \"faceTracker\" ";
                oss << HandleToHexString(faceTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyFaceTrackerFB-faceTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyFaceTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facetrackerfb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetrackerfb_info = info_with_instance.first;
        (void)gen_facetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyFaceTrackerFB(
    XrFaceTrackerFB faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facetrackerfb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetrackerfb_info = info_with_instance.first;
        (void)gen_facetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyFaceTrackerFB(faceTracker);
        if (XR_SUCCEEDED(result)) {
            g_facetrackerfb_info.erase(faceTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyFaceTrackerFB(
    XrFaceTrackerFB faceTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyFaceTrackerFB(faceTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyFaceTrackerFB(faceTracker);
}

XrResult GenValidUsageInputsXrGetFaceExpressionWeightsFB(
XrFaceTrackerFB faceTracker,
const XrFaceExpressionInfoFB* expressionInfo,
XrFaceExpressionWeightsFB* expressionWeights) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(faceTracker, XR_OBJECT_TYPE_FACE_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFaceTrackerFBHandle(&faceTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFaceTrackerFB handle \"faceTracker\" ";
                oss << HandleToHexString(faceTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetFaceExpressionWeightsFB-faceTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeightsFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facetrackerfb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetrackerfb_info = info_with_instance.first;
        (void)gen_facetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == expressionInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeightsFB-expressionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeightsFB", objects_info,
                                "Invalid NULL for XrFaceExpressionInfoFB \"expressionInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceExpressionInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFaceExpressionWeightsFB", objects_info,
                                                        true, expressionInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeightsFB-expressionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeightsFB",
                                objects_info,
                                "Command xrGetFaceExpressionWeightsFB param expressionInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == expressionWeights) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeightsFB-expressionWeights-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeightsFB", objects_info,
                                "Invalid NULL for XrFaceExpressionWeightsFB \"expressionWeights\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceExpressionWeightsFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFaceExpressionWeightsFB", objects_info,
                                                        false, expressionWeights);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeightsFB-expressionWeights-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeightsFB",
                                objects_info,
                                "Command xrGetFaceExpressionWeightsFB param expressionWeights is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetFaceExpressionWeightsFB(
    XrFaceTrackerFB faceTracker,
    const XrFaceExpressionInfoFB* expressionInfo,
    XrFaceExpressionWeightsFB* expressionWeights) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facetrackerfb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetrackerfb_info = info_with_instance.first;
        (void)gen_facetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetFaceExpressionWeightsFB(
    XrFaceTrackerFB faceTracker,
    const XrFaceExpressionInfoFB* expressionInfo,
    XrFaceExpressionWeightsFB* expressionWeights) {
    XrResult test_result = GenValidUsageInputsXrGetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
}


// ---- XR_FB_eye_tracking_social extension commands
XrResult GenValidUsageInputsXrCreateEyeTrackerFB(
XrSession session,
const XrEyeTrackerCreateInfoFB* createInfo,
XrEyeTrackerFB* eyeTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateEyeTrackerFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateEyeTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateEyeTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateEyeTrackerFB", objects_info,
                                "Invalid NULL for XrEyeTrackerCreateInfoFB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrEyeTrackerCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateEyeTrackerFB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateEyeTrackerFB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateEyeTrackerFB",
                                objects_info,
                                "Command xrCreateEyeTrackerFB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == eyeTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateEyeTrackerFB-eyeTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateEyeTrackerFB", objects_info,
                                "Invalid NULL for XrEyeTrackerFB \"eyeTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateEyeTrackerFB(
    XrSession session,
    const XrEyeTrackerCreateInfoFB* createInfo,
    XrEyeTrackerFB* eyeTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateEyeTrackerFB(session, createInfo, eyeTracker);
        if (XR_SUCCESS == result && nullptr != eyeTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_eyetrackerfb_info.insert(*eyeTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateEyeTrackerFB(
    XrSession session,
    const XrEyeTrackerCreateInfoFB* createInfo,
    XrEyeTrackerFB* eyeTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateEyeTrackerFB(session, createInfo, eyeTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateEyeTrackerFB(session, createInfo, eyeTracker);
}

XrResult GenValidUsageInputsXrDestroyEyeTrackerFB(
XrEyeTrackerFB eyeTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(eyeTracker, XR_OBJECT_TYPE_EYE_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrEyeTrackerFBHandle(&eyeTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrEyeTrackerFB handle \"eyeTracker\" ";
                oss << HandleToHexString(eyeTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyEyeTrackerFB-eyeTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyEyeTrackerFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_eyetrackerfb_info.getWithInstanceInfo(eyeTracker);
        GenValidUsageXrHandleInfo *gen_eyetrackerfb_info = info_with_instance.first;
        (void)gen_eyetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyEyeTrackerFB(
    XrEyeTrackerFB eyeTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_eyetrackerfb_info.getWithInstanceInfo(eyeTracker);
        GenValidUsageXrHandleInfo *gen_eyetrackerfb_info = info_with_instance.first;
        (void)gen_eyetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyEyeTrackerFB(eyeTracker);
        if (XR_SUCCEEDED(result)) {
            g_eyetrackerfb_info.erase(eyeTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyEyeTrackerFB(
    XrEyeTrackerFB eyeTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyEyeTrackerFB(eyeTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyEyeTrackerFB(eyeTracker);
}

XrResult GenValidUsageInputsXrGetEyeGazesFB(
XrEyeTrackerFB eyeTracker,
const XrEyeGazesInfoFB* gazeInfo,
XrEyeGazesFB* eyeGazes) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(eyeTracker, XR_OBJECT_TYPE_EYE_TRACKER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrEyeTrackerFBHandle(&eyeTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrEyeTrackerFB handle \"eyeTracker\" ";
                oss << HandleToHexString(eyeTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetEyeGazesFB-eyeTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetEyeGazesFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_eyetrackerfb_info.getWithInstanceInfo(eyeTracker);
        GenValidUsageXrHandleInfo *gen_eyetrackerfb_info = info_with_instance.first;
        (void)gen_eyetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == gazeInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetEyeGazesFB-gazeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetEyeGazesFB", objects_info,
                                "Invalid NULL for XrEyeGazesInfoFB \"gazeInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrEyeGazesInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetEyeGazesFB", objects_info,
                                                        true, gazeInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetEyeGazesFB-gazeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetEyeGazesFB",
                                objects_info,
                                "Command xrGetEyeGazesFB param gazeInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == eyeGazes) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetEyeGazesFB-eyeGazes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetEyeGazesFB", objects_info,
                                "Invalid NULL for XrEyeGazesFB \"eyeGazes\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrEyeGazesFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetEyeGazesFB", objects_info,
                                                        false, eyeGazes);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetEyeGazesFB-eyeGazes-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetEyeGazesFB",
                                objects_info,
                                "Command xrGetEyeGazesFB param eyeGazes is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetEyeGazesFB(
    XrEyeTrackerFB eyeTracker,
    const XrEyeGazesInfoFB* gazeInfo,
    XrEyeGazesFB* eyeGazes) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_eyetrackerfb_info.getWithInstanceInfo(eyeTracker);
        GenValidUsageXrHandleInfo *gen_eyetrackerfb_info = info_with_instance.first;
        (void)gen_eyetrackerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetEyeGazesFB(
    XrEyeTrackerFB eyeTracker,
    const XrEyeGazesInfoFB* gazeInfo,
    XrEyeGazesFB* eyeGazes) {
    XrResult test_result = GenValidUsageInputsXrGetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
}


// ---- XR_FB_passthrough_keyboard_hands extension commands
XrResult GenValidUsageInputsXrPassthroughLayerSetKeyboardHandsIntensityFB(
XrPassthroughLayerFB layer,
const XrPassthroughKeyboardHandsIntensityFB* intensity) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(layer, XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughLayerFBHandle(&layer);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughLayerFB handle \"layer\" ";
                oss << HandleToHexString(layer);
                CoreValidLogMessage(nullptr, "VUID-xrPassthroughLayerSetKeyboardHandsIntensityFB-layer-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetKeyboardHandsIntensityFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == intensity) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPassthroughLayerSetKeyboardHandsIntensityFB-intensity-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetKeyboardHandsIntensityFB", objects_info,
                                "Invalid NULL for XrPassthroughKeyboardHandsIntensityFB \"intensity\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughKeyboardHandsIntensityFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrPassthroughLayerSetKeyboardHandsIntensityFB", objects_info,
                                                        true, intensity);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrPassthroughLayerSetKeyboardHandsIntensityFB-intensity-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrPassthroughLayerSetKeyboardHandsIntensityFB",
                                objects_info,
                                "Command xrPassthroughLayerSetKeyboardHandsIntensityFB param intensity is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrPassthroughLayerSetKeyboardHandsIntensityFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughKeyboardHandsIntensityFB* intensity) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughlayerfb_info.getWithInstanceInfo(layer);
        GenValidUsageXrHandleInfo *gen_passthroughlayerfb_info = info_with_instance.first;
        (void)gen_passthroughlayerfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->PassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrPassthroughLayerSetKeyboardHandsIntensityFB(
    XrPassthroughLayerFB layer,
    const XrPassthroughKeyboardHandsIntensityFB* intensity) {
    XrResult test_result = GenValidUsageInputsXrPassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrPassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
}


// ---- XR_FB_haptic_pcm extension commands
XrResult GenValidUsageInputsXrGetDeviceSampleRateFB(
XrSession session,
const XrHapticActionInfo* hapticActionInfo,
XrDevicePcmSampleRateGetInfoFB* deviceSampleRate) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetDeviceSampleRateFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDeviceSampleRateFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == hapticActionInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetDeviceSampleRateFB-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDeviceSampleRateFB", objects_info,
                                "Invalid NULL for XrHapticActionInfo \"hapticActionInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrHapticActionInfo is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetDeviceSampleRateFB", objects_info,
                                                        true, hapticActionInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetDeviceSampleRateFB-hapticActionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDeviceSampleRateFB",
                                objects_info,
                                "Command xrGetDeviceSampleRateFB param hapticActionInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == deviceSampleRate) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetDeviceSampleRateFB-deviceSampleRate-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetDeviceSampleRateFB", objects_info,
                                "Invalid NULL for XrDevicePcmSampleRateGetInfoFB \"deviceSampleRate\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetDeviceSampleRateFB-deviceSampleRate-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetDeviceSampleRateFB(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetDeviceSampleRateFB(
    XrSession session,
    const XrHapticActionInfo* hapticActionInfo,
    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate) {
    XrResult test_result = GenValidUsageInputsXrGetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
}


// ---- XR_META_passthrough_preferences extension commands
XrResult GenValidUsageInputsXrGetPassthroughPreferencesMETA(
XrSession session,
XrPassthroughPreferencesMETA* preferences) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetPassthroughPreferencesMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPassthroughPreferencesMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == preferences) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPassthroughPreferencesMETA-preferences-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPassthroughPreferencesMETA", objects_info,
                                "Invalid NULL for XrPassthroughPreferencesMETA \"preferences\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughPreferencesMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetPassthroughPreferencesMETA", objects_info,
                                                        false, preferences);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPassthroughPreferencesMETA-preferences-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPassthroughPreferencesMETA",
                                objects_info,
                                "Command xrGetPassthroughPreferencesMETA param preferences is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetPassthroughPreferencesMETA(
    XrSession session,
    XrPassthroughPreferencesMETA* preferences) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetPassthroughPreferencesMETA(session, preferences);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetPassthroughPreferencesMETA(
    XrSession session,
    XrPassthroughPreferencesMETA* preferences) {
    XrResult test_result = GenValidUsageInputsXrGetPassthroughPreferencesMETA(session, preferences);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetPassthroughPreferencesMETA(session, preferences);
}


// ---- XR_META_virtual_keyboard extension commands
XrResult GenValidUsageInputsXrCreateVirtualKeyboardMETA(
XrSession session,
const XrVirtualKeyboardCreateInfoMETA* createInfo,
XrVirtualKeyboardMETA* keyboard) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateVirtualKeyboardMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardCreateInfoMETA \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardCreateInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateVirtualKeyboardMETA", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardMETA",
                                objects_info,
                                "Command xrCreateVirtualKeyboardMETA param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == keyboard) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardMETA-keyboard-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardMETA \"keyboard\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateVirtualKeyboardMETA(
    XrSession session,
    const XrVirtualKeyboardCreateInfoMETA* createInfo,
    XrVirtualKeyboardMETA* keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateVirtualKeyboardMETA(session, createInfo, keyboard);
        if (XR_SUCCESS == result && nullptr != keyboard) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_virtualkeyboardmeta_info.insert(*keyboard, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateVirtualKeyboardMETA(
    XrSession session,
    const XrVirtualKeyboardCreateInfoMETA* createInfo,
    XrVirtualKeyboardMETA* keyboard) {
    XrResult test_result = GenValidUsageInputsXrCreateVirtualKeyboardMETA(session, createInfo, keyboard);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateVirtualKeyboardMETA(session, createInfo, keyboard);
}

XrResult GenValidUsageInputsXrDestroyVirtualKeyboardMETA(
XrVirtualKeyboardMETA keyboard) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyVirtualKeyboardMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyVirtualKeyboardMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyVirtualKeyboardMETA(
    XrVirtualKeyboardMETA keyboard) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyVirtualKeyboardMETA(keyboard);
        if (XR_SUCCEEDED(result)) {
            g_virtualkeyboardmeta_info.erase(keyboard);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyVirtualKeyboardMETA(
    XrVirtualKeyboardMETA keyboard) {
    XrResult test_result = GenValidUsageInputsXrDestroyVirtualKeyboardMETA(keyboard);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyVirtualKeyboardMETA(keyboard);
}

XrResult GenValidUsageInputsXrCreateVirtualKeyboardSpaceMETA(
XrSession session,
XrVirtualKeyboardMETA keyboard,
const XrVirtualKeyboardSpaceCreateInfoMETA* createInfo,
XrSpace* keyboardSpace) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateVirtualKeyboardSpaceMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);
        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardSpaceMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        // Verify that the handles share a common ancestry
        if (!VerifyXrParent(XR_OBJECT_TYPE_SESSION,  MakeHandleGeneric(session),
                    XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META,  MakeHandleGeneric(keyboard), true)) {
            std::ostringstream oss_error;
            oss_error << "XrSession " << HandleToHexString(session);
            oss_error << " must be a parent to XrVirtualKeyboardMETA ";
            oss_error << HandleToHexString(keyboard);
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardSpaceMETA-keyboard-parent",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA",
                                objects_info, oss_error.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardSpaceMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardSpaceCreateInfoMETA \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardSpaceCreateInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateVirtualKeyboardSpaceMETA", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardSpaceMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA",
                                objects_info,
                                "Command xrCreateVirtualKeyboardSpaceMETA param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == keyboardSpace) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateVirtualKeyboardSpaceMETA-keyboardSpace-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateVirtualKeyboardSpaceMETA", objects_info,
                                "Invalid NULL for XrSpace \"keyboardSpace\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateVirtualKeyboardSpaceMETA(
    XrSession session,
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardSpaceCreateInfoMETA* createInfo,
    XrSpace* keyboardSpace) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
        if (XR_SUCCESS == result && nullptr != keyboardSpace) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*keyboardSpace, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateVirtualKeyboardSpaceMETA(
    XrSession session,
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardSpaceCreateInfoMETA* createInfo,
    XrSpace* keyboardSpace) {
    XrResult test_result = GenValidUsageInputsXrCreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
}

XrResult GenValidUsageInputsXrSuggestVirtualKeyboardLocationMETA(
XrVirtualKeyboardMETA keyboard,
const XrVirtualKeyboardLocationInfoMETA* locationInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrSuggestVirtualKeyboardLocationMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestVirtualKeyboardLocationMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locationInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSuggestVirtualKeyboardLocationMETA-locationInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestVirtualKeyboardLocationMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardLocationInfoMETA \"locationInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardLocationInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSuggestVirtualKeyboardLocationMETA", objects_info,
                                                        true, locationInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSuggestVirtualKeyboardLocationMETA-locationInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSuggestVirtualKeyboardLocationMETA",
                                objects_info,
                                "Command xrSuggestVirtualKeyboardLocationMETA param locationInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSuggestVirtualKeyboardLocationMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardLocationInfoMETA* locationInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSuggestVirtualKeyboardLocationMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardLocationInfoMETA* locationInfo) {
    XrResult test_result = GenValidUsageInputsXrSuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
}

XrResult GenValidUsageInputsXrGetVirtualKeyboardScaleMETA(
XrVirtualKeyboardMETA keyboard,
float* scale) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrGetVirtualKeyboardScaleMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardScaleMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == scale) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardScaleMETA-scale-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardScaleMETA", objects_info,
                                "Invalid NULL for float \"scale\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVirtualKeyboardScaleMETA-scale-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVirtualKeyboardScaleMETA(
    XrVirtualKeyboardMETA keyboard,
    float* scale) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetVirtualKeyboardScaleMETA(keyboard, scale);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVirtualKeyboardScaleMETA(
    XrVirtualKeyboardMETA keyboard,
    float* scale) {
    XrResult test_result = GenValidUsageInputsXrGetVirtualKeyboardScaleMETA(keyboard, scale);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVirtualKeyboardScaleMETA(keyboard, scale);
}

XrResult GenValidUsageInputsXrSetVirtualKeyboardModelVisibilityMETA(
XrVirtualKeyboardMETA keyboard,
const XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrSetVirtualKeyboardModelVisibilityMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetVirtualKeyboardModelVisibilityMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == modelVisibility) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetVirtualKeyboardModelVisibilityMETA-modelVisibility-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetVirtualKeyboardModelVisibilityMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardModelVisibilitySetInfoMETA \"modelVisibility\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardModelVisibilitySetInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSetVirtualKeyboardModelVisibilityMETA", objects_info,
                                                        true, modelVisibility);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetVirtualKeyboardModelVisibilityMETA-modelVisibility-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetVirtualKeyboardModelVisibilityMETA",
                                objects_info,
                                "Command xrSetVirtualKeyboardModelVisibilityMETA param modelVisibility is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetVirtualKeyboardModelVisibilityMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetVirtualKeyboardModelVisibilityMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility) {
    XrResult test_result = GenValidUsageInputsXrSetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
}

XrResult GenValidUsageInputsXrGetVirtualKeyboardModelAnimationStatesMETA(
XrVirtualKeyboardMETA keyboard,
XrVirtualKeyboardModelAnimationStatesMETA* animationStates) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrGetVirtualKeyboardModelAnimationStatesMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardModelAnimationStatesMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == animationStates) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardModelAnimationStatesMETA-animationStates-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardModelAnimationStatesMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardModelAnimationStatesMETA \"animationStates\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardModelAnimationStatesMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVirtualKeyboardModelAnimationStatesMETA", objects_info,
                                                        false, animationStates);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardModelAnimationStatesMETA-animationStates-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardModelAnimationStatesMETA",
                                objects_info,
                                "Command xrGetVirtualKeyboardModelAnimationStatesMETA param animationStates is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVirtualKeyboardModelAnimationStatesMETA(
    XrVirtualKeyboardMETA keyboard,
    XrVirtualKeyboardModelAnimationStatesMETA* animationStates) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVirtualKeyboardModelAnimationStatesMETA(
    XrVirtualKeyboardMETA keyboard,
    XrVirtualKeyboardModelAnimationStatesMETA* animationStates) {
    XrResult test_result = GenValidUsageInputsXrGetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
}

XrResult GenValidUsageInputsXrGetVirtualKeyboardDirtyTexturesMETA(
XrVirtualKeyboardMETA keyboard,
uint32_t textureIdCapacityInput,
uint32_t* textureIdCountOutput,
uint64_t* textureIds) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrGetVirtualKeyboardDirtyTexturesMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardDirtyTexturesMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when textureIdCapacityInput is non-zero
        if (0 != textureIdCapacityInput && nullptr == textureIds) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardDirtyTexturesMETA-textureIds-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardDirtyTexturesMETA",
                                objects_info,
                                "Command xrGetVirtualKeyboardDirtyTexturesMETA param textureIds is NULL, but textureIdCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == textureIdCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardDirtyTexturesMETA-textureIdCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardDirtyTexturesMETA", objects_info,
                                "Invalid NULL for uint32_t \"textureIdCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetVirtualKeyboardDirtyTexturesMETA-textureIdCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrGetVirtualKeyboardDirtyTexturesMETA-textureIds-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVirtualKeyboardDirtyTexturesMETA(
    XrVirtualKeyboardMETA keyboard,
    uint32_t textureIdCapacityInput,
    uint32_t* textureIdCountOutput,
    uint64_t* textureIds) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVirtualKeyboardDirtyTexturesMETA(
    XrVirtualKeyboardMETA keyboard,
    uint32_t textureIdCapacityInput,
    uint32_t* textureIdCountOutput,
    uint64_t* textureIds) {
    XrResult test_result = GenValidUsageInputsXrGetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
}

XrResult GenValidUsageInputsXrGetVirtualKeyboardTextureDataMETA(
XrVirtualKeyboardMETA keyboard,
uint64_t textureId,
XrVirtualKeyboardTextureDataMETA* textureData) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrGetVirtualKeyboardTextureDataMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardTextureDataMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == textureData) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardTextureDataMETA-textureData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardTextureDataMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardTextureDataMETA \"textureData\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardTextureDataMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetVirtualKeyboardTextureDataMETA", objects_info,
                                                        false, textureData);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetVirtualKeyboardTextureDataMETA-textureData-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetVirtualKeyboardTextureDataMETA",
                                objects_info,
                                "Command xrGetVirtualKeyboardTextureDataMETA param textureData is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetVirtualKeyboardTextureDataMETA(
    XrVirtualKeyboardMETA keyboard,
    uint64_t textureId,
    XrVirtualKeyboardTextureDataMETA* textureData) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetVirtualKeyboardTextureDataMETA(
    XrVirtualKeyboardMETA keyboard,
    uint64_t textureId,
    XrVirtualKeyboardTextureDataMETA* textureData) {
    XrResult test_result = GenValidUsageInputsXrGetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
}

XrResult GenValidUsageInputsXrSendVirtualKeyboardInputMETA(
XrVirtualKeyboardMETA keyboard,
const XrVirtualKeyboardInputInfoMETA* info,
XrPosef* interactorRootPose) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrSendVirtualKeyboardInputMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSendVirtualKeyboardInputMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSendVirtualKeyboardInputMETA-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSendVirtualKeyboardInputMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardInputInfoMETA \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardInputInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSendVirtualKeyboardInputMETA", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSendVirtualKeyboardInputMETA-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSendVirtualKeyboardInputMETA",
                                objects_info,
                                "Command xrSendVirtualKeyboardInputMETA param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == interactorRootPose) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSendVirtualKeyboardInputMETA-interactorRootPose-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSendVirtualKeyboardInputMETA", objects_info,
                                "Invalid NULL for XrPosef \"interactorRootPose\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrSendVirtualKeyboardInputMETA-interactorRootPose-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSendVirtualKeyboardInputMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardInputInfoMETA* info,
    XrPosef* interactorRootPose) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSendVirtualKeyboardInputMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardInputInfoMETA* info,
    XrPosef* interactorRootPose) {
    XrResult test_result = GenValidUsageInputsXrSendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
}

XrResult GenValidUsageInputsXrChangeVirtualKeyboardTextContextMETA(
XrVirtualKeyboardMETA keyboard,
const XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(keyboard, XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrVirtualKeyboardMETAHandle(&keyboard);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrVirtualKeyboardMETA handle \"keyboard\" ";
                oss << HandleToHexString(keyboard);
                CoreValidLogMessage(nullptr, "VUID-xrChangeVirtualKeyboardTextContextMETA-keyboard-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrChangeVirtualKeyboardTextContextMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == changeInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrChangeVirtualKeyboardTextContextMETA-changeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrChangeVirtualKeyboardTextContextMETA", objects_info,
                                "Invalid NULL for XrVirtualKeyboardTextContextChangeInfoMETA \"changeInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrVirtualKeyboardTextContextChangeInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrChangeVirtualKeyboardTextContextMETA", objects_info,
                                                        true, changeInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrChangeVirtualKeyboardTextContextMETA-changeInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrChangeVirtualKeyboardTextContextMETA",
                                objects_info,
                                "Command xrChangeVirtualKeyboardTextContextMETA param changeInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrChangeVirtualKeyboardTextContextMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_virtualkeyboardmeta_info.getWithInstanceInfo(keyboard);
        GenValidUsageXrHandleInfo *gen_virtualkeyboardmeta_info = info_with_instance.first;
        (void)gen_virtualkeyboardmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrChangeVirtualKeyboardTextContextMETA(
    XrVirtualKeyboardMETA keyboard,
    const XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo) {
    XrResult test_result = GenValidUsageInputsXrChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
}


// ---- XR_OCULUS_external_camera extension commands
XrResult GenValidUsageInputsXrEnumerateExternalCamerasOCULUS(
XrSession session,
uint32_t cameraCapacityInput,
uint32_t* cameraCountOutput,
XrExternalCameraOCULUS* cameras) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrEnumerateExternalCamerasOCULUS-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateExternalCamerasOCULUS",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when cameraCapacityInput is non-zero
        if (0 != cameraCapacityInput && nullptr == cameras) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateExternalCamerasOCULUS-cameras-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateExternalCamerasOCULUS",
                                objects_info,
                                "Command xrEnumerateExternalCamerasOCULUS param cameras is NULL, but cameraCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == cameraCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateExternalCamerasOCULUS-cameraCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateExternalCamerasOCULUS", objects_info,
                                "Invalid NULL for uint32_t \"cameraCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumerateExternalCamerasOCULUS-cameraCountOutput-parameter" type
        if (cameras) {
            for (uint32_t value_cameras_inc = 0; value_cameras_inc < cameraCapacityInput; ++value_cameras_inc) {
                // Validate that the structure XrExternalCameraOCULUS is valid
                xr_result = ValidateXrStruct(gen_instance_info, "xrEnumerateExternalCamerasOCULUS", objects_info,
                                                                true, &cameras[value_cameras_inc]);
                if (XR_SUCCESS != xr_result) {
                    CoreValidLogMessage(gen_instance_info, "VUID-xrEnumerateExternalCamerasOCULUS-cameras-parameter",
                                        VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumerateExternalCamerasOCULUS",
                                        objects_info,
                                        "Command xrEnumerateExternalCamerasOCULUS param cameras is invalid");
                    return xr_result;
                }
            }
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumerateExternalCamerasOCULUS(
    XrSession session,
    uint32_t cameraCapacityInput,
    uint32_t* cameraCountOutput,
    XrExternalCameraOCULUS* cameras) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->EnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumerateExternalCamerasOCULUS(
    XrSession session,
    uint32_t cameraCapacityInput,
    uint32_t* cameraCountOutput,
    XrExternalCameraOCULUS* cameras) {
    XrResult test_result = GenValidUsageInputsXrEnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
}


// ---- XR_META_performance_metrics extension commands
XrResult GenValidUsageInputsXrEnumeratePerformanceMetricsCounterPathsMETA(
XrInstance instance,
uint32_t counterPathCapacityInput,
uint32_t* counterPathCountOutput,
XrPath* counterPaths) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnumeratePerformanceMetricsCounterPathsMETA-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePerformanceMetricsCounterPathsMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Optional array must be non-NULL when counterPathCapacityInput is non-zero
        if (0 != counterPathCapacityInput && nullptr == counterPaths) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumeratePerformanceMetricsCounterPathsMETA-counterPaths-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePerformanceMetricsCounterPathsMETA",
                                objects_info,
                                "Command xrEnumeratePerformanceMetricsCounterPathsMETA param counterPaths is NULL, but counterPathCapacityInput is greater than 0");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == counterPathCountOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnumeratePerformanceMetricsCounterPathsMETA-counterPathCountOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnumeratePerformanceMetricsCounterPathsMETA", objects_info,
                                "Invalid NULL for uint32_t \"counterPathCountOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrEnumeratePerformanceMetricsCounterPathsMETA-counterPathCountOutput-parameter" type
        // NOTE: Can't validate "VUID-xrEnumeratePerformanceMetricsCounterPathsMETA-counterPaths-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnumeratePerformanceMetricsCounterPathsMETA(
    XrInstance instance,
    uint32_t counterPathCapacityInput,
    uint32_t* counterPathCountOutput,
    XrPath* counterPaths) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnumeratePerformanceMetricsCounterPathsMETA(
    XrInstance instance,
    uint32_t counterPathCapacityInput,
    uint32_t* counterPathCountOutput,
    XrPath* counterPaths) {
    XrResult test_result = GenValidUsageInputsXrEnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
}

XrResult GenValidUsageInputsXrSetPerformanceMetricsStateMETA(
XrSession session,
const XrPerformanceMetricsStateMETA* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetPerformanceMetricsStateMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetPerformanceMetricsStateMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetPerformanceMetricsStateMETA-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetPerformanceMetricsStateMETA", objects_info,
                                "Invalid NULL for XrPerformanceMetricsStateMETA \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPerformanceMetricsStateMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSetPerformanceMetricsStateMETA", objects_info,
                                                        true, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetPerformanceMetricsStateMETA-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetPerformanceMetricsStateMETA",
                                objects_info,
                                "Command xrSetPerformanceMetricsStateMETA param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetPerformanceMetricsStateMETA(
    XrSession session,
    const XrPerformanceMetricsStateMETA* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetPerformanceMetricsStateMETA(session, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetPerformanceMetricsStateMETA(
    XrSession session,
    const XrPerformanceMetricsStateMETA* state) {
    XrResult test_result = GenValidUsageInputsXrSetPerformanceMetricsStateMETA(session, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetPerformanceMetricsStateMETA(session, state);
}

XrResult GenValidUsageInputsXrGetPerformanceMetricsStateMETA(
XrSession session,
XrPerformanceMetricsStateMETA* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetPerformanceMetricsStateMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPerformanceMetricsStateMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPerformanceMetricsStateMETA-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPerformanceMetricsStateMETA", objects_info,
                                "Invalid NULL for XrPerformanceMetricsStateMETA \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPerformanceMetricsStateMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetPerformanceMetricsStateMETA", objects_info,
                                                        false, state);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPerformanceMetricsStateMETA-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPerformanceMetricsStateMETA",
                                objects_info,
                                "Command xrGetPerformanceMetricsStateMETA param state is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetPerformanceMetricsStateMETA(
    XrSession session,
    XrPerformanceMetricsStateMETA* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetPerformanceMetricsStateMETA(session, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetPerformanceMetricsStateMETA(
    XrSession session,
    XrPerformanceMetricsStateMETA* state) {
    XrResult test_result = GenValidUsageInputsXrGetPerformanceMetricsStateMETA(session, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetPerformanceMetricsStateMETA(session, state);
}

XrResult GenValidUsageInputsXrQueryPerformanceMetricsCounterMETA(
XrSession session,
XrPath counterPath,
XrPerformanceMetricsCounterMETA* counter) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrQueryPerformanceMetricsCounterMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryPerformanceMetricsCounterMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == counter) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQueryPerformanceMetricsCounterMETA-counter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryPerformanceMetricsCounterMETA", objects_info,
                                "Invalid NULL for XrPerformanceMetricsCounterMETA \"counter\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPerformanceMetricsCounterMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrQueryPerformanceMetricsCounterMETA", objects_info,
                                                        false, counter);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrQueryPerformanceMetricsCounterMETA-counter-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrQueryPerformanceMetricsCounterMETA",
                                objects_info,
                                "Command xrQueryPerformanceMetricsCounterMETA param counter is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrQueryPerformanceMetricsCounterMETA(
    XrSession session,
    XrPath counterPath,
    XrPerformanceMetricsCounterMETA* counter) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->QueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrQueryPerformanceMetricsCounterMETA(
    XrSession session,
    XrPath counterPath,
    XrPerformanceMetricsCounterMETA* counter) {
    XrResult test_result = GenValidUsageInputsXrQueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrQueryPerformanceMetricsCounterMETA(session, counterPath, counter);
}


// ---- XR_FB_spatial_entity_storage_batch extension commands
XrResult GenValidUsageInputsXrSaveSpaceListFB(
XrSession session,
const XrSpaceListSaveInfoFB* info,
XrAsyncRequestIdFB* requestId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSaveSpaceListFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceListFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceListFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceListFB", objects_info,
                                "Invalid NULL for XrSpaceListSaveInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceListSaveInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrSaveSpaceListFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceListFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceListFB",
                                objects_info,
                                "Command xrSaveSpaceListFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == requestId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrSaveSpaceListFB-requestId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSaveSpaceListFB", objects_info,
                                "Invalid NULL for XrAsyncRequestIdFB \"requestId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrSaveSpaceListFB-requestId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSaveSpaceListFB(
    XrSession session,
    const XrSpaceListSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SaveSpaceListFB(session, info, requestId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSaveSpaceListFB(
    XrSession session,
    const XrSpaceListSaveInfoFB* info,
    XrAsyncRequestIdFB* requestId) {
    XrResult test_result = GenValidUsageInputsXrSaveSpaceListFB(session, info, requestId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSaveSpaceListFB(session, info, requestId);
}


// ---- XR_FB_spatial_entity_user extension commands
XrResult GenValidUsageInputsXrCreateSpaceUserFB(
XrSession session,
const XrSpaceUserCreateInfoFB* info,
XrSpaceUserFB* user) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpaceUserFB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceUserFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceUserFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceUserFB", objects_info,
                                "Invalid NULL for XrSpaceUserCreateInfoFB \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceUserCreateInfoFB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpaceUserFB", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceUserFB-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceUserFB",
                                objects_info,
                                "Command xrCreateSpaceUserFB param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == user) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpaceUserFB-user-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpaceUserFB", objects_info,
                                "Invalid NULL for XrSpaceUserFB \"user\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpaceUserFB(
    XrSession session,
    const XrSpaceUserCreateInfoFB* info,
    XrSpaceUserFB* user) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpaceUserFB(session, info, user);
        if (XR_SUCCESS == result && nullptr != user) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_spaceuserfb_info.insert(*user, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpaceUserFB(
    XrSession session,
    const XrSpaceUserCreateInfoFB* info,
    XrSpaceUserFB* user) {
    XrResult test_result = GenValidUsageInputsXrCreateSpaceUserFB(session, info, user);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpaceUserFB(session, info, user);
}

XrResult GenValidUsageInputsXrGetSpaceUserIdFB(
XrSpaceUserFB user,
XrSpaceUserIdFB* userId) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(user, XR_OBJECT_TYPE_SPACE_USER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceUserFBHandle(&user);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpaceUserFB handle \"user\" ";
                oss << HandleToHexString(user);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceUserIdFB-user-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceUserIdFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spaceuserfb_info.getWithInstanceInfo(user);
        GenValidUsageXrHandleInfo *gen_spaceuserfb_info = info_with_instance.first;
        (void)gen_spaceuserfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == userId) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceUserIdFB-userId-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceUserIdFB", objects_info,
                                "Invalid NULL for XrSpaceUserIdFB \"userId\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // NOTE: Can't validate "VUID-xrGetSpaceUserIdFB-userId-parameter" type
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceUserIdFB(
    XrSpaceUserFB user,
    XrSpaceUserIdFB* userId) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spaceuserfb_info.getWithInstanceInfo(user);
        GenValidUsageXrHandleInfo *gen_spaceuserfb_info = info_with_instance.first;
        (void)gen_spaceuserfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceUserIdFB(user, userId);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceUserIdFB(
    XrSpaceUserFB user,
    XrSpaceUserIdFB* userId) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceUserIdFB(user, userId);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceUserIdFB(user, userId);
}

XrResult GenValidUsageInputsXrDestroySpaceUserFB(
XrSpaceUserFB user) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(user, XR_OBJECT_TYPE_SPACE_USER_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceUserFBHandle(&user);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpaceUserFB handle \"user\" ";
                oss << HandleToHexString(user);
                CoreValidLogMessage(nullptr, "VUID-xrDestroySpaceUserFB-user-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroySpaceUserFB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_spaceuserfb_info.getWithInstanceInfo(user);
        GenValidUsageXrHandleInfo *gen_spaceuserfb_info = info_with_instance.first;
        (void)gen_spaceuserfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroySpaceUserFB(
    XrSpaceUserFB user) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_spaceuserfb_info.getWithInstanceInfo(user);
        GenValidUsageXrHandleInfo *gen_spaceuserfb_info = info_with_instance.first;
        (void)gen_spaceuserfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroySpaceUserFB(user);
        if (XR_SUCCEEDED(result)) {
            g_spaceuserfb_info.erase(user);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroySpaceUserFB(
    XrSpaceUserFB user) {
    XrResult test_result = GenValidUsageInputsXrDestroySpaceUserFB(user);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroySpaceUserFB(user);
}


// ---- XR_META_recommended_layer_resolution extension commands
XrResult GenValidUsageInputsXrGetRecommendedLayerResolutionMETA(
XrSession session,
const XrRecommendedLayerResolutionGetInfoMETA* info,
XrRecommendedLayerResolutionMETA* resolution) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrGetRecommendedLayerResolutionMETA-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRecommendedLayerResolutionMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRecommendedLayerResolutionMETA-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRecommendedLayerResolutionMETA", objects_info,
                                "Invalid NULL for XrRecommendedLayerResolutionGetInfoMETA \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRecommendedLayerResolutionGetInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetRecommendedLayerResolutionMETA", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRecommendedLayerResolutionMETA-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRecommendedLayerResolutionMETA",
                                objects_info,
                                "Command xrGetRecommendedLayerResolutionMETA param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == resolution) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRecommendedLayerResolutionMETA-resolution-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRecommendedLayerResolutionMETA", objects_info,
                                "Invalid NULL for XrRecommendedLayerResolutionMETA \"resolution\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrRecommendedLayerResolutionMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetRecommendedLayerResolutionMETA", objects_info,
                                                        false, resolution);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetRecommendedLayerResolutionMETA-resolution-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetRecommendedLayerResolutionMETA",
                                objects_info,
                                "Command xrGetRecommendedLayerResolutionMETA param resolution is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetRecommendedLayerResolutionMETA(
    XrSession session,
    const XrRecommendedLayerResolutionGetInfoMETA* info,
    XrRecommendedLayerResolutionMETA* resolution) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetRecommendedLayerResolutionMETA(session, info, resolution);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetRecommendedLayerResolutionMETA(
    XrSession session,
    const XrRecommendedLayerResolutionGetInfoMETA* info,
    XrRecommendedLayerResolutionMETA* resolution) {
    XrResult test_result = GenValidUsageInputsXrGetRecommendedLayerResolutionMETA(session, info, resolution);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetRecommendedLayerResolutionMETA(session, info, resolution);
}


// ---- XR_META_passthrough_color_lut extension commands
XrResult GenValidUsageInputsXrCreatePassthroughColorLutMETA(
XrPassthroughFB passthrough,
const XrPassthroughColorLutCreateInfoMETA* createInfo,
XrPassthroughColorLutMETA* colorLut) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(passthrough, XR_OBJECT_TYPE_PASSTHROUGH_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughFBHandle(&passthrough);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughFB handle \"passthrough\" ";
                oss << HandleToHexString(passthrough);
                CoreValidLogMessage(nullptr, "VUID-xrCreatePassthroughColorLutMETA-passthrough-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughColorLutMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughColorLutMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughColorLutMETA", objects_info,
                                "Invalid NULL for XrPassthroughColorLutCreateInfoMETA \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughColorLutCreateInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreatePassthroughColorLutMETA", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughColorLutMETA-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughColorLutMETA",
                                objects_info,
                                "Command xrCreatePassthroughColorLutMETA param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == colorLut) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughColorLutMETA-colorLut-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughColorLutMETA", objects_info,
                                "Invalid NULL for XrPassthroughColorLutMETA \"colorLut\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreatePassthroughColorLutMETA(
    XrPassthroughFB passthrough,
    const XrPassthroughColorLutCreateInfoMETA* createInfo,
    XrPassthroughColorLutMETA* colorLut) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughfb_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughfb_info = info_with_instance.first;
        (void)gen_passthroughfb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
        if (XR_SUCCESS == result && nullptr != colorLut) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_PASSTHROUGH_FB;
            handle_info->direct_parent_handle = MakeHandleGeneric(passthrough);
            g_passthroughcolorlutmeta_info.insert(*colorLut, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreatePassthroughColorLutMETA(
    XrPassthroughFB passthrough,
    const XrPassthroughColorLutCreateInfoMETA* createInfo,
    XrPassthroughColorLutMETA* colorLut) {
    XrResult test_result = GenValidUsageInputsXrCreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
}

XrResult GenValidUsageInputsXrDestroyPassthroughColorLutMETA(
XrPassthroughColorLutMETA colorLut) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(colorLut, XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughColorLutMETAHandle(&colorLut);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughColorLutMETA handle \"colorLut\" ";
                oss << HandleToHexString(colorLut);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyPassthroughColorLutMETA-colorLut-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyPassthroughColorLutMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughcolorlutmeta_info.getWithInstanceInfo(colorLut);
        GenValidUsageXrHandleInfo *gen_passthroughcolorlutmeta_info = info_with_instance.first;
        (void)gen_passthroughcolorlutmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyPassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughcolorlutmeta_info.getWithInstanceInfo(colorLut);
        GenValidUsageXrHandleInfo *gen_passthroughcolorlutmeta_info = info_with_instance.first;
        (void)gen_passthroughcolorlutmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyPassthroughColorLutMETA(colorLut);
        if (XR_SUCCEEDED(result)) {
            g_passthroughcolorlutmeta_info.erase(colorLut);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyPassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut) {
    XrResult test_result = GenValidUsageInputsXrDestroyPassthroughColorLutMETA(colorLut);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyPassthroughColorLutMETA(colorLut);
}

XrResult GenValidUsageInputsXrUpdatePassthroughColorLutMETA(
XrPassthroughColorLutMETA colorLut,
const XrPassthroughColorLutUpdateInfoMETA* updateInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(colorLut, XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughColorLutMETAHandle(&colorLut);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughColorLutMETA handle \"colorLut\" ";
                oss << HandleToHexString(colorLut);
                CoreValidLogMessage(nullptr, "VUID-xrUpdatePassthroughColorLutMETA-colorLut-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdatePassthroughColorLutMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughcolorlutmeta_info.getWithInstanceInfo(colorLut);
        GenValidUsageXrHandleInfo *gen_passthroughcolorlutmeta_info = info_with_instance.first;
        (void)gen_passthroughcolorlutmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == updateInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdatePassthroughColorLutMETA-updateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdatePassthroughColorLutMETA", objects_info,
                                "Invalid NULL for XrPassthroughColorLutUpdateInfoMETA \"updateInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughColorLutUpdateInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrUpdatePassthroughColorLutMETA", objects_info,
                                                        true, updateInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrUpdatePassthroughColorLutMETA-updateInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrUpdatePassthroughColorLutMETA",
                                objects_info,
                                "Command xrUpdatePassthroughColorLutMETA param updateInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrUpdatePassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut,
    const XrPassthroughColorLutUpdateInfoMETA* updateInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughcolorlutmeta_info.getWithInstanceInfo(colorLut);
        GenValidUsageXrHandleInfo *gen_passthroughcolorlutmeta_info = info_with_instance.first;
        (void)gen_passthroughcolorlutmeta_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->UpdatePassthroughColorLutMETA(colorLut, updateInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrUpdatePassthroughColorLutMETA(
    XrPassthroughColorLutMETA colorLut,
    const XrPassthroughColorLutUpdateInfoMETA* updateInfo) {
    XrResult test_result = GenValidUsageInputsXrUpdatePassthroughColorLutMETA(colorLut, updateInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrUpdatePassthroughColorLutMETA(colorLut, updateInfo);
}


// ---- XR_META_spatial_entity_mesh extension commands
XrResult GenValidUsageInputsXrGetSpaceTriangleMeshMETA(
XrSpace space,
const XrSpaceTriangleMeshGetInfoMETA* getInfo,
XrSpaceTriangleMeshMETA* triangleMeshOutput) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(space, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&space);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"space\" ";
                oss << HandleToHexString(space);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpaceTriangleMeshMETA-space-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceTriangleMeshMETA",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == getInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceTriangleMeshMETA-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceTriangleMeshMETA", objects_info,
                                "Invalid NULL for XrSpaceTriangleMeshGetInfoMETA \"getInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceTriangleMeshGetInfoMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceTriangleMeshMETA", objects_info,
                                                        true, getInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceTriangleMeshMETA-getInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceTriangleMeshMETA",
                                objects_info,
                                "Command xrGetSpaceTriangleMeshMETA param getInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == triangleMeshOutput) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceTriangleMeshMETA-triangleMeshOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceTriangleMeshMETA", objects_info,
                                "Invalid NULL for XrSpaceTriangleMeshMETA \"triangleMeshOutput\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpaceTriangleMeshMETA is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpaceTriangleMeshMETA", objects_info,
                                                        false, triangleMeshOutput);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpaceTriangleMeshMETA-triangleMeshOutput-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpaceTriangleMeshMETA",
                                objects_info,
                                "Command xrGetSpaceTriangleMeshMETA param triangleMeshOutput is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpaceTriangleMeshMETA(
    XrSpace space,
    const XrSpaceTriangleMeshGetInfoMETA* getInfo,
    XrSpaceTriangleMeshMETA* triangleMeshOutput) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(space);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpaceTriangleMeshMETA(
    XrSpace space,
    const XrSpaceTriangleMeshGetInfoMETA* getInfo,
    XrSpaceTriangleMeshMETA* triangleMeshOutput) {
    XrResult test_result = GenValidUsageInputsXrGetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
}


// ---- XR_FB_face_tracking2 extension commands
XrResult GenValidUsageInputsXrCreateFaceTracker2FB(
XrSession session,
const XrFaceTrackerCreateInfo2FB* createInfo,
XrFaceTracker2FB* faceTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateFaceTracker2FB-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTracker2FB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTracker2FB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTracker2FB", objects_info,
                                "Invalid NULL for XrFaceTrackerCreateInfo2FB \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceTrackerCreateInfo2FB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateFaceTracker2FB", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTracker2FB-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTracker2FB",
                                objects_info,
                                "Command xrCreateFaceTracker2FB param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == faceTracker) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateFaceTracker2FB-faceTracker-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateFaceTracker2FB", objects_info,
                                "Invalid NULL for XrFaceTracker2FB \"faceTracker\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateFaceTracker2FB(
    XrSession session,
    const XrFaceTrackerCreateInfo2FB* createInfo,
    XrFaceTracker2FB* faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateFaceTracker2FB(session, createInfo, faceTracker);
        if (XR_SUCCESS == result && nullptr != faceTracker) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_facetracker2fb_info.insert(*faceTracker, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateFaceTracker2FB(
    XrSession session,
    const XrFaceTrackerCreateInfo2FB* createInfo,
    XrFaceTracker2FB* faceTracker) {
    XrResult test_result = GenValidUsageInputsXrCreateFaceTracker2FB(session, createInfo, faceTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateFaceTracker2FB(session, createInfo, faceTracker);
}

XrResult GenValidUsageInputsXrDestroyFaceTracker2FB(
XrFaceTracker2FB faceTracker) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(faceTracker, XR_OBJECT_TYPE_FACE_TRACKER2_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFaceTracker2FBHandle(&faceTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFaceTracker2FB handle \"faceTracker\" ";
                oss << HandleToHexString(faceTracker);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyFaceTracker2FB-faceTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyFaceTracker2FB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facetracker2fb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetracker2fb_info = info_with_instance.first;
        (void)gen_facetracker2fb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyFaceTracker2FB(
    XrFaceTracker2FB faceTracker) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facetracker2fb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetracker2fb_info = info_with_instance.first;
        (void)gen_facetracker2fb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyFaceTracker2FB(faceTracker);
        if (XR_SUCCEEDED(result)) {
            g_facetracker2fb_info.erase(faceTracker);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyFaceTracker2FB(
    XrFaceTracker2FB faceTracker) {
    XrResult test_result = GenValidUsageInputsXrDestroyFaceTracker2FB(faceTracker);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyFaceTracker2FB(faceTracker);
}

XrResult GenValidUsageInputsXrGetFaceExpressionWeights2FB(
XrFaceTracker2FB faceTracker,
const XrFaceExpressionInfo2FB* expressionInfo,
XrFaceExpressionWeights2FB* expressionWeights) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(faceTracker, XR_OBJECT_TYPE_FACE_TRACKER2_FB);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrFaceTracker2FBHandle(&faceTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrFaceTracker2FB handle \"faceTracker\" ";
                oss << HandleToHexString(faceTracker);
                CoreValidLogMessage(nullptr, "VUID-xrGetFaceExpressionWeights2FB-faceTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeights2FB",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_facetracker2fb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetracker2fb_info = info_with_instance.first;
        (void)gen_facetracker2fb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == expressionInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeights2FB-expressionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeights2FB", objects_info,
                                "Invalid NULL for XrFaceExpressionInfo2FB \"expressionInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceExpressionInfo2FB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFaceExpressionWeights2FB", objects_info,
                                                        true, expressionInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeights2FB-expressionInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeights2FB",
                                objects_info,
                                "Command xrGetFaceExpressionWeights2FB param expressionInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == expressionWeights) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeights2FB-expressionWeights-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeights2FB", objects_info,
                                "Invalid NULL for XrFaceExpressionWeights2FB \"expressionWeights\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFaceExpressionWeights2FB is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetFaceExpressionWeights2FB", objects_info,
                                                        false, expressionWeights);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetFaceExpressionWeights2FB-expressionWeights-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetFaceExpressionWeights2FB",
                                objects_info,
                                "Command xrGetFaceExpressionWeights2FB param expressionWeights is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetFaceExpressionWeights2FB(
    XrFaceTracker2FB faceTracker,
    const XrFaceExpressionInfo2FB* expressionInfo,
    XrFaceExpressionWeights2FB* expressionWeights) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_facetracker2fb_info.getWithInstanceInfo(faceTracker);
        GenValidUsageXrHandleInfo *gen_facetracker2fb_info = info_with_instance.first;
        (void)gen_facetracker2fb_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetFaceExpressionWeights2FB(
    XrFaceTracker2FB faceTracker,
    const XrFaceExpressionInfo2FB* expressionInfo,
    XrFaceExpressionWeights2FB* expressionWeights) {
    XrResult test_result = GenValidUsageInputsXrGetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
}


// ---- XR_QCOM_tracking_optimization_settings extension commands
XrResult GenValidUsageInputsXrSetTrackingOptimizationSettingsHintQCOM(
XrSession session,
XrTrackingOptimizationSettingsDomainQCOM domain,
XrTrackingOptimizationSettingsHintQCOM hint) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrSetTrackingOptimizationSettingsHintQCOM-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetTrackingOptimizationSettingsHintQCOM",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Make sure the enum type XrTrackingOptimizationSettingsDomainQCOM value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrSetTrackingOptimizationSettingsHintQCOM", "xrSetTrackingOptimizationSettingsHintQCOM", "domain", objects_info, domain)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrTrackingOptimizationSettingsDomainQCOM \"domain\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(domain));
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetTrackingOptimizationSettingsHintQCOM-domain-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetTrackingOptimizationSettingsHintQCOM",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrTrackingOptimizationSettingsHintQCOM value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrSetTrackingOptimizationSettingsHintQCOM", "xrSetTrackingOptimizationSettingsHintQCOM", "hint", objects_info, hint)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrTrackingOptimizationSettingsHintQCOM \"hint\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(hint));
            CoreValidLogMessage(gen_instance_info, "VUID-xrSetTrackingOptimizationSettingsHintQCOM-hint-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrSetTrackingOptimizationSettingsHintQCOM",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrSetTrackingOptimizationSettingsHintQCOM(
    XrSession session,
    XrTrackingOptimizationSettingsDomainQCOM domain,
    XrTrackingOptimizationSettingsHintQCOM hint) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->SetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrSetTrackingOptimizationSettingsHintQCOM(
    XrSession session,
    XrTrackingOptimizationSettingsDomainQCOM domain,
    XrTrackingOptimizationSettingsHintQCOM hint) {
    XrResult test_result = GenValidUsageInputsXrSetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrSetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
}


// ---- XR_HTC_passthrough extension commands
XrResult GenValidUsageInputsXrCreatePassthroughHTC(
XrSession session,
const XrPassthroughCreateInfoHTC* createInfo,
XrPassthroughHTC* passthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreatePassthroughHTC-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughHTC", objects_info,
                                "Invalid NULL for XrPassthroughCreateInfoHTC \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPassthroughCreateInfoHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreatePassthroughHTC", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughHTC",
                                objects_info,
                                "Command xrCreatePassthroughHTC param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == passthrough) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePassthroughHTC-passthrough-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePassthroughHTC", objects_info,
                                "Invalid NULL for XrPassthroughHTC \"passthrough\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreatePassthroughHTC(
    XrSession session,
    const XrPassthroughCreateInfoHTC* createInfo,
    XrPassthroughHTC* passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreatePassthroughHTC(session, createInfo, passthrough);
        if (XR_SUCCESS == result && nullptr != passthrough) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_passthroughhtc_info.insert(*passthrough, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreatePassthroughHTC(
    XrSession session,
    const XrPassthroughCreateInfoHTC* createInfo,
    XrPassthroughHTC* passthrough) {
    XrResult test_result = GenValidUsageInputsXrCreatePassthroughHTC(session, createInfo, passthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreatePassthroughHTC(session, createInfo, passthrough);
}

XrResult GenValidUsageInputsXrDestroyPassthroughHTC(
XrPassthroughHTC passthrough) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(passthrough, XR_OBJECT_TYPE_PASSTHROUGH_HTC);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPassthroughHTCHandle(&passthrough);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPassthroughHTC handle \"passthrough\" ";
                oss << HandleToHexString(passthrough);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyPassthroughHTC-passthrough-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyPassthroughHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_passthroughhtc_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughhtc_info = info_with_instance.first;
        (void)gen_passthroughhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyPassthroughHTC(
    XrPassthroughHTC passthrough) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_passthroughhtc_info.getWithInstanceInfo(passthrough);
        GenValidUsageXrHandleInfo *gen_passthroughhtc_info = info_with_instance.first;
        (void)gen_passthroughhtc_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyPassthroughHTC(passthrough);
        if (XR_SUCCEEDED(result)) {
            g_passthroughhtc_info.erase(passthrough);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyPassthroughHTC(
    XrPassthroughHTC passthrough) {
    XrResult test_result = GenValidUsageInputsXrDestroyPassthroughHTC(passthrough);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyPassthroughHTC(passthrough);
}


// ---- XR_HTC_foveation extension commands
XrResult GenValidUsageInputsXrApplyFoveationHTC(
XrSession session,
const XrFoveationApplyInfoHTC* applyInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrApplyFoveationHTC-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyFoveationHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == applyInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyFoveationHTC-applyInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyFoveationHTC", objects_info,
                                "Invalid NULL for XrFoveationApplyInfoHTC \"applyInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrFoveationApplyInfoHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrApplyFoveationHTC", objects_info,
                                                        true, applyInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyFoveationHTC-applyInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyFoveationHTC",
                                objects_info,
                                "Command xrApplyFoveationHTC param applyInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrApplyFoveationHTC(
    XrSession session,
    const XrFoveationApplyInfoHTC* applyInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ApplyFoveationHTC(session, applyInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrApplyFoveationHTC(
    XrSession session,
    const XrFoveationApplyInfoHTC* applyInfo) {
    XrResult test_result = GenValidUsageInputsXrApplyFoveationHTC(session, applyInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrApplyFoveationHTC(session, applyInfo);
}


// ---- XR_HTC_anchor extension commands
XrResult GenValidUsageInputsXrCreateSpatialAnchorHTC(
XrSession session,
const XrSpatialAnchorCreateInfoHTC* createInfo,
XrSpace* anchor) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreateSpatialAnchorHTC-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorHTC", objects_info,
                                "Invalid NULL for XrSpatialAnchorCreateInfoHTC \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorCreateInfoHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreateSpatialAnchorHTC", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorHTC-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorHTC",
                                objects_info,
                                "Command xrCreateSpatialAnchorHTC param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == anchor) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreateSpatialAnchorHTC-anchor-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreateSpatialAnchorHTC", objects_info,
                                "Invalid NULL for XrSpace \"anchor\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreateSpatialAnchorHTC(
    XrSession session,
    const XrSpatialAnchorCreateInfoHTC* createInfo,
    XrSpace* anchor) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreateSpatialAnchorHTC(session, createInfo, anchor);
        if (XR_SUCCESS == result && nullptr != anchor) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_space_info.insert(*anchor, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreateSpatialAnchorHTC(
    XrSession session,
    const XrSpatialAnchorCreateInfoHTC* createInfo,
    XrSpace* anchor) {
    XrResult test_result = GenValidUsageInputsXrCreateSpatialAnchorHTC(session, createInfo, anchor);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreateSpatialAnchorHTC(session, createInfo, anchor);
}

XrResult GenValidUsageInputsXrGetSpatialAnchorNameHTC(
XrSpace anchor,
XrSpatialAnchorNameHTC* name) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(anchor, XR_OBJECT_TYPE_SPACE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSpaceHandle(&anchor);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSpace handle \"anchor\" ";
                oss << HandleToHexString(anchor);
                CoreValidLogMessage(nullptr, "VUID-xrGetSpatialAnchorNameHTC-anchor-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialAnchorNameHTC",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_space_info.getWithInstanceInfo(anchor);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == name) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpatialAnchorNameHTC-name-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialAnchorNameHTC", objects_info,
                                "Invalid NULL for XrSpatialAnchorNameHTC \"name\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrSpatialAnchorNameHTC is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetSpatialAnchorNameHTC", objects_info,
                                                        false, name);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetSpatialAnchorNameHTC-name-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetSpatialAnchorNameHTC",
                                objects_info,
                                "Command xrGetSpatialAnchorNameHTC param name is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetSpatialAnchorNameHTC(
    XrSpace anchor,
    XrSpatialAnchorNameHTC* name) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_space_info.getWithInstanceInfo(anchor);
        GenValidUsageXrHandleInfo *gen_space_info = info_with_instance.first;
        (void)gen_space_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetSpatialAnchorNameHTC(anchor, name);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetSpatialAnchorNameHTC(
    XrSpace anchor,
    XrSpatialAnchorNameHTC* name) {
    XrResult test_result = GenValidUsageInputsXrGetSpatialAnchorNameHTC(anchor, name);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetSpatialAnchorNameHTC(anchor, name);
}


// ---- XR_MNDX_force_feedback_curl extension commands
XrResult GenValidUsageInputsXrApplyForceFeedbackCurlMNDX(
XrHandTrackerEXT handTracker,
const XrForceFeedbackCurlApplyLocationsMNDX* locations) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(handTracker, XR_OBJECT_TYPE_HAND_TRACKER_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrHandTrackerEXTHandle(&handTracker);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrHandTrackerEXT handle \"handTracker\" ";
                oss << HandleToHexString(handTracker);
                CoreValidLogMessage(nullptr, "VUID-xrApplyForceFeedbackCurlMNDX-handTracker-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyForceFeedbackCurlMNDX",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locations) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyForceFeedbackCurlMNDX-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyForceFeedbackCurlMNDX", objects_info,
                                "Invalid NULL for XrForceFeedbackCurlApplyLocationsMNDX \"locations\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrForceFeedbackCurlApplyLocationsMNDX is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrApplyForceFeedbackCurlMNDX", objects_info,
                                                        true, locations);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrApplyForceFeedbackCurlMNDX-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrApplyForceFeedbackCurlMNDX",
                                objects_info,
                                "Command xrApplyForceFeedbackCurlMNDX param locations is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrApplyForceFeedbackCurlMNDX(
    XrHandTrackerEXT handTracker,
    const XrForceFeedbackCurlApplyLocationsMNDX* locations) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_handtrackerext_info.getWithInstanceInfo(handTracker);
        GenValidUsageXrHandleInfo *gen_handtrackerext_info = info_with_instance.first;
        (void)gen_handtrackerext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->ApplyForceFeedbackCurlMNDX(handTracker, locations);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrApplyForceFeedbackCurlMNDX(
    XrHandTrackerEXT handTracker,
    const XrForceFeedbackCurlApplyLocationsMNDX* locations) {
    XrResult test_result = GenValidUsageInputsXrApplyForceFeedbackCurlMNDX(handTracker, locations);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrApplyForceFeedbackCurlMNDX(handTracker, locations);
}


// ---- XR_EXT_plane_detection extension commands
XrResult GenValidUsageInputsXrCreatePlaneDetectorEXT(
XrSession session,
const XrPlaneDetectorCreateInfoEXT* createInfo,
XrPlaneDetectorEXT* planeDetector) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(session, XR_OBJECT_TYPE_SESSION);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrSessionHandle(&session);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrSession handle \"session\" ";
                oss << HandleToHexString(session);
                CoreValidLogMessage(nullptr, "VUID-xrCreatePlaneDetectorEXT-session-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePlaneDetectorEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == createInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePlaneDetectorEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePlaneDetectorEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorCreateInfoEXT \"createInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPlaneDetectorCreateInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrCreatePlaneDetectorEXT", objects_info,
                                                        true, createInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePlaneDetectorEXT-createInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePlaneDetectorEXT",
                                objects_info,
                                "Command xrCreatePlaneDetectorEXT param createInfo is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == planeDetector) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrCreatePlaneDetectorEXT-planeDetector-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrCreatePlaneDetectorEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorEXT \"planeDetector\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrCreatePlaneDetectorEXT(
    XrSession session,
    const XrPlaneDetectorCreateInfoEXT* createInfo,
    XrPlaneDetectorEXT* planeDetector) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_session_info.getWithInstanceInfo(session);
        GenValidUsageXrHandleInfo *gen_session_info = info_with_instance.first;
        (void)gen_session_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->CreatePlaneDetectorEXT(session, createInfo, planeDetector);
        if (XR_SUCCESS == result && nullptr != planeDetector) {
            std::unique_ptr<GenValidUsageXrHandleInfo> handle_info(new GenValidUsageXrHandleInfo());
            handle_info->instance_info = gen_instance_info;
            handle_info->direct_parent_type = XR_OBJECT_TYPE_SESSION;
            handle_info->direct_parent_handle = MakeHandleGeneric(session);
            g_planedetectorext_info.insert(*planeDetector, std::move(handle_info));
        }
    } catch (std::bad_alloc&) {
        result = XR_ERROR_OUT_OF_MEMORY;
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrCreatePlaneDetectorEXT(
    XrSession session,
    const XrPlaneDetectorCreateInfoEXT* createInfo,
    XrPlaneDetectorEXT* planeDetector) {
    XrResult test_result = GenValidUsageInputsXrCreatePlaneDetectorEXT(session, createInfo, planeDetector);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrCreatePlaneDetectorEXT(session, createInfo, planeDetector);
}

XrResult GenValidUsageInputsXrDestroyPlaneDetectorEXT(
XrPlaneDetectorEXT planeDetector) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(planeDetector, XR_OBJECT_TYPE_PLANE_DETECTOR_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPlaneDetectorEXTHandle(&planeDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPlaneDetectorEXT handle \"planeDetector\" ";
                oss << HandleToHexString(planeDetector);
                CoreValidLogMessage(nullptr, "VUID-xrDestroyPlaneDetectorEXT-planeDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrDestroyPlaneDetectorEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrDestroyPlaneDetectorEXT(
    XrPlaneDetectorEXT planeDetector) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->DestroyPlaneDetectorEXT(planeDetector);
        if (XR_SUCCEEDED(result)) {
            g_planedetectorext_info.erase(planeDetector);
        }
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrDestroyPlaneDetectorEXT(
    XrPlaneDetectorEXT planeDetector) {
    XrResult test_result = GenValidUsageInputsXrDestroyPlaneDetectorEXT(planeDetector);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrDestroyPlaneDetectorEXT(planeDetector);
}

XrResult GenValidUsageInputsXrBeginPlaneDetectionEXT(
XrPlaneDetectorEXT planeDetector,
const XrPlaneDetectorBeginInfoEXT* beginInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(planeDetector, XR_OBJECT_TYPE_PLANE_DETECTOR_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPlaneDetectorEXTHandle(&planeDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPlaneDetectorEXT handle \"planeDetector\" ";
                oss << HandleToHexString(planeDetector);
                CoreValidLogMessage(nullptr, "VUID-xrBeginPlaneDetectionEXT-planeDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginPlaneDetectionEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == beginInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrBeginPlaneDetectionEXT-beginInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginPlaneDetectionEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorBeginInfoEXT \"beginInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPlaneDetectorBeginInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrBeginPlaneDetectionEXT", objects_info,
                                                        true, beginInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrBeginPlaneDetectionEXT-beginInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrBeginPlaneDetectionEXT",
                                objects_info,
                                "Command xrBeginPlaneDetectionEXT param beginInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrBeginPlaneDetectionEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorBeginInfoEXT* beginInfo) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->BeginPlaneDetectionEXT(planeDetector, beginInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrBeginPlaneDetectionEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorBeginInfoEXT* beginInfo) {
    XrResult test_result = GenValidUsageInputsXrBeginPlaneDetectionEXT(planeDetector, beginInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrBeginPlaneDetectionEXT(planeDetector, beginInfo);
}

XrResult GenValidUsageInputsXrGetPlaneDetectionStateEXT(
XrPlaneDetectorEXT planeDetector,
XrPlaneDetectionStateEXT* state) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(planeDetector, XR_OBJECT_TYPE_PLANE_DETECTOR_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPlaneDetectorEXTHandle(&planeDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPlaneDetectorEXT handle \"planeDetector\" ";
                oss << HandleToHexString(planeDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetPlaneDetectionStateEXT-planeDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionStateEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == state) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionStateEXT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionStateEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectionStateEXT \"state\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Make sure the enum type XrPlaneDetectionStateEXT value is valid
        if (!ValidateXrEnum(gen_instance_info, "xrGetPlaneDetectionStateEXT", "xrGetPlaneDetectionStateEXT", "state", objects_info, *state)) {
            std::ostringstream oss_enum;
            oss_enum << "Invalid XrPlaneDetectionStateEXT \"state\" enum value ";
            oss_enum << Uint32ToHexString(static_cast<uint32_t>(*state));
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionStateEXT-state-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionStateEXT",
                                objects_info, oss_enum.str());
            return XR_ERROR_VALIDATION_FAILURE;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetPlaneDetectionStateEXT(
    XrPlaneDetectorEXT planeDetector,
    XrPlaneDetectionStateEXT* state) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetPlaneDetectionStateEXT(planeDetector, state);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetPlaneDetectionStateEXT(
    XrPlaneDetectorEXT planeDetector,
    XrPlaneDetectionStateEXT* state) {
    XrResult test_result = GenValidUsageInputsXrGetPlaneDetectionStateEXT(planeDetector, state);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetPlaneDetectionStateEXT(planeDetector, state);
}

XrResult GenValidUsageInputsXrGetPlaneDetectionsEXT(
XrPlaneDetectorEXT planeDetector,
const XrPlaneDetectorGetInfoEXT* info,
XrPlaneDetectorLocationsEXT* locations) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(planeDetector, XR_OBJECT_TYPE_PLANE_DETECTOR_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPlaneDetectorEXTHandle(&planeDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPlaneDetectorEXT handle \"planeDetector\" ";
                oss << HandleToHexString(planeDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetPlaneDetectionsEXT-planeDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionsEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == info) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionsEXT-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionsEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorGetInfoEXT \"info\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPlaneDetectorGetInfoEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetPlaneDetectionsEXT", objects_info,
                                                        true, info);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionsEXT-info-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionsEXT",
                                objects_info,
                                "Command xrGetPlaneDetectionsEXT param info is invalid");
            return xr_result;
        }
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == locations) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionsEXT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionsEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorLocationsEXT \"locations\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPlaneDetectorLocationsEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetPlaneDetectionsEXT", objects_info,
                                                        false, locations);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlaneDetectionsEXT-locations-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlaneDetectionsEXT",
                                objects_info,
                                "Command xrGetPlaneDetectionsEXT param locations is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetPlaneDetectionsEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorGetInfoEXT* info,
    XrPlaneDetectorLocationsEXT* locations) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetPlaneDetectionsEXT(planeDetector, info, locations);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetPlaneDetectionsEXT(
    XrPlaneDetectorEXT planeDetector,
    const XrPlaneDetectorGetInfoEXT* info,
    XrPlaneDetectorLocationsEXT* locations) {
    XrResult test_result = GenValidUsageInputsXrGetPlaneDetectionsEXT(planeDetector, info, locations);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetPlaneDetectionsEXT(planeDetector, info, locations);
}

XrResult GenValidUsageInputsXrGetPlanePolygonBufferEXT(
XrPlaneDetectorEXT planeDetector,
uint64_t planeId,
uint32_t polygonBufferIndex,
XrPlaneDetectorPolygonBufferEXT* polygonBuffer) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(planeDetector, XR_OBJECT_TYPE_PLANE_DETECTOR_EXT);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrPlaneDetectorEXTHandle(&planeDetector);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrPlaneDetectorEXT handle \"planeDetector\" ";
                oss << HandleToHexString(planeDetector);
                CoreValidLogMessage(nullptr, "VUID-xrGetPlanePolygonBufferEXT-planeDetector-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlanePolygonBufferEXT",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == polygonBuffer) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlanePolygonBufferEXT-polygonBuffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlanePolygonBufferEXT", objects_info,
                                "Invalid NULL for XrPlaneDetectorPolygonBufferEXT \"polygonBuffer\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrPlaneDetectorPolygonBufferEXT is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrGetPlanePolygonBufferEXT", objects_info,
                                                        false, polygonBuffer);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrGetPlanePolygonBufferEXT-polygonBuffer-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetPlanePolygonBufferEXT",
                                objects_info,
                                "Command xrGetPlanePolygonBufferEXT param polygonBuffer is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrGetPlanePolygonBufferEXT(
    XrPlaneDetectorEXT planeDetector,
    uint64_t planeId,
    uint32_t polygonBufferIndex,
    XrPlaneDetectorPolygonBufferEXT* polygonBuffer) {
    XrResult result = XR_SUCCESS;
    try {
        auto info_with_instance = g_planedetectorext_info.getWithInstanceInfo(planeDetector);
        GenValidUsageXrHandleInfo *gen_planedetectorext_info = info_with_instance.first;
        (void)gen_planedetectorext_info;  // quiet warnings
        GenValidUsageXrInstanceInfo *gen_instance_info = info_with_instance.second;
        result = gen_instance_info->dispatch_table->GetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetPlanePolygonBufferEXT(
    XrPlaneDetectorEXT planeDetector,
    uint64_t planeId,
    uint32_t polygonBufferIndex,
    XrPlaneDetectorPolygonBufferEXT* polygonBuffer) {
    XrResult test_result = GenValidUsageInputsXrGetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrGetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
}


// ---- XR_ML_user_calibration extension commands
XrResult GenValidUsageInputsXrEnableUserCalibrationEventsML(
XrInstance instance,
const XrUserCalibrationEnableEventsInfoML* enableInfo) {
    try {
        XrResult xr_result = XR_SUCCESS;
        std::vector<GenValidUsageXrObjectInfo> objects_info;
        objects_info.emplace_back(instance, XR_OBJECT_TYPE_INSTANCE);

        {
            // writeValidateInlineHandleValidation
            ValidateXrHandleResult handle_result = VerifyXrInstanceHandle(&instance);
            if (handle_result != VALIDATE_XR_HANDLE_SUCCESS) {
                // Not a valid handle or NULL (which is not valid in this case)
                std::ostringstream oss;
                oss << "Invalid XrInstance handle \"instance\" ";
                oss << HandleToHexString(instance);
                CoreValidLogMessage(nullptr, "VUID-xrEnableUserCalibrationEventsML-instance-parameter",
                                    VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableUserCalibrationEventsML",
                                    objects_info, oss.str());
                return XR_ERROR_HANDLE_INVALID;
            }
        }
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        (void)gen_instance_info;  // quiet warnings
        // Non-optional pointer/array variable that needs to not be NULL
        if (nullptr == enableInfo) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnableUserCalibrationEventsML-enableInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableUserCalibrationEventsML", objects_info,
                                "Invalid NULL for XrUserCalibrationEnableEventsInfoML \"enableInfo\" which is not "
                                "optional and must be non-NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        // Validate that the structure XrUserCalibrationEnableEventsInfoML is valid
        xr_result = ValidateXrStruct(gen_instance_info, "xrEnableUserCalibrationEventsML", objects_info,
                                                        true, enableInfo);
        if (XR_SUCCESS != xr_result) {
            CoreValidLogMessage(gen_instance_info, "VUID-xrEnableUserCalibrationEventsML-enableInfo-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrEnableUserCalibrationEventsML",
                                objects_info,
                                "Command xrEnableUserCalibrationEventsML param enableInfo is invalid");
            return xr_result;
        }
        return xr_result;
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageNextXrEnableUserCalibrationEventsML(
    XrInstance instance,
    const XrUserCalibrationEnableEventsInfoML* enableInfo) {
    XrResult result = XR_SUCCESS;
    try {
        GenValidUsageXrInstanceInfo *gen_instance_info = g_instance_info.get(instance);
        result = gen_instance_info->dispatch_table->EnableUserCalibrationEventsML(instance, enableInfo);
    } catch (...) {
        result = XR_ERROR_VALIDATION_FAILURE;
    }
    return result;
}

XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrEnableUserCalibrationEventsML(
    XrInstance instance,
    const XrUserCalibrationEnableEventsInfoML* enableInfo) {
    XrResult test_result = GenValidUsageInputsXrEnableUserCalibrationEventsML(instance, enableInfo);
    if (XR_SUCCESS != test_result) {
        return test_result;
    }
    return GenValidUsageNextXrEnableUserCalibrationEventsML(instance, enableInfo);
}

static PFN_xrVoidFunction GenValidUsageInnerGetInstanceProcAddr(
    const char*                                 name) {
        std::string func_name = name;


        // ---- Core 1.0 commands
        if (func_name == "xrGetInstanceProcAddr") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetInstanceProcAddr);
        }
        if (func_name == "xrCreateInstance") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrCreateInstance);
        }
        if (func_name == "xrDestroyInstance") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrDestroyInstance);
        }
        if (func_name == "xrGetInstanceProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetInstanceProperties);
        }
        if (func_name == "xrPollEvent") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPollEvent);
        }
        if (func_name == "xrResultToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrResultToString);
        }
        if (func_name == "xrStructureTypeToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrStructureTypeToString);
        }
        if (func_name == "xrGetSystem") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSystem);
        }
        if (func_name == "xrGetSystemProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSystemProperties);
        }
        if (func_name == "xrEnumerateEnvironmentBlendModes") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateEnvironmentBlendModes);
        }
        if (func_name == "xrCreateSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrCreateSession);
        }
        if (func_name == "xrDestroySession") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySession);
        }
        if (func_name == "xrEnumerateReferenceSpaces") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateReferenceSpaces);
        }
        if (func_name == "xrCreateReferenceSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateReferenceSpace);
        }
        if (func_name == "xrGetReferenceSpaceBoundsRect") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetReferenceSpaceBoundsRect);
        }
        if (func_name == "xrCreateActionSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateActionSpace);
        }
        if (func_name == "xrLocateSpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLocateSpace);
        }
        if (func_name == "xrDestroySpace") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySpace);
        }
        if (func_name == "xrEnumerateViewConfigurations") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateViewConfigurations);
        }
        if (func_name == "xrGetViewConfigurationProperties") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetViewConfigurationProperties);
        }
        if (func_name == "xrEnumerateViewConfigurationViews") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateViewConfigurationViews);
        }
        if (func_name == "xrEnumerateSwapchainFormats") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateSwapchainFormats);
        }
        if (func_name == "xrCreateSwapchain") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSwapchain);
        }
        if (func_name == "xrDestroySwapchain") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySwapchain);
        }
        if (func_name == "xrEnumerateSwapchainImages") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateSwapchainImages);
        }
        if (func_name == "xrAcquireSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrAcquireSwapchainImage);
        }
        if (func_name == "xrWaitSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrWaitSwapchainImage);
        }
        if (func_name == "xrReleaseSwapchainImage") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrReleaseSwapchainImage);
        }
        if (func_name == "xrBeginSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrBeginSession);
        }
        if (func_name == "xrEndSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEndSession);
        }
        if (func_name == "xrRequestExitSession") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrRequestExitSession);
        }
        if (func_name == "xrWaitFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrWaitFrame);
        }
        if (func_name == "xrBeginFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrBeginFrame);
        }
        if (func_name == "xrEndFrame") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEndFrame);
        }
        if (func_name == "xrLocateViews") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLocateViews);
        }
        if (func_name == "xrStringToPath") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrStringToPath);
        }
        if (func_name == "xrPathToString") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPathToString);
        }
        if (func_name == "xrCreateActionSet") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateActionSet);
        }
        if (func_name == "xrDestroyActionSet") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyActionSet);
        }
        if (func_name == "xrCreateAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateAction);
        }
        if (func_name == "xrDestroyAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyAction);
        }
        if (func_name == "xrSuggestInteractionProfileBindings") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSuggestInteractionProfileBindings);
        }
        if (func_name == "xrAttachSessionActionSets") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrAttachSessionActionSets);
        }
        if (func_name == "xrGetCurrentInteractionProfile") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetCurrentInteractionProfile);
        }
        if (func_name == "xrGetActionStateBoolean") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetActionStateBoolean);
        }
        if (func_name == "xrGetActionStateFloat") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetActionStateFloat);
        }
        if (func_name == "xrGetActionStateVector2f") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetActionStateVector2f);
        }
        if (func_name == "xrGetActionStatePose") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetActionStatePose);
        }
        if (func_name == "xrSyncActions") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSyncActions);
        }
        if (func_name == "xrEnumerateBoundSourcesForAction") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateBoundSourcesForAction);
        }
        if (func_name == "xrGetInputSourceLocalizedName") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetInputSourceLocalizedName);
        }
        if (func_name == "xrApplyHapticFeedback") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrApplyHapticFeedback);
        }
        if (func_name == "xrStopHapticFeedback") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrStopHapticFeedback);
        }

        // ---- Core ERSION.1.0 commands

        // ---- XR_KHR_android_thread_settings extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
        if (func_name == "xrSetAndroidApplicationThreadKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetAndroidApplicationThreadKHR);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID)

        // ---- XR_KHR_android_surface_swapchain extension commands
#if defined(XR_USE_PLATFORM_ANDROID)
        if (func_name == "xrCreateSwapchainAndroidSurfaceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSwapchainAndroidSurfaceKHR);
        }
#endif // defined(XR_USE_PLATFORM_ANDROID)

        // ---- XR_KHR_opengl_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL)
        if (func_name == "xrGetOpenGLGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetOpenGLGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL)

        // ---- XR_KHR_opengl_es_enable extension commands
#if defined(XR_USE_GRAPHICS_API_OPENGL_ES)
        if (func_name == "xrGetOpenGLESGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetOpenGLESGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_OPENGL_ES)

        // ---- XR_KHR_vulkan_enable extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanInstanceExtensionsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanInstanceExtensionsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanDeviceExtensionsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanDeviceExtensionsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsDeviceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanGraphicsDeviceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanGraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

        // ---- XR_KHR_D3D11_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D11)
        if (func_name == "xrGetD3D11GraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetD3D11GraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D11)

        // ---- XR_KHR_D3D12_enable extension commands
#if defined(XR_USE_GRAPHICS_API_D3D12)
        if (func_name == "xrGetD3D12GraphicsRequirementsKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetD3D12GraphicsRequirementsKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_D3D12)

        // ---- XR_KHR_visibility_mask extension commands
        if (func_name == "xrGetVisibilityMaskKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVisibilityMaskKHR);
        }

        // ---- XR_KHR_win32_convert_performance_counter_time extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrConvertWin32PerformanceCounterToTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrConvertWin32PerformanceCounterToTimeKHR);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrConvertTimeToWin32PerformanceCounterKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrConvertTimeToWin32PerformanceCounterKHR);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_KHR_convert_timespec_time extension commands
#if defined(XR_USE_TIMESPEC)
        if (func_name == "xrConvertTimespecTimeToTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrConvertTimespecTimeToTimeKHR);
        }
#endif // defined(XR_USE_TIMESPEC)
#if defined(XR_USE_TIMESPEC)
        if (func_name == "xrConvertTimeToTimespecTimeKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrConvertTimeToTimespecTimeKHR);
        }
#endif // defined(XR_USE_TIMESPEC)

        // ---- XR_KHR_loader_init extension commands

        // ---- XR_KHR_vulkan_enable2 extension commands
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrCreateVulkanInstanceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateVulkanInstanceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrCreateVulkanDeviceKHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateVulkanDeviceKHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsDevice2KHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanGraphicsDevice2KHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)
#if defined(XR_USE_GRAPHICS_API_VULKAN)
        if (func_name == "xrGetVulkanGraphicsRequirements2KHR") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVulkanGraphicsRequirements2KHR);
        }
#endif // defined(XR_USE_GRAPHICS_API_VULKAN)

        // ---- XR_EXT_performance_settings extension commands
        if (func_name == "xrPerfSettingsSetPerformanceLevelEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPerfSettingsSetPerformanceLevelEXT);
        }

        // ---- XR_EXT_thermal_query extension commands
        if (func_name == "xrThermalGetTemperatureTrendEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrThermalGetTemperatureTrendEXT);
        }

        // ---- XR_EXT_debug_utils extension commands
        if (func_name == "xrSetDebugUtilsObjectNameEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrSetDebugUtilsObjectNameEXT);
        }
        if (func_name == "xrCreateDebugUtilsMessengerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrCreateDebugUtilsMessengerEXT);
        }
        if (func_name == "xrDestroyDebugUtilsMessengerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrDestroyDebugUtilsMessengerEXT);
        }
        if (func_name == "xrSubmitDebugUtilsMessageEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSubmitDebugUtilsMessageEXT);
        }
        if (func_name == "xrSessionBeginDebugUtilsLabelRegionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrSessionBeginDebugUtilsLabelRegionEXT);
        }
        if (func_name == "xrSessionEndDebugUtilsLabelRegionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrSessionEndDebugUtilsLabelRegionEXT);
        }
        if (func_name == "xrSessionInsertDebugUtilsLabelEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(CoreValidationXrSessionInsertDebugUtilsLabelEXT);
        }

        // ---- XR_MSFT_spatial_anchor extension commands
        if (func_name == "xrCreateSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorMSFT);
        }
        if (func_name == "xrCreateSpatialAnchorSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorSpaceMSFT);
        }
        if (func_name == "xrDestroySpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySpatialAnchorMSFT);
        }

        // ---- XR_EXT_conformance_automation extension commands
        if (func_name == "xrSetInputDeviceActiveEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetInputDeviceActiveEXT);
        }
        if (func_name == "xrSetInputDeviceStateBoolEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetInputDeviceStateBoolEXT);
        }
        if (func_name == "xrSetInputDeviceStateFloatEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetInputDeviceStateFloatEXT);
        }
        if (func_name == "xrSetInputDeviceStateVector2fEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetInputDeviceStateVector2fEXT);
        }
        if (func_name == "xrSetInputDeviceLocationEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetInputDeviceLocationEXT);
        }

        // ---- XR_MSFT_spatial_graph_bridge extension commands
        if (func_name == "xrCreateSpatialGraphNodeSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialGraphNodeSpaceMSFT);
        }
        if (func_name == "xrTryCreateSpatialGraphStaticNodeBindingMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTryCreateSpatialGraphStaticNodeBindingMSFT);
        }
        if (func_name == "xrDestroySpatialGraphNodeBindingMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySpatialGraphNodeBindingMSFT);
        }
        if (func_name == "xrGetSpatialGraphNodeBindingPropertiesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpatialGraphNodeBindingPropertiesMSFT);
        }

        // ---- XR_EXT_hand_tracking extension commands
        if (func_name == "xrCreateHandTrackerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateHandTrackerEXT);
        }
        if (func_name == "xrDestroyHandTrackerEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyHandTrackerEXT);
        }
        if (func_name == "xrLocateHandJointsEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLocateHandJointsEXT);
        }

        // ---- XR_MSFT_hand_tracking_mesh extension commands
        if (func_name == "xrCreateHandMeshSpaceMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateHandMeshSpaceMSFT);
        }
        if (func_name == "xrUpdateHandMeshMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrUpdateHandMeshMSFT);
        }

        // ---- XR_MSFT_controller_model extension commands
        if (func_name == "xrGetControllerModelKeyMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetControllerModelKeyMSFT);
        }
        if (func_name == "xrLoadControllerModelMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLoadControllerModelMSFT);
        }
        if (func_name == "xrGetControllerModelPropertiesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetControllerModelPropertiesMSFT);
        }
        if (func_name == "xrGetControllerModelStateMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetControllerModelStateMSFT);
        }

        // ---- XR_MSFT_perception_anchor_interop extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrCreateSpatialAnchorFromPerceptionAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorFromPerceptionAnchorMSFT);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrTryGetPerceptionAnchorFromSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTryGetPerceptionAnchorFromSpatialAnchorMSFT);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_MSFT_composition_layer_reprojection extension commands
        if (func_name == "xrEnumerateReprojectionModesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateReprojectionModesMSFT);
        }

        // ---- XR_FB_swapchain_update_state extension commands
        if (func_name == "xrUpdateSwapchainFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrUpdateSwapchainFB);
        }
        if (func_name == "xrGetSwapchainStateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSwapchainStateFB);
        }

        // ---- XR_FB_body_tracking extension commands
        if (func_name == "xrCreateBodyTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateBodyTrackerFB);
        }
        if (func_name == "xrDestroyBodyTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyBodyTrackerFB);
        }
        if (func_name == "xrLocateBodyJointsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLocateBodyJointsFB);
        }
        if (func_name == "xrGetBodySkeletonFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetBodySkeletonFB);
        }

        // ---- XR_MSFT_scene_understanding extension commands
        if (func_name == "xrEnumerateSceneComputeFeaturesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateSceneComputeFeaturesMSFT);
        }
        if (func_name == "xrCreateSceneObserverMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSceneObserverMSFT);
        }
        if (func_name == "xrDestroySceneObserverMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySceneObserverMSFT);
        }
        if (func_name == "xrCreateSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSceneMSFT);
        }
        if (func_name == "xrDestroySceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySceneMSFT);
        }
        if (func_name == "xrComputeNewSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrComputeNewSceneMSFT);
        }
        if (func_name == "xrGetSceneComputeStateMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSceneComputeStateMSFT);
        }
        if (func_name == "xrGetSceneComponentsMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSceneComponentsMSFT);
        }
        if (func_name == "xrLocateSceneComponentsMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLocateSceneComponentsMSFT);
        }
        if (func_name == "xrGetSceneMeshBuffersMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSceneMeshBuffersMSFT);
        }

        // ---- XR_MSFT_scene_understanding_serialization extension commands
        if (func_name == "xrDeserializeSceneMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDeserializeSceneMSFT);
        }
        if (func_name == "xrGetSerializedSceneFragmentDataMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSerializedSceneFragmentDataMSFT);
        }

        // ---- XR_FB_display_refresh_rate extension commands
        if (func_name == "xrEnumerateDisplayRefreshRatesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateDisplayRefreshRatesFB);
        }
        if (func_name == "xrGetDisplayRefreshRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetDisplayRefreshRateFB);
        }
        if (func_name == "xrRequestDisplayRefreshRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrRequestDisplayRefreshRateFB);
        }

        // ---- XR_HTCX_vive_tracker_interaction extension commands
        if (func_name == "xrEnumerateViveTrackerPathsHTCX") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateViveTrackerPathsHTCX);
        }

        // ---- XR_HTC_facial_tracking extension commands
        if (func_name == "xrCreateFacialTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateFacialTrackerHTC);
        }
        if (func_name == "xrDestroyFacialTrackerHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyFacialTrackerHTC);
        }
        if (func_name == "xrGetFacialExpressionsHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetFacialExpressionsHTC);
        }

        // ---- XR_FB_color_space extension commands
        if (func_name == "xrEnumerateColorSpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateColorSpacesFB);
        }
        if (func_name == "xrSetColorSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetColorSpaceFB);
        }

        // ---- XR_FB_hand_tracking_mesh extension commands
        if (func_name == "xrGetHandMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetHandMeshFB);
        }

        // ---- XR_FB_spatial_entity extension commands
        if (func_name == "xrCreateSpatialAnchorFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorFB);
        }
        if (func_name == "xrGetSpaceUuidFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceUuidFB);
        }
        if (func_name == "xrEnumerateSpaceSupportedComponentsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateSpaceSupportedComponentsFB);
        }
        if (func_name == "xrSetSpaceComponentStatusFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetSpaceComponentStatusFB);
        }
        if (func_name == "xrGetSpaceComponentStatusFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceComponentStatusFB);
        }

        // ---- XR_FB_foveation extension commands
        if (func_name == "xrCreateFoveationProfileFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateFoveationProfileFB);
        }
        if (func_name == "xrDestroyFoveationProfileFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyFoveationProfileFB);
        }

        // ---- XR_FB_keyboard_tracking extension commands
        if (func_name == "xrQuerySystemTrackedKeyboardFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrQuerySystemTrackedKeyboardFB);
        }
        if (func_name == "xrCreateKeyboardSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateKeyboardSpaceFB);
        }

        // ---- XR_FB_triangle_mesh extension commands
        if (func_name == "xrCreateTriangleMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateTriangleMeshFB);
        }
        if (func_name == "xrDestroyTriangleMeshFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyTriangleMeshFB);
        }
        if (func_name == "xrTriangleMeshGetVertexBufferFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshGetVertexBufferFB);
        }
        if (func_name == "xrTriangleMeshGetIndexBufferFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshGetIndexBufferFB);
        }
        if (func_name == "xrTriangleMeshBeginUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshBeginUpdateFB);
        }
        if (func_name == "xrTriangleMeshEndUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshEndUpdateFB);
        }
        if (func_name == "xrTriangleMeshBeginVertexBufferUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshBeginVertexBufferUpdateFB);
        }
        if (func_name == "xrTriangleMeshEndVertexBufferUpdateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrTriangleMeshEndVertexBufferUpdateFB);
        }

        // ---- XR_FB_passthrough extension commands
        if (func_name == "xrCreatePassthroughFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreatePassthroughFB);
        }
        if (func_name == "xrDestroyPassthroughFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyPassthroughFB);
        }
        if (func_name == "xrPassthroughStartFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughStartFB);
        }
        if (func_name == "xrPassthroughPauseFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughPauseFB);
        }
        if (func_name == "xrCreatePassthroughLayerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreatePassthroughLayerFB);
        }
        if (func_name == "xrDestroyPassthroughLayerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyPassthroughLayerFB);
        }
        if (func_name == "xrPassthroughLayerPauseFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughLayerPauseFB);
        }
        if (func_name == "xrPassthroughLayerResumeFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughLayerResumeFB);
        }
        if (func_name == "xrPassthroughLayerSetStyleFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughLayerSetStyleFB);
        }
        if (func_name == "xrCreateGeometryInstanceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateGeometryInstanceFB);
        }
        if (func_name == "xrDestroyGeometryInstanceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyGeometryInstanceFB);
        }
        if (func_name == "xrGeometryInstanceSetTransformFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGeometryInstanceSetTransformFB);
        }

        // ---- XR_FB_render_model extension commands
        if (func_name == "xrEnumerateRenderModelPathsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateRenderModelPathsFB);
        }
        if (func_name == "xrGetRenderModelPropertiesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetRenderModelPropertiesFB);
        }
        if (func_name == "xrLoadRenderModelFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrLoadRenderModelFB);
        }

        // ---- XR_VARJO_environment_depth_estimation extension commands
        if (func_name == "xrSetEnvironmentDepthEstimationVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetEnvironmentDepthEstimationVARJO);
        }

        // ---- XR_VARJO_marker_tracking extension commands
        if (func_name == "xrSetMarkerTrackingVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetMarkerTrackingVARJO);
        }
        if (func_name == "xrSetMarkerTrackingTimeoutVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetMarkerTrackingTimeoutVARJO);
        }
        if (func_name == "xrSetMarkerTrackingPredictionVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetMarkerTrackingPredictionVARJO);
        }
        if (func_name == "xrGetMarkerSizeVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerSizeVARJO);
        }
        if (func_name == "xrCreateMarkerSpaceVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateMarkerSpaceVARJO);
        }

        // ---- XR_VARJO_view_offset extension commands
        if (func_name == "xrSetViewOffsetVARJO") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetViewOffsetVARJO);
        }

        // ---- XR_ML_compat extension commands
#if defined(XR_USE_PLATFORM_ML)
        if (func_name == "xrCreateSpaceFromCoordinateFrameUIDML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpaceFromCoordinateFrameUIDML);
        }
#endif // defined(XR_USE_PLATFORM_ML)

        // ---- XR_ML_marker_understanding extension commands
        if (func_name == "xrCreateMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateMarkerDetectorML);
        }
        if (func_name == "xrDestroyMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyMarkerDetectorML);
        }
        if (func_name == "xrSnapshotMarkerDetectorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSnapshotMarkerDetectorML);
        }
        if (func_name == "xrGetMarkerDetectorStateML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerDetectorStateML);
        }
        if (func_name == "xrGetMarkersML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkersML);
        }
        if (func_name == "xrGetMarkerReprojectionErrorML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerReprojectionErrorML);
        }
        if (func_name == "xrGetMarkerLengthML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerLengthML);
        }
        if (func_name == "xrGetMarkerNumberML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerNumberML);
        }
        if (func_name == "xrGetMarkerStringML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetMarkerStringML);
        }
        if (func_name == "xrCreateMarkerSpaceML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateMarkerSpaceML);
        }

        // ---- XR_ML_localization_map extension commands
        if (func_name == "xrEnableLocalizationEventsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnableLocalizationEventsML);
        }
        if (func_name == "xrQueryLocalizationMapsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrQueryLocalizationMapsML);
        }
        if (func_name == "xrRequestMapLocalizationML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrRequestMapLocalizationML);
        }
        if (func_name == "xrImportLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrImportLocalizationMapML);
        }
        if (func_name == "xrCreateExportedLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateExportedLocalizationMapML);
        }
        if (func_name == "xrDestroyExportedLocalizationMapML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyExportedLocalizationMapML);
        }
        if (func_name == "xrGetExportedLocalizationMapDataML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetExportedLocalizationMapDataML);
        }

        // ---- XR_MSFT_spatial_anchor_persistence extension commands
        if (func_name == "xrCreateSpatialAnchorStoreConnectionMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorStoreConnectionMSFT);
        }
        if (func_name == "xrDestroySpatialAnchorStoreConnectionMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySpatialAnchorStoreConnectionMSFT);
        }
        if (func_name == "xrPersistSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPersistSpatialAnchorMSFT);
        }
        if (func_name == "xrEnumeratePersistedSpatialAnchorNamesMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumeratePersistedSpatialAnchorNamesMSFT);
        }
        if (func_name == "xrCreateSpatialAnchorFromPersistedNameMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorFromPersistedNameMSFT);
        }
        if (func_name == "xrUnpersistSpatialAnchorMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrUnpersistSpatialAnchorMSFT);
        }
        if (func_name == "xrClearSpatialAnchorStoreMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrClearSpatialAnchorStoreMSFT);
        }

        // ---- XR_MSFT_scene_marker extension commands
        if (func_name == "xrGetSceneMarkerRawDataMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSceneMarkerRawDataMSFT);
        }
        if (func_name == "xrGetSceneMarkerDecodedStringMSFT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSceneMarkerDecodedStringMSFT);
        }

        // ---- XR_FB_spatial_entity_query extension commands
        if (func_name == "xrQuerySpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrQuerySpacesFB);
        }
        if (func_name == "xrRetrieveSpaceQueryResultsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrRetrieveSpaceQueryResultsFB);
        }

        // ---- XR_FB_spatial_entity_storage extension commands
        if (func_name == "xrSaveSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSaveSpaceFB);
        }
        if (func_name == "xrEraseSpaceFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEraseSpaceFB);
        }

        // ---- XR_OCULUS_audio_device_guid extension commands
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrGetAudioOutputDeviceGuidOculus") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetAudioOutputDeviceGuidOculus);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)
#if defined(XR_USE_PLATFORM_WIN32)
        if (func_name == "xrGetAudioInputDeviceGuidOculus") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetAudioInputDeviceGuidOculus);
        }
#endif // defined(XR_USE_PLATFORM_WIN32)

        // ---- XR_FB_spatial_entity_sharing extension commands
        if (func_name == "xrShareSpacesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrShareSpacesFB);
        }

        // ---- XR_FB_scene extension commands
        if (func_name == "xrGetSpaceBoundingBox2DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceBoundingBox2DFB);
        }
        if (func_name == "xrGetSpaceBoundingBox3DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceBoundingBox3DFB);
        }
        if (func_name == "xrGetSpaceSemanticLabelsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceSemanticLabelsFB);
        }
        if (func_name == "xrGetSpaceBoundary2DFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceBoundary2DFB);
        }
        if (func_name == "xrGetSpaceRoomLayoutFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceRoomLayoutFB);
        }

        // ---- XR_ALMALENCE_digital_lens_control extension commands
        if (func_name == "xrSetDigitalLensControlALMALENCE") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetDigitalLensControlALMALENCE);
        }

        // ---- XR_FB_scene_capture extension commands
        if (func_name == "xrRequestSceneCaptureFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrRequestSceneCaptureFB);
        }

        // ---- XR_FB_spatial_entity_container extension commands
        if (func_name == "xrGetSpaceContainerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceContainerFB);
        }

        // ---- XR_META_foveation_eye_tracked extension commands
        if (func_name == "xrGetFoveationEyeTrackedStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetFoveationEyeTrackedStateMETA);
        }

        // ---- XR_FB_face_tracking extension commands
        if (func_name == "xrCreateFaceTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateFaceTrackerFB);
        }
        if (func_name == "xrDestroyFaceTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyFaceTrackerFB);
        }
        if (func_name == "xrGetFaceExpressionWeightsFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetFaceExpressionWeightsFB);
        }

        // ---- XR_FB_eye_tracking_social extension commands
        if (func_name == "xrCreateEyeTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateEyeTrackerFB);
        }
        if (func_name == "xrDestroyEyeTrackerFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyEyeTrackerFB);
        }
        if (func_name == "xrGetEyeGazesFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetEyeGazesFB);
        }

        // ---- XR_FB_passthrough_keyboard_hands extension commands
        if (func_name == "xrPassthroughLayerSetKeyboardHandsIntensityFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrPassthroughLayerSetKeyboardHandsIntensityFB);
        }

        // ---- XR_FB_haptic_pcm extension commands
        if (func_name == "xrGetDeviceSampleRateFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetDeviceSampleRateFB);
        }

        // ---- XR_META_passthrough_preferences extension commands
        if (func_name == "xrGetPassthroughPreferencesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetPassthroughPreferencesMETA);
        }

        // ---- XR_META_virtual_keyboard extension commands
        if (func_name == "xrCreateVirtualKeyboardMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateVirtualKeyboardMETA);
        }
        if (func_name == "xrDestroyVirtualKeyboardMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyVirtualKeyboardMETA);
        }
        if (func_name == "xrCreateVirtualKeyboardSpaceMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateVirtualKeyboardSpaceMETA);
        }
        if (func_name == "xrSuggestVirtualKeyboardLocationMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSuggestVirtualKeyboardLocationMETA);
        }
        if (func_name == "xrGetVirtualKeyboardScaleMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVirtualKeyboardScaleMETA);
        }
        if (func_name == "xrSetVirtualKeyboardModelVisibilityMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetVirtualKeyboardModelVisibilityMETA);
        }
        if (func_name == "xrGetVirtualKeyboardModelAnimationStatesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVirtualKeyboardModelAnimationStatesMETA);
        }
        if (func_name == "xrGetVirtualKeyboardDirtyTexturesMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVirtualKeyboardDirtyTexturesMETA);
        }
        if (func_name == "xrGetVirtualKeyboardTextureDataMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetVirtualKeyboardTextureDataMETA);
        }
        if (func_name == "xrSendVirtualKeyboardInputMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSendVirtualKeyboardInputMETA);
        }
        if (func_name == "xrChangeVirtualKeyboardTextContextMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrChangeVirtualKeyboardTextContextMETA);
        }

        // ---- XR_OCULUS_external_camera extension commands
        if (func_name == "xrEnumerateExternalCamerasOCULUS") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumerateExternalCamerasOCULUS);
        }

        // ---- XR_META_performance_metrics extension commands
        if (func_name == "xrEnumeratePerformanceMetricsCounterPathsMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnumeratePerformanceMetricsCounterPathsMETA);
        }
        if (func_name == "xrSetPerformanceMetricsStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetPerformanceMetricsStateMETA);
        }
        if (func_name == "xrGetPerformanceMetricsStateMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetPerformanceMetricsStateMETA);
        }
        if (func_name == "xrQueryPerformanceMetricsCounterMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrQueryPerformanceMetricsCounterMETA);
        }

        // ---- XR_FB_spatial_entity_storage_batch extension commands
        if (func_name == "xrSaveSpaceListFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSaveSpaceListFB);
        }

        // ---- XR_FB_spatial_entity_user extension commands
        if (func_name == "xrCreateSpaceUserFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpaceUserFB);
        }
        if (func_name == "xrGetSpaceUserIdFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceUserIdFB);
        }
        if (func_name == "xrDestroySpaceUserFB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroySpaceUserFB);
        }

        // ---- XR_META_recommended_layer_resolution extension commands
        if (func_name == "xrGetRecommendedLayerResolutionMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetRecommendedLayerResolutionMETA);
        }

        // ---- XR_META_passthrough_color_lut extension commands
        if (func_name == "xrCreatePassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreatePassthroughColorLutMETA);
        }
        if (func_name == "xrDestroyPassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyPassthroughColorLutMETA);
        }
        if (func_name == "xrUpdatePassthroughColorLutMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrUpdatePassthroughColorLutMETA);
        }

        // ---- XR_META_spatial_entity_mesh extension commands
        if (func_name == "xrGetSpaceTriangleMeshMETA") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpaceTriangleMeshMETA);
        }

        // ---- XR_FB_face_tracking2 extension commands
        if (func_name == "xrCreateFaceTracker2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateFaceTracker2FB);
        }
        if (func_name == "xrDestroyFaceTracker2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyFaceTracker2FB);
        }
        if (func_name == "xrGetFaceExpressionWeights2FB") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetFaceExpressionWeights2FB);
        }

        // ---- XR_QCOM_tracking_optimization_settings extension commands
        if (func_name == "xrSetTrackingOptimizationSettingsHintQCOM") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrSetTrackingOptimizationSettingsHintQCOM);
        }

        // ---- XR_HTC_passthrough extension commands
        if (func_name == "xrCreatePassthroughHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreatePassthroughHTC);
        }
        if (func_name == "xrDestroyPassthroughHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyPassthroughHTC);
        }

        // ---- XR_HTC_foveation extension commands
        if (func_name == "xrApplyFoveationHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrApplyFoveationHTC);
        }

        // ---- XR_HTC_anchor extension commands
        if (func_name == "xrCreateSpatialAnchorHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreateSpatialAnchorHTC);
        }
        if (func_name == "xrGetSpatialAnchorNameHTC") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetSpatialAnchorNameHTC);
        }

        // ---- XR_MNDX_force_feedback_curl extension commands
        if (func_name == "xrApplyForceFeedbackCurlMNDX") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrApplyForceFeedbackCurlMNDX);
        }

        // ---- XR_EXT_plane_detection extension commands
        if (func_name == "xrCreatePlaneDetectorEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrCreatePlaneDetectorEXT);
        }
        if (func_name == "xrDestroyPlaneDetectorEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrDestroyPlaneDetectorEXT);
        }
        if (func_name == "xrBeginPlaneDetectionEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrBeginPlaneDetectionEXT);
        }
        if (func_name == "xrGetPlaneDetectionStateEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetPlaneDetectionStateEXT);
        }
        if (func_name == "xrGetPlaneDetectionsEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetPlaneDetectionsEXT);
        }
        if (func_name == "xrGetPlanePolygonBufferEXT") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrGetPlanePolygonBufferEXT);
        }

        // ---- XR_ML_user_calibration extension commands
        if (func_name == "xrEnableUserCalibrationEventsML") {
            return reinterpret_cast<PFN_xrVoidFunction>(GenValidUsageXrEnableUserCalibrationEventsML);
        }
        return nullptr;
    }

// API Layer's xrGetInstanceProcAddr
XRAPI_ATTR XrResult XRAPI_CALL GenValidUsageXrGetInstanceProcAddr(
    XrInstance          instance,
    const char*         name,
    PFN_xrVoidFunction* function) {
    try {
        std::string func_name = name;
        std::vector<GenValidUsageXrObjectInfo> objects;
        if (g_instance_info.verifyHandle(&instance) == VALIDATE_XR_HANDLE_INVALID) {
            // Make sure the instance is valid if it is not XR_NULL_HANDLE
            std::vector<GenValidUsageXrObjectInfo> objects;
            objects.resize(1);
            objects[0].handle = MakeHandleGeneric(instance);
            objects[0].type = XR_OBJECT_TYPE_INSTANCE;
            CoreValidLogMessage(nullptr, "VUID-xrGetInstanceProcAddr-instance-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInstanceProcAddr", objects,
                                "Invalid instance handle provided.");
        }
        // NOTE: Can't validate "VUID-xrGetInstanceProcAddr-name-parameter" null-termination
        // If we setup the function, just return
        if (function == nullptr) {
            CoreValidLogMessage(nullptr, "VUID-xrGetInstanceProcAddr-function-parameter",
                                VALID_USAGE_DEBUG_SEVERITY_ERROR, "xrGetInstanceProcAddr", objects,
                                "function is NULL");
            return XR_ERROR_VALIDATION_FAILURE;
        }
        *function = GenValidUsageInnerGetInstanceProcAddr(name);

        // If we setup the function, just return
        if (*function != nullptr) {
            return XR_SUCCESS;
        }
        // We have not found it, so pass it down to the next layer/runtime
        GenValidUsageXrInstanceInfo* instance_valid_usage_info = g_instance_info.get(instance);
        if (nullptr == instance_valid_usage_info) {
            return XR_ERROR_HANDLE_INVALID;
        }
        return instance_valid_usage_info->dispatch_table->GetInstanceProcAddr(instance, name, function);
    } catch (...) {
        return XR_ERROR_VALIDATION_FAILURE;
    }
}

